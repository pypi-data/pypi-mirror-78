'''Internal bus transport.

Provides global Bus instances identified by a name. Arbitrary many
connections can be made to the bus. Sent data is distributed to all other
peers.
'''

__all__ = ['Bus', 'BusTransport']

import logging
import threading
import itertools as it
from queue import Queue, Empty, Full
from .transports import Transport, TransportError

_bus_instances = {}


def L():
    return logging.getLogger(__name__)


class _StopSignal:
    pass


class Bus:
    def __init__(self, name=''):
        self.name = name
        self.peers = []
        self._auto_name_counter = it.count()
        self._peer_lock = threading.Lock()

    @classmethod
    def get_instance(cls, name):
        '''Get global bus instance by name.'''
        global _bus_instances
        name = str(name)
        return _bus_instances.setdefault(name, Bus(name))

    def kill(self):
        '''Kill bus instance.

        All connected transports will stop. Their bus is set to None.
        '''
        _bus_instances.pop(self.name)
        for peer in self.peers:
            peer.stop()
            peer.bus = None

    def auto_name(self):
        '''Return an autogenerated peer name.'''
        return "%s.%d" % (self.name, next(self._auto_name_counter))

    def add_peer(self, peer):
        '''Add peer to the bus. Threadsafe.'''
        with self._peer_lock:
            self.peers.append(peer)

    def remove_peer(self, peer):
        '''Remove peer. Threadsafe.'''
        with self._peer_lock:
            self.peers.remove(peer)

    def send(self, sender_name, data, receivers=None):
        '''Send message to the bus. Threadsafe.'''
        with self._peer_lock:
            receivers = receivers or [
                peer.name for peer in self.peers if peer.name != sender_name
            ]
            peernames = set(peer.name for peer in self.peers)
            for r in receivers:
                if r not in peernames:
                    raise IOError('Sending to bus %s: Unknown receiver %s' % (self.name, r))
            for peer in self.peers:
                if peer.name in receivers:
                    peer.enqueue(sender_name, data)


class InternalTransport(Transport):
    '''Internal bus transport.

    Connects to the bus identified by ``bus_name`` with the given
    ``sender_name``.

    If ``bus_name`` is omitted, it defaults to ``internal``.

    If ``sender_name`` is omitted, it defaults to ``<bus_name>.<number>``.

    If the bus does not exist, it is created.

    Properties:
        name (str): Sender/peer name of transport
        bus  (:class:`Bus`): Bus object
        queue_size (int): queue size

    ``bus`` and ``queue_size`` are applied on ``start()`` of transport. They
    MUST not be changed while running.
    '''

    shorthand = 'internal'

    def __init__(self, bus_name='internal', sender_name='', queue_size=1000):
        super().__init__()
        self.bus = Bus.get_instance(bus_name or 'internal')
        self.name = str(sender_name) or self.bus.auto_name()
        self.queue_size = queue_size

    @classmethod
    def fromstring(cls, expression):
        '''``internal:<bus_name>:<sender_name>``

        or ``internal:<bus_name>``
        or ``internal``

        ``bus_name``, ``sender_name`` are arbitrary strings (excluding
        ``:``). One or both can be left out.
        '''
        parts = expression.split(':') + ['']*3
        bus_name, sender_name = parts[1:3]
        return cls(bus_name=bus_name, sender_name=sender_name)

    def open(self):
        '''Reinit message queue and add myself to the bus.'''
        self._queue = Queue(self.queue_size)
        self._leftovers = {}
        if not self.bus:
            raise IOError('Bus is not set')
        self.bus.add_peer(self)
        L().debug('InternalTransport connected to %s as %s', self.bus.name, self.name)

    def run(self):
        '''Process incoming data.'''
        self.running = True
        while self.running:
            try:
                indata = self._queue.get(timeout=30.0)
            except Empty:
                continue
            if indata is _StopSignal:
                break
            sender, data = indata
            leftover = self._leftovers.get(sender, b'')
            leftover = self.received(sender, leftover + data) or b''
            self._leftovers[sender] = leftover
        self.bus.remove_peer(self)
        L().debug('InternalTransport %s finished', self.name)

    def stop(self):
        '''Stop running transport.'''
        # Put sentinel object for instant stop.
        self._queue.put(_StopSignal)
        super().stop()

    def send(self, data, receivers=None):
        '''Send to the bus.

        Message is not echoed to self, unless explicitly included in ``receivers``.
        '''
        if not self.bus:
            raise IOError('Bus is not set')
        if not self.running:
            raise IOError('Transport is not running.')
        self.bus.send(self.name, bytes(data), receivers)

    def enqueue(self, sender, data):
        '''Add data to the receive queue. For internal use.'''
        self._queue.put((sender, data))
