"""Autogenerated API"""
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module

log = logging.getLogger(__name__)


@register_command(
    extending=("sensors", "v1", "type"),
    module=argus_cli_module
)
def add_sensor_type(
    shortName: str = None,
    name: str = None,
    url: str = None,
    department: str = None,
    expectedSensorUpdateTime: int = None,
    monitorCollectionOnly: bool = None,
    json: bool = True,
    verify: bool = True,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
  ) -> dict:
    """Create a new sensor type (DEV)
    
    :param str shortName: Short name of sensor type, needs to be unique  => [a-zA-Z0-9_\-\.]*
    :param str name: Name of sensor type  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str url: URL of sensor type  => ((https?|ftp|gopher|telnet|file):((/)|(\\))+[\w\d:\#@%/;$()~_?\\+-=\\\.&]*)
    :param str department: Department that the sensor type belongs to (default none)
    :param int expectedSensorUpdateTime: Expected maximum update time duration in millis of sensor which belong to the type (default 0)
    :param bool monitorCollectionOnly: Flag to determine whether sensors of this type are monitored by analysis or only by collection (default false)
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """
    from os import getenv
    from requests import post
    from argus_api._validators import validate_http_response
    
    from argus_cli.settings import settings
    
    url = "{}/sensors/v1/type".format(
        server_url or settings["api"]["api_url"],
        
    )
    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': 'application/json'
    }

    if not apiKey and "api_key" in settings["api"]:
        apiKey = settings["api"]["api_key"]

    if apiKey:
        headers["Argus-API-Key"] = apiKey
    elif authentication and isinstance(authentication, dict):
        headers.update(authentication)
    elif callable(authentication):
        headers.update(authentication(url))

    body = {}
    # Only send shortName if the argument was provided, dont send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send url if the argument was provided, dont send null values
    if url is not None:
        body.update({"url": url})
    # Only send expectedSensorUpdateTime if the argument was provided, dont send null values
    if expectedSensorUpdateTime is not None:
        body.update({"expectedSensorUpdateTime": expectedSensorUpdateTime})
    # Only send department if the argument was provided, dont send null values
    if department is not None:
        body.update({"department": department})
    # Only send monitorCollectionOnly if the argument was provided, dont send null values
    if monitorCollectionOnly is not None:
        body.update({"monitorCollectionOnly": monitorCollectionOnly})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (url, str(headers), str(body) or ""))

    response = post(
        url,
        params=query_parameters or None,
        json=body,
        verify=getenv('REQUESTS_CA_BUNDLE', verify),
        headers=headers
    )

    validate_http_response(response)
    return response.json()


@register_command(
    extending=("sensors", "v1", "type"),
    module=argus_cli_module
)
def delete_sensor_type(
    idOrShortName: str,
    newType: str = None,
    json: bool = True,
    verify: bool = True,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
  ) -> dict:
    """Delete a sensor type and update existing Sensors of that type to a new sensor type (DEV)
    
    :param str idOrShortName: Sensor type ID or short name
    :param str newType: Sensor type delete request
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """
    from os import getenv
    from requests import delete
    from argus_api._validators import validate_http_response
    
    from argus_cli.settings import settings
    
    url = "{}/sensors/v1/type/{idOrShortName}".format(
        server_url or settings["api"]["api_url"],
        idOrShortName=idOrShortName,
        newType=newType
    )
    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': 'application/json'
    }

    if not apiKey and "api_key" in settings["api"]:
        apiKey = settings["api"]["api_key"]

    if apiKey:
        headers["Argus-API-Key"] = apiKey
    elif authentication and isinstance(authentication, dict):
        headers.update(authentication)
    elif callable(authentication):
        headers.update(authentication(url))

    body = {}

    query_parameters = {}
    # Only send newType if the argument was provided, dont send null values
    if newType is not None:
        query_parameters.update({"newType": newType})

    log.debug("DELETE %s (headers: %s, body: %s)" % (url, str(headers), str(body) or ""))

    response = delete(
        url,
        params=query_parameters or None,
        verify=getenv('REQUESTS_CA_BUNDLE', verify),
        headers=headers
    )

    validate_http_response(response)
    return response.json()


@register_command(
    extending=("sensors", "v1", "type"),
    module=argus_cli_module
)
def get_sensor_type(
    idOrShortName: str,
    json: bool = True,
    verify: bool = True,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
  ) -> dict:
    """Get sensor type by ID or short name (DEV)
    
    :param str idOrShortName: Sensor type ID or short name
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """
    from os import getenv
    from requests import get
    from argus_api._validators import validate_http_response
    
    from argus_cli.settings import settings
    
    url = "{}/sensors/v1/type/{idOrShortName}".format(
        server_url or settings["api"]["api_url"],
        idOrShortName=idOrShortName
    )
    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': 'application/json'
    }

    if not apiKey and "api_key" in settings["api"]:
        apiKey = settings["api"]["api_key"]

    if apiKey:
        headers["Argus-API-Key"] = apiKey
    elif authentication and isinstance(authentication, dict):
        headers.update(authentication)
    elif callable(authentication):
        headers.update(authentication(url))

    body = {}

    query_parameters = {}

    log.debug("GET %s (headers: %s, body: %s)" % (url, str(headers), str(body) or ""))

    response = get(
        url,
        params=query_parameters or None,
        verify=getenv('REQUESTS_CA_BUNDLE', verify),
        headers=headers
    )

    validate_http_response(response)
    return response.json()


@register_command(
    extending=("sensors", "v1", "type"),
    module=argus_cli_module
)
def get_sensor_types(
    json: bool = True,
    verify: bool = True,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
  ) -> dict:
    """Get all sensor types (DEV)
    
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """
    from os import getenv
    from requests import get
    from argus_api._validators import validate_http_response
    
    from argus_cli.settings import settings
    
    url = "{}/sensors/v1/type".format(
        server_url or settings["api"]["api_url"],
        
    )
    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': 'application/json'
    }

    if not apiKey and "api_key" in settings["api"]:
        apiKey = settings["api"]["api_key"]

    if apiKey:
        headers["Argus-API-Key"] = apiKey
    elif authentication and isinstance(authentication, dict):
        headers.update(authentication)
    elif callable(authentication):
        headers.update(authentication(url))

    body = {}

    query_parameters = {}

    log.debug("GET %s (headers: %s, body: %s)" % (url, str(headers), str(body) or ""))

    response = get(
        url,
        params=query_parameters or None,
        verify=getenv('REQUESTS_CA_BUNDLE', verify),
        headers=headers
    )

    validate_http_response(response)
    return response.json()


@register_command(
    extending=("sensors", "v1", "type"),
    module=argus_cli_module
)
def update_sensor_type(
    idOrShortName: str,
    shortName: str = None,
    name: str = None,
    url: str = None,
    expectedSensorUpdateTime: int = None,
    department: str = None,
    monitorCollectionOnly: bool = None,
    json: bool = True,
    verify: bool = True,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
  ) -> dict:
    """Update a sensor type (DEV)
    
    :param str idOrShortName: Sensor type ID or short name
    :param str shortName: Update short name of sensor type, needs to be unique  => [a-zA-Z0-9_\-\.]*
    :param str name: Update name of sensor type  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str url: Update url of sensor type  => ((https?|ftp|gopher|telnet|file):((/)|(\\))+[\w\d:\#@%/;$()~_?\\+-=\\\.&]*)
    :param int expectedSensorUpdateTime: Update expected sensor update time for the sensor type 
    :param str department: Update department of sensor type 
    :param bool monitorCollectionOnly: Flag to determine whether sensors of this type are monitored by analysis or only by collection 
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """
    from os import getenv
    from requests import put
    from argus_api._validators import validate_http_response
    
    from argus_cli.settings import settings
    
    url = "{}/sensors/v1/type/{idOrShortName}".format(
        server_url or settings["api"]["api_url"],
        idOrShortName=idOrShortName
    )
    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': 'application/json'
    }

    if not apiKey and "api_key" in settings["api"]:
        apiKey = settings["api"]["api_key"]

    if apiKey:
        headers["Argus-API-Key"] = apiKey
    elif authentication and isinstance(authentication, dict):
        headers.update(authentication)
    elif callable(authentication):
        headers.update(authentication(url))

    body = {}
    # Only send shortName if the argument was provided, dont send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send url if the argument was provided, dont send null values
    if url is not None:
        body.update({"url": url})
    # Only send expectedSensorUpdateTime if the argument was provided, dont send null values
    if expectedSensorUpdateTime is not None:
        body.update({"expectedSensorUpdateTime": expectedSensorUpdateTime})
    # Only send department if the argument was provided, dont send null values
    if department is not None:
        body.update({"department": department})
    # Only send monitorCollectionOnly if the argument was provided, dont send null values
    if monitorCollectionOnly is not None:
        body.update({"monitorCollectionOnly": monitorCollectionOnly})

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (url, str(headers), str(body) or ""))

    response = put(
        url,
        params=query_parameters or None,
        json=body,
        verify=getenv('REQUESTS_CA_BUNDLE', verify),
        headers=headers
    )

    validate_http_response(response)
    return response.json()

