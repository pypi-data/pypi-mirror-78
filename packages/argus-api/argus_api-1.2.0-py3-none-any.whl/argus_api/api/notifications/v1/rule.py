"""Autogenerated API"""
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module

log = logging.getLogger(__name__)


@register_command(
    extending=("notifications", "v1", "rule"),
    module=argus_cli_module
)
def add_action(
    id: int,
    index: int,
    changeMatching: str = None,
    changeTypes: str = None,
    changeFormats: str = None,
    changeRoles: str = None,
    sender: str = None,
    setFlags: int = None,
    unsetFlags: int = None,
    subjectTemplate: dict = None,
    bodyTemplate: dict = None,
    smsTemplate: dict = None,
    json: bool = True,
    verify: bool = True,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
  ) -> dict:
    """Add notification action to rule (INTERNAL)
    
    :param int id: ID of rule to add this action to
    :param int index: Index to put this action at
    :param str changeMatching: [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param list changeTypes: 
    :param list changeFormats: 
    :param list changeRoles: 
    :param str sender: 
    :param int setFlags: 
    :param int unsetFlags: 
    :param dict subjectTemplate: format:html
    :param dict bodyTemplate: format:html
    :param dict smsTemplate: [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """
    from os import getenv
    from requests import post
    from argus_api._validators import validate_http_response
    
    from argus_cli.settings import settings
    
    url = "{}/notifications/v1/rule/{id}/actions/{index}".format(
        server_url or settings["api"]["api_url"],
        id=id,
        index=index
    )
    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': 'application/json'
    }

    if not apiKey and "api_key" in settings["api"]:
        apiKey = settings["api"]["api_key"]

    if apiKey:
        headers["Argus-API-Key"] = apiKey
    elif authentication and isinstance(authentication, dict):
        headers.update(authentication)
    elif callable(authentication):
        headers.update(authentication(url))

    body = {}
    # Only send changeMatching if the argument was provided, dont send null values
    if changeMatching is not None:
        body.update({"changeMatching": changeMatching})
    # Only send changeTypes if the argument was provided, dont send null values
    if changeTypes is not None:
        body.update({"changeTypes": changeTypes})
    # Only send changeFormats if the argument was provided, dont send null values
    if changeFormats is not None:
        body.update({"changeFormats": changeFormats})
    # Only send changeRoles if the argument was provided, dont send null values
    if changeRoles is not None:
        body.update({"changeRoles": changeRoles})
    # Only send sender if the argument was provided, dont send null values
    if sender is not None:
        body.update({"sender": sender})
    # Only send setFlags if the argument was provided, dont send null values
    if setFlags is not None:
        body.update({"setFlags": setFlags})
    # Only send unsetFlags if the argument was provided, dont send null values
    if unsetFlags is not None:
        body.update({"unsetFlags": unsetFlags})
    # Only send subjectTemplate if the argument was provided, dont send null values
    if subjectTemplate is not None:
        body.update({"subjectTemplate": subjectTemplate})
    # Only send bodyTemplate if the argument was provided, dont send null values
    if bodyTemplate is not None:
        body.update({"bodyTemplate": bodyTemplate})
    # Only send smsTemplate if the argument was provided, dont send null values
    if smsTemplate is not None:
        body.update({"smsTemplate": smsTemplate})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (url, str(headers), str(body) or ""))

    response = post(
        url,
        params=query_parameters or None,
        json=body,
        verify=getenv('REQUESTS_CA_BUNDLE', verify),
        headers=headers
    )

    validate_http_response(response)
    return response.json()


@register_command(
    extending=("notifications", "v1", "rule"),
    module=argus_cli_module
)
def add_destination(
    id: int,
    format: str = None,
    type: str = None,
    role: str = None,
    name: str = None,
    destination: str = None,
    language: str = None,
    flags: int = None,
    json: bool = True,
    verify: bool = True,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
  ) -> dict:
    """Add destination to notification rule (INTERNAL)
    
    :param int id: ID of rule to add this destination to
    :param str format: 
    :param str type: 
    :param str role: 
    :param str name: [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str destination: 
    :param str language: 
    :param int flags: 
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """
    from os import getenv
    from requests import post
    from argus_api._validators import validate_http_response
    
    from argus_cli.settings import settings
    
    url = "{}/notifications/v1/rule/{id}/destinations".format(
        server_url or settings["api"]["api_url"],
        id=id
    )
    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': 'application/json'
    }

    if not apiKey and "api_key" in settings["api"]:
        apiKey = settings["api"]["api_key"]

    if apiKey:
        headers["Argus-API-Key"] = apiKey
    elif authentication and isinstance(authentication, dict):
        headers.update(authentication)
    elif callable(authentication):
        headers.update(authentication(url))

    body = {}
    # Only send format if the argument was provided, dont send null values
    if format is not None:
        body.update({"format": format})
    # Only send type if the argument was provided, dont send null values
    if type is not None:
        body.update({"type": type})
    # Only send role if the argument was provided, dont send null values
    if role is not None:
        body.update({"role": role})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send destination if the argument was provided, dont send null values
    if destination is not None:
        body.update({"destination": destination})
    # Only send language if the argument was provided, dont send null values
    if language is not None:
        body.update({"language": language})
    # Only send flags if the argument was provided, dont send null values
    if flags is not None:
        body.update({"flags": flags})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (url, str(headers), str(body) or ""))

    response = post(
        url,
        params=query_parameters or None,
        json=body,
        verify=getenv('REQUESTS_CA_BUNDLE', verify),
        headers=headers
    )

    validate_http_response(response)
    return response.json()


@register_command(
    extending=("notifications", "v1", "rule"),
    module=argus_cli_module
)
def create(
    matchRule: str = None,
    customerID: int = None,
    setFlags: int = None,
    additionalDestinations: dict = None,
    events: str = None,
    name: str = None,
    actions: dict = None,
    index: int = None,
    json: bool = True,
    verify: bool = True,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
  ) -> dict:
    """Add notification rule (INTERNAL)
    
    :param str matchRule: 
    :param int customerID: 
    :param int setFlags: 
    :param list additionalDestinations: 
    :param list events: 
    :param str name: Notification rule name  => [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param list actions: Actions 
    :param int index: index (default 0)
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """
    from os import getenv
    from requests import post
    from argus_api._validators import validate_http_response
    
    from argus_cli.settings import settings
    
    url = "{}/notifications/v1/rule".format(
        server_url or settings["api"]["api_url"],
        
    )
    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': 'application/json'
    }

    if not apiKey and "api_key" in settings["api"]:
        apiKey = settings["api"]["api_key"]

    if apiKey:
        headers["Argus-API-Key"] = apiKey
    elif authentication and isinstance(authentication, dict):
        headers.update(authentication)
    elif callable(authentication):
        headers.update(authentication(url))

    body = {}
    # Only send matchRule if the argument was provided, dont send null values
    if matchRule is not None:
        body.update({"matchRule": matchRule})
    # Only send customerID if the argument was provided, dont send null values
    if customerID is not None:
        body.update({"customerID": customerID})
    # Only send setFlags if the argument was provided, dont send null values
    if setFlags is not None:
        body.update({"setFlags": setFlags})
    # Only send additionalDestinations if the argument was provided, dont send null values
    if additionalDestinations is not None:
        body.update({"additionalDestinations": additionalDestinations})
    # Only send events if the argument was provided, dont send null values
    if events is not None:
        body.update({"events": events})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send index if the argument was provided, dont send null values
    if index is not None:
        body.update({"index": index})
    # Only send actions if the argument was provided, dont send null values
    if actions is not None:
        body.update({"actions": actions})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (url, str(headers), str(body) or ""))

    response = post(
        url,
        params=query_parameters or None,
        json=body,
        verify=getenv('REQUESTS_CA_BUNDLE', verify),
        headers=headers
    )

    validate_http_response(response)
    return response.json()


@register_command(
    extending=("notifications", "v1", "rule"),
    module=argus_cli_module
)
def delete_action(
    id: int,
    index: int,
    json: bool = True,
    verify: bool = True,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
  ) -> dict:
    """Delete action from notification rule (INTERNAL)
    
    :param int id: ID of rule
    :param int index: Index of action to delete
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """
    from os import getenv
    from requests import delete
    from argus_api._validators import validate_http_response
    
    from argus_cli.settings import settings
    
    url = "{}/notifications/v1/rule/{id}/actions/{index}".format(
        server_url or settings["api"]["api_url"],
        id=id,
        index=index
    )
    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': 'application/json'
    }

    if not apiKey and "api_key" in settings["api"]:
        apiKey = settings["api"]["api_key"]

    if apiKey:
        headers["Argus-API-Key"] = apiKey
    elif authentication and isinstance(authentication, dict):
        headers.update(authentication)
    elif callable(authentication):
        headers.update(authentication(url))

    body = {}

    query_parameters = {}

    log.debug("DELETE %s (headers: %s, body: %s)" % (url, str(headers), str(body) or ""))

    response = delete(
        url,
        params=query_parameters or None,
        verify=getenv('REQUESTS_CA_BUNDLE', verify),
        headers=headers
    )

    validate_http_response(response)
    return response.json()


@register_command(
    extending=("notifications", "v1", "rule"),
    module=argus_cli_module
)
def delete_destination(
    id: int,
    index: int,
    json: bool = True,
    verify: bool = True,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
  ) -> dict:
    """Delete destination from notification rule (INTERNAL)
    
    :param int id: ID of rule
    :param int index: Index of destination to delete
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """
    from os import getenv
    from requests import delete
    from argus_api._validators import validate_http_response
    
    from argus_cli.settings import settings
    
    url = "{}/notifications/v1/rule/{id}/destinations/{index}".format(
        server_url or settings["api"]["api_url"],
        id=id,
        index=index
    )
    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': 'application/json'
    }

    if not apiKey and "api_key" in settings["api"]:
        apiKey = settings["api"]["api_key"]

    if apiKey:
        headers["Argus-API-Key"] = apiKey
    elif authentication and isinstance(authentication, dict):
        headers.update(authentication)
    elif callable(authentication):
        headers.update(authentication(url))

    body = {}

    query_parameters = {}

    log.debug("DELETE %s (headers: %s, body: %s)" % (url, str(headers), str(body) or ""))

    response = delete(
        url,
        params=query_parameters or None,
        verify=getenv('REQUESTS_CA_BUNDLE', verify),
        headers=headers
    )

    validate_http_response(response)
    return response.json()


@register_command(
    extending=("notifications", "v1", "rule"),
    module=argus_cli_module
)
def delete_rule(
    id: int,
    json: bool = True,
    verify: bool = True,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
  ) -> dict:
    """Delete notification rule (INTERNAL)
    
    :param int id: ID of rule to delete
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """
    from os import getenv
    from requests import delete
    from argus_api._validators import validate_http_response
    
    from argus_cli.settings import settings
    
    url = "{}/notifications/v1/rule/{id}".format(
        server_url or settings["api"]["api_url"],
        id=id
    )
    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': 'application/json'
    }

    if not apiKey and "api_key" in settings["api"]:
        apiKey = settings["api"]["api_key"]

    if apiKey:
        headers["Argus-API-Key"] = apiKey
    elif authentication and isinstance(authentication, dict):
        headers.update(authentication)
    elif callable(authentication):
        headers.update(authentication(url))

    body = {}

    query_parameters = {}

    log.debug("DELETE %s (headers: %s, body: %s)" % (url, str(headers), str(body) or ""))

    response = delete(
        url,
        params=query_parameters or None,
        verify=getenv('REQUESTS_CA_BUNDLE', verify),
        headers=headers
    )

    validate_http_response(response)
    return response.json()


@register_command(
    extending=("notifications", "v1", "rule"),
    module=argus_cli_module
)
def duplicate_rule(
    id: int,
    json: bool = True,
    verify: bool = True,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
  ) -> dict:
    """Duplicate this notification rule (INTERNAL)
    
    :param int id: ID of rule to duplicate
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """
    from os import getenv
    from requests import post
    from argus_api._validators import validate_http_response
    
    from argus_cli.settings import settings
    
    url = "{}/notifications/v1/rule/{id}/duplicate".format(
        server_url or settings["api"]["api_url"],
        id=id
    )
    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': 'application/json'
    }

    if not apiKey and "api_key" in settings["api"]:
        apiKey = settings["api"]["api_key"]

    if apiKey:
        headers["Argus-API-Key"] = apiKey
    elif authentication and isinstance(authentication, dict):
        headers.update(authentication)
    elif callable(authentication):
        headers.update(authentication(url))

    body = {}

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (url, str(headers), str(body) or ""))

    response = post(
        url,
        params=query_parameters or None,
        json=body,
        verify=getenv('REQUESTS_CA_BUNDLE', verify),
        headers=headers
    )

    validate_http_response(response)
    return response.json()


@register_command(
    extending=("notifications", "v1", "rule"),
    module=argus_cli_module
)
def get_rule_by_id(
    id: int,
    json: bool = True,
    verify: bool = True,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
  ) -> dict:
    """Fetch notification rule (INTERNAL)
    
    :param int id: ID of rule to fetch
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """
    from os import getenv
    from requests import get
    from argus_api._validators import validate_http_response
    
    from argus_cli.settings import settings
    
    url = "{}/notifications/v1/rule/{id}".format(
        server_url or settings["api"]["api_url"],
        id=id
    )
    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': 'application/json'
    }

    if not apiKey and "api_key" in settings["api"]:
        apiKey = settings["api"]["api_key"]

    if apiKey:
        headers["Argus-API-Key"] = apiKey
    elif authentication and isinstance(authentication, dict):
        headers.update(authentication)
    elif callable(authentication):
        headers.update(authentication(url))

    body = {}

    query_parameters = {}

    log.debug("GET %s (headers: %s, body: %s)" % (url, str(headers), str(body) or ""))

    response = get(
        url,
        params=query_parameters or None,
        verify=getenv('REQUESTS_CA_BUNDLE', verify),
        headers=headers
    )

    validate_http_response(response)
    return response.json()


@register_command(
    extending=("notifications", "v1", "rule"),
    module=argus_cli_module
)
def get_rule_by_name(
    name: str,
    json: bool = True,
    verify: bool = True,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
  ) -> dict:
    """Fetch notification rule (INTERNAL)
    
    :param str name: Name of rule to fetch
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """
    from os import getenv
    from requests import get
    from argus_api._validators import validate_http_response
    
    from argus_cli.settings import settings
    
    url = "{}/notifications/v1/rule/{name}".format(
        server_url or settings["api"]["api_url"],
        name=name
    )
    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': 'application/json'
    }

    if not apiKey and "api_key" in settings["api"]:
        apiKey = settings["api"]["api_key"]

    if apiKey:
        headers["Argus-API-Key"] = apiKey
    elif authentication and isinstance(authentication, dict):
        headers.update(authentication)
    elif callable(authentication):
        headers.update(authentication(url))

    body = {}

    query_parameters = {}

    log.debug("GET %s (headers: %s, body: %s)" % (url, str(headers), str(body) or ""))

    response = get(
        url,
        params=query_parameters or None,
        verify=getenv('REQUESTS_CA_BUNDLE', verify),
        headers=headers
    )

    validate_http_response(response)
    return response.json()


@register_command(
    extending=("notifications", "v1", "rule"),
    module=argus_cli_module
)
def list(
    includeDeleted: bool = None,
    includeFlags: int = None,
    excludeFlags: int = None,
    customerID: int = None,
    offset: int = None,
    events: str = None,
    limit: int = 25,
    json: bool = True,
    verify: bool = True,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
  ) -> dict:
    """List notification rules (INTERNAL)
    
    :param bool includeDeleted: Include deleted rules
    :param int includeFlags: Limit result to rules with these flagbits set
    :param int excludeFlags: Limit result to rules with these flagbits unset
    :param list customerID: Limit result to rules for these customers
    :param int offset: Offset result
    :param list events: Limit result to rules for these events
    :param int limit: Limit result
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """
    from os import getenv
    from requests import get
    from argus_api._validators import validate_http_response
    
    from argus_cli.settings import settings
    
    url = "{}/notifications/v1/rule".format(
        server_url or settings["api"]["api_url"],
        limit=limit,
        includeDeleted=includeDeleted,
        includeFlags=includeFlags,
        excludeFlags=excludeFlags,
        customerID=customerID,
        offset=offset,
        events=events
    )
    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': 'application/json'
    }

    if not apiKey and "api_key" in settings["api"]:
        apiKey = settings["api"]["api_key"]

    if apiKey:
        headers["Argus-API-Key"] = apiKey
    elif authentication and isinstance(authentication, dict):
        headers.update(authentication)
    elif callable(authentication):
        headers.update(authentication(url))

    body = {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send includeDeleted if the argument was provided, dont send null values
    if includeDeleted is not None:
        query_parameters.update({"includeDeleted": includeDeleted})
    # Only send includeFlags if the argument was provided, dont send null values
    if includeFlags is not None:
        query_parameters.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, dont send null values
    if excludeFlags is not None:
        query_parameters.update({"excludeFlags": excludeFlags})
    # Only send customerID if the argument was provided, dont send null values
    if customerID is not None:
        query_parameters.update({"customerID": customerID})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send events if the argument was provided, dont send null values
    if events is not None:
        query_parameters.update({"events": events})

    log.debug("GET %s (headers: %s, body: %s)" % (url, str(headers), str(body) or ""))

    response = get(
        url,
        params=query_parameters or None,
        verify=getenv('REQUESTS_CA_BUNDLE', verify),
        headers=headers
    )

    validate_http_response(response)
    return response.json()


@register_command(
    extending=("notifications", "v1", "rule"),
    module=argus_cli_module
)
def list_1(
    events: int = None,
    searchString: str = None,
    masterID: int = None,
    encodedEvents: str = None,
    limit: int = None,
    offset: int = None,
    includeDeleted: bool = None,
    includeFlags: int = None,
    excludeFlags: int = None,
    customerID: int = None,
    sortBy: str = None,
    startTimestamp: int = None,
    endTimestamp: int = None,
    json: bool = True,
    verify: bool = True,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
  ) -> dict:
    """Search notification rules (INTERNAL)
    
    :param int events: 
    :param str searchString: 
    :param int masterID: 
    :param list encodedEvents: 
    :param int limit: Limit results 
    :param int offset: Offset results 
    :param bool includeDeleted: Also include deleted objects (where implemented) 
    :param int includeFlags: Search objects with these flags set 
    :param int excludeFlags: Exclude objects with these flags set 
    :param list customerID: Limit result to objects belonging to these customers 
    :param list sortBy: Order results by these properties (prefix with - to sort descending) 
    :param int startTimestamp: Search objects from this timestamp 
    :param int endTimestamp: Search objects until this timestamp 
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """
    from os import getenv
    from requests import post
    from argus_api._validators import validate_http_response
    
    from argus_cli.settings import settings
    
    url = "{}/notifications/v1/rule/search".format(
        server_url or settings["api"]["api_url"],
        
    )
    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': 'application/json'
    }

    if not apiKey and "api_key" in settings["api"]:
        apiKey = settings["api"]["api_key"]

    if apiKey:
        headers["Argus-API-Key"] = apiKey
    elif authentication and isinstance(authentication, dict):
        headers.update(authentication)
    elif callable(authentication):
        headers.update(authentication(url))

    body = {}
    # Only send events if the argument was provided, dont send null values
    if events is not None:
        body.update({"events": events})
    # Only send searchString if the argument was provided, dont send null values
    if searchString is not None:
        body.update({"searchString": searchString})
    # Only send masterID if the argument was provided, dont send null values
    if masterID is not None:
        body.update({"masterID": masterID})
    # Only send encodedEvents if the argument was provided, dont send null values
    if encodedEvents is not None:
        body.update({"encodedEvents": encodedEvents})
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, dont send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send includeFlags if the argument was provided, dont send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, dont send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send customerID if the argument was provided, dont send null values
    if customerID is not None:
        body.update({"customerID": customerID})
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send startTimestamp if the argument was provided, dont send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, dont send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})

    query_parameters = {}

    log.debug("POST %s (headers: %s, body: %s)" % (url, str(headers), str(body) or ""))

    response = post(
        url,
        params=query_parameters or None,
        json=body,
        verify=getenv('REQUESTS_CA_BUNDLE', verify),
        headers=headers
    )

    validate_http_response(response)
    return response.json()


@register_command(
    extending=("notifications", "v1", "rule"),
    module=argus_cli_module
)
def revisions(
    id: int,
    offset: int = None,
    limit: int = 25,
    json: bool = True,
    verify: bool = True,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
  ) -> dict:
    """List revisions of notification rule (INTERNAL)
    
    :param int id: ID of rule to fetch
    :param int offset: Offset result
    :param int limit: Limit result
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """
    from os import getenv
    from requests import get
    from argus_api._validators import validate_http_response
    
    from argus_cli.settings import settings
    
    url = "{}/notifications/v1/rule/{id}/revisions".format(
        server_url or settings["api"]["api_url"],
        limit=limit,
        id=id,
        offset=offset
    )
    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': 'application/json'
    }

    if not apiKey and "api_key" in settings["api"]:
        apiKey = settings["api"]["api_key"]

    if apiKey:
        headers["Argus-API-Key"] = apiKey
    elif authentication and isinstance(authentication, dict):
        headers.update(authentication)
    elif callable(authentication):
        headers.update(authentication(url))

    body = {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    log.debug("GET %s (headers: %s, body: %s)" % (url, str(headers), str(body) or ""))

    response = get(
        url,
        params=query_parameters or None,
        verify=getenv('REQUESTS_CA_BUNDLE', verify),
        headers=headers
    )

    validate_http_response(response)
    return response.json()


@register_command(
    extending=("notifications", "v1", "rule"),
    module=argus_cli_module
)
def update_action(
    id: int,
    index: int,
    changeMatching: str = None,
    changeTypes: str = None,
    changeFormats: str = None,
    changeRoles: str = None,
    sender: str = None,
    setFlags: int = None,
    unsetFlags: int = None,
    subjectTemplate: dict = None,
    bodyTemplate: dict = None,
    smsTemplate: dict = None,
    json: bool = True,
    verify: bool = True,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
  ) -> dict:
    """Update notification rule action (INTERNAL)
    
    :param int id: ID of rule to update
    :param int index: Index of action to update
    :param str changeMatching: [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param list changeTypes: 
    :param list changeFormats: 
    :param list changeRoles: 
    :param str sender: 
    :param int setFlags: 
    :param int unsetFlags: 
    :param dict subjectTemplate: format:html
    :param dict bodyTemplate: format:html
    :param dict smsTemplate: [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """
    from os import getenv
    from requests import put
    from argus_api._validators import validate_http_response
    
    from argus_cli.settings import settings
    
    url = "{}/notifications/v1/rule/{id}/actions/{index}".format(
        server_url or settings["api"]["api_url"],
        id=id,
        index=index
    )
    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': 'application/json'
    }

    if not apiKey and "api_key" in settings["api"]:
        apiKey = settings["api"]["api_key"]

    if apiKey:
        headers["Argus-API-Key"] = apiKey
    elif authentication and isinstance(authentication, dict):
        headers.update(authentication)
    elif callable(authentication):
        headers.update(authentication(url))

    body = {}
    # Only send changeMatching if the argument was provided, dont send null values
    if changeMatching is not None:
        body.update({"changeMatching": changeMatching})
    # Only send changeTypes if the argument was provided, dont send null values
    if changeTypes is not None:
        body.update({"changeTypes": changeTypes})
    # Only send changeFormats if the argument was provided, dont send null values
    if changeFormats is not None:
        body.update({"changeFormats": changeFormats})
    # Only send changeRoles if the argument was provided, dont send null values
    if changeRoles is not None:
        body.update({"changeRoles": changeRoles})
    # Only send sender if the argument was provided, dont send null values
    if sender is not None:
        body.update({"sender": sender})
    # Only send setFlags if the argument was provided, dont send null values
    if setFlags is not None:
        body.update({"setFlags": setFlags})
    # Only send unsetFlags if the argument was provided, dont send null values
    if unsetFlags is not None:
        body.update({"unsetFlags": unsetFlags})
    # Only send subjectTemplate if the argument was provided, dont send null values
    if subjectTemplate is not None:
        body.update({"subjectTemplate": subjectTemplate})
    # Only send bodyTemplate if the argument was provided, dont send null values
    if bodyTemplate is not None:
        body.update({"bodyTemplate": bodyTemplate})
    # Only send smsTemplate if the argument was provided, dont send null values
    if smsTemplate is not None:
        body.update({"smsTemplate": smsTemplate})

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (url, str(headers), str(body) or ""))

    response = put(
        url,
        params=query_parameters or None,
        json=body,
        verify=getenv('REQUESTS_CA_BUNDLE', verify),
        headers=headers
    )

    validate_http_response(response)
    return response.json()


@register_command(
    extending=("notifications", "v1", "rule"),
    module=argus_cli_module
)
def update_destination(
    id: int,
    index: int,
    format: str = None,
    type: str = None,
    role: str = None,
    name: str = None,
    destination: str = None,
    language: str = None,
    flags: int = None,
    json: bool = True,
    verify: bool = True,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
  ) -> dict:
    """Update notification rule destination (INTERNAL)
    
    :param int id: ID of rule to update
    :param int index: Index of destination to update
    :param str format: 
    :param str type: 
    :param str role: 
    :param str name: [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str destination: 
    :param str language: 
    :param int flags: 
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """
    from os import getenv
    from requests import put
    from argus_api._validators import validate_http_response
    
    from argus_cli.settings import settings
    
    url = "{}/notifications/v1/rule/{id}/destinations/{index}".format(
        server_url or settings["api"]["api_url"],
        id=id,
        index=index
    )
    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': 'application/json'
    }

    if not apiKey and "api_key" in settings["api"]:
        apiKey = settings["api"]["api_key"]

    if apiKey:
        headers["Argus-API-Key"] = apiKey
    elif authentication and isinstance(authentication, dict):
        headers.update(authentication)
    elif callable(authentication):
        headers.update(authentication(url))

    body = {}
    # Only send format if the argument was provided, dont send null values
    if format is not None:
        body.update({"format": format})
    # Only send type if the argument was provided, dont send null values
    if type is not None:
        body.update({"type": type})
    # Only send role if the argument was provided, dont send null values
    if role is not None:
        body.update({"role": role})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send destination if the argument was provided, dont send null values
    if destination is not None:
        body.update({"destination": destination})
    # Only send language if the argument was provided, dont send null values
    if language is not None:
        body.update({"language": language})
    # Only send flags if the argument was provided, dont send null values
    if flags is not None:
        body.update({"flags": flags})

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (url, str(headers), str(body) or ""))

    response = put(
        url,
        params=query_parameters or None,
        json=body,
        verify=getenv('REQUESTS_CA_BUNDLE', verify),
        headers=headers
    )

    validate_http_response(response)
    return response.json()


@register_command(
    extending=("notifications", "v1", "rule"),
    module=argus_cli_module
)
def update_rule(
    id: int,
    name: str = None,
    matchRule: str = None,
    setFlags: int = None,
    unsetFlags: int = None,
    actions: dict = None,
    additionalDestinations: dict = None,
    events: str = None,
    index: int = None,
    json: bool = True,
    verify: bool = True,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
  ) -> dict:
    """Update notification rule (INTERNAL)
    
    :param int id: ID of rule to update
    :param str name: [\s\w\{\}\$\-\(\)\.\[\]"\'_/\\,\*\+\#:@!?;=]*
    :param str matchRule: 
    :param int setFlags: 
    :param int unsetFlags: 
    :param list actions: 
    :param list additionalDestinations: 
    :param list events: 
    :param int index: index (default null)
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns dictionary translated from JSON
    """
    from os import getenv
    from requests import put
    from argus_api._validators import validate_http_response
    
    from argus_cli.settings import settings
    
    url = "{}/notifications/v1/rule/{id}".format(
        server_url or settings["api"]["api_url"],
        id=id
    )
    headers = {
        'User-Agent': 'ArgusToolbelt/',
        'content': 'application/json'
    }

    if not apiKey and "api_key" in settings["api"]:
        apiKey = settings["api"]["api_key"]

    if apiKey:
        headers["Argus-API-Key"] = apiKey
    elif authentication and isinstance(authentication, dict):
        headers.update(authentication)
    elif callable(authentication):
        headers.update(authentication(url))

    body = {}
    # Only send id if the argument was provided, dont send null values
    if id is not None:
        body.update({"id": id})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send matchRule if the argument was provided, dont send null values
    if matchRule is not None:
        body.update({"matchRule": matchRule})
    # Only send setFlags if the argument was provided, dont send null values
    if setFlags is not None:
        body.update({"setFlags": setFlags})
    # Only send unsetFlags if the argument was provided, dont send null values
    if unsetFlags is not None:
        body.update({"unsetFlags": unsetFlags})
    # Only send actions if the argument was provided, dont send null values
    if actions is not None:
        body.update({"actions": actions})
    # Only send additionalDestinations if the argument was provided, dont send null values
    if additionalDestinations is not None:
        body.update({"additionalDestinations": additionalDestinations})
    # Only send events if the argument was provided, dont send null values
    if events is not None:
        body.update({"events": events})
    # Only send index if the argument was provided, dont send null values
    if index is not None:
        body.update({"index": index})

    query_parameters = {}

    log.debug("PUT %s (headers: %s, body: %s)" % (url, str(headers), str(body) or ""))

    response = put(
        url,
        params=query_parameters or None,
        json=body,
        verify=getenv('REQUESTS_CA_BUNDLE', verify),
        headers=headers
    )

    validate_http_response(response)
    return response.json()

