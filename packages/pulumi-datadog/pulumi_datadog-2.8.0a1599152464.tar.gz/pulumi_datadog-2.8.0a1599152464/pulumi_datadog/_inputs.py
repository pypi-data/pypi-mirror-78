# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Dict, List, Mapping, Optional, Tuple, Union
from . import _utilities, _tables

__all__ = [
    'DashboardListDashItemArgs',
    'DashboardTemplateVariableArgs',
    'DashboardTemplateVariablePresetArgs',
    'DashboardTemplateVariablePresetTemplateVariableArgs',
    'DashboardWidgetArgs',
    'DashboardWidgetAlertGraphDefinitionArgs',
    'DashboardWidgetAlertGraphDefinitionTimeArgs',
    'DashboardWidgetAlertValueDefinitionArgs',
    'DashboardWidgetChangeDefinitionArgs',
    'DashboardWidgetChangeDefinitionRequestArgs',
    'DashboardWidgetChangeDefinitionRequestApmQueryArgs',
    'DashboardWidgetChangeDefinitionRequestApmQueryComputeArgs',
    'DashboardWidgetChangeDefinitionRequestApmQueryGroupByArgs',
    'DashboardWidgetChangeDefinitionRequestApmQueryGroupBySortArgs',
    'DashboardWidgetChangeDefinitionRequestApmQuerySearchArgs',
    'DashboardWidgetChangeDefinitionRequestLogQueryArgs',
    'DashboardWidgetChangeDefinitionRequestLogQueryComputeArgs',
    'DashboardWidgetChangeDefinitionRequestLogQueryGroupByArgs',
    'DashboardWidgetChangeDefinitionRequestLogQueryGroupBySortArgs',
    'DashboardWidgetChangeDefinitionRequestLogQuerySearchArgs',
    'DashboardWidgetChangeDefinitionRequestProcessQueryArgs',
    'DashboardWidgetChangeDefinitionTimeArgs',
    'DashboardWidgetCheckStatusDefinitionArgs',
    'DashboardWidgetCheckStatusDefinitionTimeArgs',
    'DashboardWidgetDistributionDefinitionArgs',
    'DashboardWidgetDistributionDefinitionRequestArgs',
    'DashboardWidgetDistributionDefinitionRequestApmQueryArgs',
    'DashboardWidgetDistributionDefinitionRequestApmQueryComputeArgs',
    'DashboardWidgetDistributionDefinitionRequestApmQueryGroupByArgs',
    'DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySortArgs',
    'DashboardWidgetDistributionDefinitionRequestApmQuerySearchArgs',
    'DashboardWidgetDistributionDefinitionRequestLogQueryArgs',
    'DashboardWidgetDistributionDefinitionRequestLogQueryComputeArgs',
    'DashboardWidgetDistributionDefinitionRequestLogQueryGroupByArgs',
    'DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySortArgs',
    'DashboardWidgetDistributionDefinitionRequestLogQuerySearchArgs',
    'DashboardWidgetDistributionDefinitionRequestProcessQueryArgs',
    'DashboardWidgetDistributionDefinitionRequestStyleArgs',
    'DashboardWidgetDistributionDefinitionTimeArgs',
    'DashboardWidgetEventStreamDefinitionArgs',
    'DashboardWidgetEventStreamDefinitionTimeArgs',
    'DashboardWidgetEventTimelineDefinitionArgs',
    'DashboardWidgetEventTimelineDefinitionTimeArgs',
    'DashboardWidgetFreeTextDefinitionArgs',
    'DashboardWidgetGroupDefinitionArgs',
    'DashboardWidgetGroupDefinitionWidgetArgs',
    'DashboardWidgetGroupDefinitionWidgetAlertGraphDefinitionArgs',
    'DashboardWidgetGroupDefinitionWidgetAlertGraphDefinitionTimeArgs',
    'DashboardWidgetGroupDefinitionWidgetAlertValueDefinitionArgs',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionArgs',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestArgs',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeArgs',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupByArgs',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortArgs',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuerySearchArgs',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeArgs',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupByArgs',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortArgs',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuerySearchArgs',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionTimeArgs',
    'DashboardWidgetGroupDefinitionWidgetCheckStatusDefinitionArgs',
    'DashboardWidgetGroupDefinitionWidgetCheckStatusDefinitionTimeArgs',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionArgs',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestArgs',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeArgs',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupByArgs',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortArgs',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuerySearchArgs',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeArgs',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupByArgs',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortArgs',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuerySearchArgs',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyleArgs',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionTimeArgs',
    'DashboardWidgetGroupDefinitionWidgetEventStreamDefinitionArgs',
    'DashboardWidgetGroupDefinitionWidgetEventStreamDefinitionTimeArgs',
    'DashboardWidgetGroupDefinitionWidgetEventTimelineDefinitionArgs',
    'DashboardWidgetGroupDefinitionWidgetEventTimelineDefinitionTimeArgs',
    'DashboardWidgetGroupDefinitionWidgetFreeTextDefinitionArgs',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionArgs',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEventArgs',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestArgs',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeArgs',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupByArgs',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortArgs',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuerySearchArgs',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeArgs',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupByArgs',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortArgs',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuerySearchArgs',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyleArgs',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionTimeArgs',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxisArgs',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionArgs',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestArgs',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillArgs',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeArgs',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupByArgs',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortArgs',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuerySearchArgs',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeArgs',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupByArgs',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortArgs',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuerySearchArgs',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeArgs',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeArgs',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupByArgs',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortArgs',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuerySearchArgs',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeArgs',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupByArgs',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortArgs',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuerySearchArgs',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyleArgs',
    'DashboardWidgetGroupDefinitionWidgetIframeDefinitionArgs',
    'DashboardWidgetGroupDefinitionWidgetImageDefinitionArgs',
    'DashboardWidgetGroupDefinitionWidgetLayoutArgs',
    'DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionArgs',
    'DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSortArgs',
    'DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionTimeArgs',
    'DashboardWidgetGroupDefinitionWidgetManageStatusDefinitionArgs',
    'DashboardWidgetGroupDefinitionWidgetNoteDefinitionArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupByArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuerySearchArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormatArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupByArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuerySearchArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionTimeArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupByArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuerySearchArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormatArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupByArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuerySearchArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTimeArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupByArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuerySearchArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupByArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuerySearchArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupByArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuerySearchArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupByArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuerySearchArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionTimeArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxisArgs',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxisArgs',
    'DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinitionArgs',
    'DashboardWidgetGroupDefinitionWidgetServicemapDefinitionArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEventArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarkerArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupByArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuerySearchArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupByArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuerySearchArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadataArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuerySearchArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupByArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuerySearchArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyleArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionTimeArgs',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxisArgs',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionArgs',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestArgs',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeArgs',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupByArgs',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortArgs',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuerySearchArgs',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormatArgs',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeArgs',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupByArgs',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortArgs',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuerySearchArgs',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQueryArgs',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyleArgs',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionTimeArgs',
    'DashboardWidgetGroupDefinitionWidgetTraceServiceDefinitionArgs',
    'DashboardWidgetGroupDefinitionWidgetTraceServiceDefinitionTimeArgs',
    'DashboardWidgetHeatmapDefinitionArgs',
    'DashboardWidgetHeatmapDefinitionEventArgs',
    'DashboardWidgetHeatmapDefinitionRequestArgs',
    'DashboardWidgetHeatmapDefinitionRequestApmQueryArgs',
    'DashboardWidgetHeatmapDefinitionRequestApmQueryComputeArgs',
    'DashboardWidgetHeatmapDefinitionRequestApmQueryGroupByArgs',
    'DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySortArgs',
    'DashboardWidgetHeatmapDefinitionRequestApmQuerySearchArgs',
    'DashboardWidgetHeatmapDefinitionRequestLogQueryArgs',
    'DashboardWidgetHeatmapDefinitionRequestLogQueryComputeArgs',
    'DashboardWidgetHeatmapDefinitionRequestLogQueryGroupByArgs',
    'DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySortArgs',
    'DashboardWidgetHeatmapDefinitionRequestLogQuerySearchArgs',
    'DashboardWidgetHeatmapDefinitionRequestProcessQueryArgs',
    'DashboardWidgetHeatmapDefinitionRequestStyleArgs',
    'DashboardWidgetHeatmapDefinitionTimeArgs',
    'DashboardWidgetHeatmapDefinitionYaxisArgs',
    'DashboardWidgetHostmapDefinitionArgs',
    'DashboardWidgetHostmapDefinitionRequestArgs',
    'DashboardWidgetHostmapDefinitionRequestFillArgs',
    'DashboardWidgetHostmapDefinitionRequestFillApmQueryArgs',
    'DashboardWidgetHostmapDefinitionRequestFillApmQueryComputeArgs',
    'DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupByArgs',
    'DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySortArgs',
    'DashboardWidgetHostmapDefinitionRequestFillApmQuerySearchArgs',
    'DashboardWidgetHostmapDefinitionRequestFillLogQueryArgs',
    'DashboardWidgetHostmapDefinitionRequestFillLogQueryComputeArgs',
    'DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupByArgs',
    'DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySortArgs',
    'DashboardWidgetHostmapDefinitionRequestFillLogQuerySearchArgs',
    'DashboardWidgetHostmapDefinitionRequestFillProcessQueryArgs',
    'DashboardWidgetHostmapDefinitionRequestSizeArgs',
    'DashboardWidgetHostmapDefinitionRequestSizeApmQueryArgs',
    'DashboardWidgetHostmapDefinitionRequestSizeApmQueryComputeArgs',
    'DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupByArgs',
    'DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortArgs',
    'DashboardWidgetHostmapDefinitionRequestSizeApmQuerySearchArgs',
    'DashboardWidgetHostmapDefinitionRequestSizeLogQueryArgs',
    'DashboardWidgetHostmapDefinitionRequestSizeLogQueryComputeArgs',
    'DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupByArgs',
    'DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortArgs',
    'DashboardWidgetHostmapDefinitionRequestSizeLogQuerySearchArgs',
    'DashboardWidgetHostmapDefinitionRequestSizeProcessQueryArgs',
    'DashboardWidgetHostmapDefinitionStyleArgs',
    'DashboardWidgetIframeDefinitionArgs',
    'DashboardWidgetImageDefinitionArgs',
    'DashboardWidgetLayoutArgs',
    'DashboardWidgetLogStreamDefinitionArgs',
    'DashboardWidgetLogStreamDefinitionSortArgs',
    'DashboardWidgetLogStreamDefinitionTimeArgs',
    'DashboardWidgetManageStatusDefinitionArgs',
    'DashboardWidgetNoteDefinitionArgs',
    'DashboardWidgetQueryTableDefinitionArgs',
    'DashboardWidgetQueryTableDefinitionRequestArgs',
    'DashboardWidgetQueryTableDefinitionRequestApmQueryArgs',
    'DashboardWidgetQueryTableDefinitionRequestApmQueryComputeArgs',
    'DashboardWidgetQueryTableDefinitionRequestApmQueryGroupByArgs',
    'DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySortArgs',
    'DashboardWidgetQueryTableDefinitionRequestApmQuerySearchArgs',
    'DashboardWidgetQueryTableDefinitionRequestConditionalFormatArgs',
    'DashboardWidgetQueryTableDefinitionRequestLogQueryArgs',
    'DashboardWidgetQueryTableDefinitionRequestLogQueryComputeArgs',
    'DashboardWidgetQueryTableDefinitionRequestLogQueryGroupByArgs',
    'DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySortArgs',
    'DashboardWidgetQueryTableDefinitionRequestLogQuerySearchArgs',
    'DashboardWidgetQueryTableDefinitionRequestProcessQueryArgs',
    'DashboardWidgetQueryTableDefinitionTimeArgs',
    'DashboardWidgetQueryValueDefinitionArgs',
    'DashboardWidgetQueryValueDefinitionRequestArgs',
    'DashboardWidgetQueryValueDefinitionRequestApmQueryArgs',
    'DashboardWidgetQueryValueDefinitionRequestApmQueryComputeArgs',
    'DashboardWidgetQueryValueDefinitionRequestApmQueryGroupByArgs',
    'DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySortArgs',
    'DashboardWidgetQueryValueDefinitionRequestApmQuerySearchArgs',
    'DashboardWidgetQueryValueDefinitionRequestConditionalFormatArgs',
    'DashboardWidgetQueryValueDefinitionRequestLogQueryArgs',
    'DashboardWidgetQueryValueDefinitionRequestLogQueryComputeArgs',
    'DashboardWidgetQueryValueDefinitionRequestLogQueryGroupByArgs',
    'DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySortArgs',
    'DashboardWidgetQueryValueDefinitionRequestLogQuerySearchArgs',
    'DashboardWidgetQueryValueDefinitionRequestProcessQueryArgs',
    'DashboardWidgetQueryValueDefinitionTimeArgs',
    'DashboardWidgetScatterplotDefinitionArgs',
    'DashboardWidgetScatterplotDefinitionRequestArgs',
    'DashboardWidgetScatterplotDefinitionRequestXArgs',
    'DashboardWidgetScatterplotDefinitionRequestXApmQueryArgs',
    'DashboardWidgetScatterplotDefinitionRequestXApmQueryComputeArgs',
    'DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupByArgs',
    'DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySortArgs',
    'DashboardWidgetScatterplotDefinitionRequestXApmQuerySearchArgs',
    'DashboardWidgetScatterplotDefinitionRequestXLogQueryArgs',
    'DashboardWidgetScatterplotDefinitionRequestXLogQueryComputeArgs',
    'DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupByArgs',
    'DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySortArgs',
    'DashboardWidgetScatterplotDefinitionRequestXLogQuerySearchArgs',
    'DashboardWidgetScatterplotDefinitionRequestXProcessQueryArgs',
    'DashboardWidgetScatterplotDefinitionRequestYArgs',
    'DashboardWidgetScatterplotDefinitionRequestYApmQueryArgs',
    'DashboardWidgetScatterplotDefinitionRequestYApmQueryComputeArgs',
    'DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupByArgs',
    'DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySortArgs',
    'DashboardWidgetScatterplotDefinitionRequestYApmQuerySearchArgs',
    'DashboardWidgetScatterplotDefinitionRequestYLogQueryArgs',
    'DashboardWidgetScatterplotDefinitionRequestYLogQueryComputeArgs',
    'DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupByArgs',
    'DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySortArgs',
    'DashboardWidgetScatterplotDefinitionRequestYLogQuerySearchArgs',
    'DashboardWidgetScatterplotDefinitionRequestYProcessQueryArgs',
    'DashboardWidgetScatterplotDefinitionTimeArgs',
    'DashboardWidgetScatterplotDefinitionXaxisArgs',
    'DashboardWidgetScatterplotDefinitionYaxisArgs',
    'DashboardWidgetServiceLevelObjectiveDefinitionArgs',
    'DashboardWidgetServicemapDefinitionArgs',
    'DashboardWidgetTimeseriesDefinitionArgs',
    'DashboardWidgetTimeseriesDefinitionEventArgs',
    'DashboardWidgetTimeseriesDefinitionMarkerArgs',
    'DashboardWidgetTimeseriesDefinitionRequestArgs',
    'DashboardWidgetTimeseriesDefinitionRequestApmQueryArgs',
    'DashboardWidgetTimeseriesDefinitionRequestApmQueryComputeArgs',
    'DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupByArgs',
    'DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySortArgs',
    'DashboardWidgetTimeseriesDefinitionRequestApmQuerySearchArgs',
    'DashboardWidgetTimeseriesDefinitionRequestLogQueryArgs',
    'DashboardWidgetTimeseriesDefinitionRequestLogQueryComputeArgs',
    'DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupByArgs',
    'DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySortArgs',
    'DashboardWidgetTimeseriesDefinitionRequestLogQuerySearchArgs',
    'DashboardWidgetTimeseriesDefinitionRequestMetadataArgs',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryArgs',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeArgs',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortArgs',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQuerySearchArgs',
    'DashboardWidgetTimeseriesDefinitionRequestProcessQueryArgs',
    'DashboardWidgetTimeseriesDefinitionRequestRumQueryArgs',
    'DashboardWidgetTimeseriesDefinitionRequestRumQueryComputeArgs',
    'DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupByArgs',
    'DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySortArgs',
    'DashboardWidgetTimeseriesDefinitionRequestRumQuerySearchArgs',
    'DashboardWidgetTimeseriesDefinitionRequestStyleArgs',
    'DashboardWidgetTimeseriesDefinitionTimeArgs',
    'DashboardWidgetTimeseriesDefinitionYaxisArgs',
    'DashboardWidgetToplistDefinitionArgs',
    'DashboardWidgetToplistDefinitionRequestArgs',
    'DashboardWidgetToplistDefinitionRequestApmQueryArgs',
    'DashboardWidgetToplistDefinitionRequestApmQueryComputeArgs',
    'DashboardWidgetToplistDefinitionRequestApmQueryGroupByArgs',
    'DashboardWidgetToplistDefinitionRequestApmQueryGroupBySortArgs',
    'DashboardWidgetToplistDefinitionRequestApmQuerySearchArgs',
    'DashboardWidgetToplistDefinitionRequestConditionalFormatArgs',
    'DashboardWidgetToplistDefinitionRequestLogQueryArgs',
    'DashboardWidgetToplistDefinitionRequestLogQueryComputeArgs',
    'DashboardWidgetToplistDefinitionRequestLogQueryGroupByArgs',
    'DashboardWidgetToplistDefinitionRequestLogQueryGroupBySortArgs',
    'DashboardWidgetToplistDefinitionRequestLogQuerySearchArgs',
    'DashboardWidgetToplistDefinitionRequestProcessQueryArgs',
    'DashboardWidgetToplistDefinitionRequestStyleArgs',
    'DashboardWidgetToplistDefinitionTimeArgs',
    'DashboardWidgetTraceServiceDefinitionArgs',
    'DashboardWidgetTraceServiceDefinitionTimeArgs',
    'DowntimeRecurrenceArgs',
    'LogsArchiveAzureArgs',
    'LogsArchiveGcsArgs',
    'LogsArchiveS3Args',
    'LogsCustomPipelineFilterArgs',
    'LogsCustomPipelineProcessorArgs',
    'LogsCustomPipelineProcessorArithmeticProcessorArgs',
    'LogsCustomPipelineProcessorAttributeRemapperArgs',
    'LogsCustomPipelineProcessorCategoryProcessorArgs',
    'LogsCustomPipelineProcessorCategoryProcessorCategoryArgs',
    'LogsCustomPipelineProcessorCategoryProcessorCategoryFilterArgs',
    'LogsCustomPipelineProcessorDateRemapperArgs',
    'LogsCustomPipelineProcessorGeoIpParserArgs',
    'LogsCustomPipelineProcessorGrokParserArgs',
    'LogsCustomPipelineProcessorGrokParserGrokArgs',
    'LogsCustomPipelineProcessorLookupProcessorArgs',
    'LogsCustomPipelineProcessorMessageRemapperArgs',
    'LogsCustomPipelineProcessorPipelineArgs',
    'LogsCustomPipelineProcessorPipelineFilterArgs',
    'LogsCustomPipelineProcessorPipelineProcessorArgs',
    'LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessorArgs',
    'LogsCustomPipelineProcessorPipelineProcessorAttributeRemapperArgs',
    'LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorArgs',
    'LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryArgs',
    'LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilterArgs',
    'LogsCustomPipelineProcessorPipelineProcessorDateRemapperArgs',
    'LogsCustomPipelineProcessorPipelineProcessorGeoIpParserArgs',
    'LogsCustomPipelineProcessorPipelineProcessorGrokParserArgs',
    'LogsCustomPipelineProcessorPipelineProcessorGrokParserGrokArgs',
    'LogsCustomPipelineProcessorPipelineProcessorLookupProcessorArgs',
    'LogsCustomPipelineProcessorPipelineProcessorMessageRemapperArgs',
    'LogsCustomPipelineProcessorPipelineProcessorServiceRemapperArgs',
    'LogsCustomPipelineProcessorPipelineProcessorStatusRemapperArgs',
    'LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessorArgs',
    'LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapperArgs',
    'LogsCustomPipelineProcessorPipelineProcessorUrlParserArgs',
    'LogsCustomPipelineProcessorPipelineProcessorUserAgentParserArgs',
    'LogsCustomPipelineProcessorServiceRemapperArgs',
    'LogsCustomPipelineProcessorStatusRemapperArgs',
    'LogsCustomPipelineProcessorStringBuilderProcessorArgs',
    'LogsCustomPipelineProcessorTraceIdRemapperArgs',
    'LogsCustomPipelineProcessorUrlParserArgs',
    'LogsCustomPipelineProcessorUserAgentParserArgs',
    'LogsIndexExclusionFilterArgs',
    'LogsIndexExclusionFilterFilterArgs',
    'LogsIndexFilterArgs',
    'MonitorThresholdWindowsArgs',
    'MonitorThresholdsArgs',
    'ScreenBoardTemplateVariableArgs',
    'ScreenBoardWidgetArgs',
    'ScreenBoardWidgetRuleArgs',
    'ScreenBoardWidgetTileDefArgs',
    'ScreenBoardWidgetTileDefEventArgs',
    'ScreenBoardWidgetTileDefMarkerArgs',
    'ScreenBoardWidgetTileDefRequestArgs',
    'ScreenBoardWidgetTileDefRequestApmQueryArgs',
    'ScreenBoardWidgetTileDefRequestApmQueryComputeArgs',
    'ScreenBoardWidgetTileDefRequestApmQueryGroupByArgs',
    'ScreenBoardWidgetTileDefRequestApmQueryGroupBySortArgs',
    'ScreenBoardWidgetTileDefRequestApmQuerySearchArgs',
    'ScreenBoardWidgetTileDefRequestConditionalFormatArgs',
    'ScreenBoardWidgetTileDefRequestLogQueryArgs',
    'ScreenBoardWidgetTileDefRequestLogQueryComputeArgs',
    'ScreenBoardWidgetTileDefRequestLogQueryGroupByArgs',
    'ScreenBoardWidgetTileDefRequestLogQueryGroupBySortArgs',
    'ScreenBoardWidgetTileDefRequestLogQuerySearchArgs',
    'ScreenBoardWidgetTileDefRequestProcessQueryArgs',
    'ServiceLevelObjectiveQueryArgs',
    'ServiceLevelObjectiveThresholdArgs',
    'SyntheticsTestOptionsArgs',
    'SyntheticsTestRequestArgs',
    'SyntheticsTestRequestBasicauthArgs',
    'TimeBoardGraphArgs',
    'TimeBoardGraphMarkerArgs',
    'TimeBoardGraphRequestArgs',
    'TimeBoardGraphRequestApmQueryArgs',
    'TimeBoardGraphRequestApmQueryComputeArgs',
    'TimeBoardGraphRequestApmQueryGroupByArgs',
    'TimeBoardGraphRequestApmQueryGroupBySortArgs',
    'TimeBoardGraphRequestApmQuerySearchArgs',
    'TimeBoardGraphRequestConditionalFormatArgs',
    'TimeBoardGraphRequestLogQueryArgs',
    'TimeBoardGraphRequestLogQueryComputeArgs',
    'TimeBoardGraphRequestLogQueryGroupByArgs',
    'TimeBoardGraphRequestLogQueryGroupBySortArgs',
    'TimeBoardGraphRequestLogQuerySearchArgs',
    'TimeBoardGraphRequestProcessQueryArgs',
    'TimeBoardTemplateVariableArgs',
]

@pulumi.input_type
class DashboardListDashItemArgs:
    def __init__(__self__, *,
                 dash_id: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] dash_id: The ID of this dashboard.
        :param pulumi.Input[str] type: The type of this dashboard. Available options are: `custom_timeboard`, `custom_screenboard`, `integration_screenboard`, `integration_timeboard`, and `host_timeboard`
        """
        pulumi.set(__self__, "dash_id", dash_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="dashId")
    def dash_id(self) -> pulumi.Input[str]:
        """
        The ID of this dashboard.
        """
        return pulumi.get(self, "dash_id")

    @dash_id.setter
    def dash_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dash_id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of this dashboard. Available options are: `custom_timeboard`, `custom_screenboard`, `integration_screenboard`, `integration_timeboard`, and `host_timeboard`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class DashboardTemplateVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 default: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The variable name. Can be referenced as $name in `graph` `request` `q` query strings.
        :param pulumi.Input[str] default: The default tag. Default: "\*" (match all).
        :param pulumi.Input[str] prefix: The tag group. Default: no tag group.
        """
        pulumi.set(__self__, "name", name)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The variable name. Can be referenced as $name in `graph` `request` `q` query strings.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[str]]:
        """
        The default tag. Default: "\*" (match all).
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The tag group. Default: no tag group.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


@pulumi.input_type
class DashboardTemplateVariablePresetArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 template_variables: pulumi.Input[List[pulumi.Input['DashboardTemplateVariablePresetTemplateVariableArgs']]]):
        """
        :param pulumi.Input[str] name: The displayed name of the preset.
               - `template_variable`: (Required) Block describing the values that a template_variable within this preset should assume. Each referenced template_variable name must be defined on the dashboard, but not all template_variables must be included in a preset. One or more blocks can be defined per preset.
               - `name`: (Required) The name of the template_variable being referenced.
               - `value`: (Required) The value that the template_variable should assume.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "template_variables", template_variables)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The displayed name of the preset.
        - `template_variable`: (Required) Block describing the values that a template_variable within this preset should assume. Each referenced template_variable name must be defined on the dashboard, but not all template_variables must be included in a preset. One or more blocks can be defined per preset.
        - `name`: (Required) The name of the template_variable being referenced.
        - `value`: (Required) The value that the template_variable should assume.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="templateVariables")
    def template_variables(self) -> pulumi.Input[List[pulumi.Input['DashboardTemplateVariablePresetTemplateVariableArgs']]]:
        return pulumi.get(self, "template_variables")

    @template_variables.setter
    def template_variables(self, value: pulumi.Input[List[pulumi.Input['DashboardTemplateVariablePresetTemplateVariableArgs']]]):
        pulumi.set(self, "template_variables", value)


@pulumi.input_type
class DashboardTemplateVariablePresetTemplateVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The variable name. Can be referenced as $name in `graph` `request` `q` query strings.
        :param pulumi.Input[str] value: Value for the comparator.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The variable name. Can be referenced as $name in `graph` `request` `q` query strings.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class DashboardWidgetArgs:
    def __init__(__self__, *,
                 alert_graph_definition: Optional[pulumi.Input['DashboardWidgetAlertGraphDefinitionArgs']] = None,
                 alert_value_definition: Optional[pulumi.Input['DashboardWidgetAlertValueDefinitionArgs']] = None,
                 change_definition: Optional[pulumi.Input['DashboardWidgetChangeDefinitionArgs']] = None,
                 check_status_definition: Optional[pulumi.Input['DashboardWidgetCheckStatusDefinitionArgs']] = None,
                 distribution_definition: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionArgs']] = None,
                 event_stream_definition: Optional[pulumi.Input['DashboardWidgetEventStreamDefinitionArgs']] = None,
                 event_timeline_definition: Optional[pulumi.Input['DashboardWidgetEventTimelineDefinitionArgs']] = None,
                 free_text_definition: Optional[pulumi.Input['DashboardWidgetFreeTextDefinitionArgs']] = None,
                 group_definition: Optional[pulumi.Input['DashboardWidgetGroupDefinitionArgs']] = None,
                 heatmap_definition: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionArgs']] = None,
                 hostmap_definition: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionArgs']] = None,
                 iframe_definition: Optional[pulumi.Input['DashboardWidgetIframeDefinitionArgs']] = None,
                 image_definition: Optional[pulumi.Input['DashboardWidgetImageDefinitionArgs']] = None,
                 layout: Optional[pulumi.Input['DashboardWidgetLayoutArgs']] = None,
                 log_stream_definition: Optional[pulumi.Input['DashboardWidgetLogStreamDefinitionArgs']] = None,
                 manage_status_definition: Optional[pulumi.Input['DashboardWidgetManageStatusDefinitionArgs']] = None,
                 note_definition: Optional[pulumi.Input['DashboardWidgetNoteDefinitionArgs']] = None,
                 query_table_definition: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionArgs']] = None,
                 query_value_definition: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionArgs']] = None,
                 scatterplot_definition: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionArgs']] = None,
                 service_level_objective_definition: Optional[pulumi.Input['DashboardWidgetServiceLevelObjectiveDefinitionArgs']] = None,
                 servicemap_definition: Optional[pulumi.Input['DashboardWidgetServicemapDefinitionArgs']] = None,
                 timeseries_definition: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionArgs']] = None,
                 toplist_definition: Optional[pulumi.Input['DashboardWidgetToplistDefinitionArgs']] = None,
                 trace_service_definition: Optional[pulumi.Input['DashboardWidgetTraceServiceDefinitionArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetLayoutArgs'] layout: . The structure of this block is described below
               - A widget should have exactly one of the following nested blocks describing the widget definition:
               - `alert_graph_definition`: The definition for a Alert Graph widget. Exactly one nested block is allowed with the following structure:
               - `alert_id`: (Required) The ID of the monitor used by the widget.
               - `viz_type`: (Required) Type of visualization to use when displaying the widget. Either "timeseries" or "toplist".
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right"
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `alert_value_definition`: The definition for an Alert Value widget. Exactly one nested block is allowed with the following structure:
               - `alert_id`: (Required) The ID of the monitor used by the widget.
               - `precision`: (Optional) The precision to use when displaying the value. Use "*" for maximum precision.
               - `unit`: (Optional) The unit for the value displayed in the widget.
               - `text_align`: (Optional) The alignment of the text in the widget.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right"
               - `change_definition`: The definition for a Change widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `change_type`: (Optional) Whether to show absolute or relative change. One of "absolute", "relative".
        """
        if alert_graph_definition is not None:
            pulumi.set(__self__, "alert_graph_definition", alert_graph_definition)
        if alert_value_definition is not None:
            pulumi.set(__self__, "alert_value_definition", alert_value_definition)
        if change_definition is not None:
            pulumi.set(__self__, "change_definition", change_definition)
        if check_status_definition is not None:
            pulumi.set(__self__, "check_status_definition", check_status_definition)
        if distribution_definition is not None:
            pulumi.set(__self__, "distribution_definition", distribution_definition)
        if event_stream_definition is not None:
            pulumi.set(__self__, "event_stream_definition", event_stream_definition)
        if event_timeline_definition is not None:
            pulumi.set(__self__, "event_timeline_definition", event_timeline_definition)
        if free_text_definition is not None:
            pulumi.set(__self__, "free_text_definition", free_text_definition)
        if group_definition is not None:
            pulumi.set(__self__, "group_definition", group_definition)
        if heatmap_definition is not None:
            pulumi.set(__self__, "heatmap_definition", heatmap_definition)
        if hostmap_definition is not None:
            pulumi.set(__self__, "hostmap_definition", hostmap_definition)
        if iframe_definition is not None:
            pulumi.set(__self__, "iframe_definition", iframe_definition)
        if image_definition is not None:
            pulumi.set(__self__, "image_definition", image_definition)
        if layout is not None:
            pulumi.set(__self__, "layout", layout)
        if log_stream_definition is not None:
            pulumi.set(__self__, "log_stream_definition", log_stream_definition)
        if manage_status_definition is not None:
            pulumi.set(__self__, "manage_status_definition", manage_status_definition)
        if note_definition is not None:
            pulumi.set(__self__, "note_definition", note_definition)
        if query_table_definition is not None:
            pulumi.set(__self__, "query_table_definition", query_table_definition)
        if query_value_definition is not None:
            pulumi.set(__self__, "query_value_definition", query_value_definition)
        if scatterplot_definition is not None:
            pulumi.set(__self__, "scatterplot_definition", scatterplot_definition)
        if service_level_objective_definition is not None:
            pulumi.set(__self__, "service_level_objective_definition", service_level_objective_definition)
        if servicemap_definition is not None:
            pulumi.set(__self__, "servicemap_definition", servicemap_definition)
        if timeseries_definition is not None:
            pulumi.set(__self__, "timeseries_definition", timeseries_definition)
        if toplist_definition is not None:
            pulumi.set(__self__, "toplist_definition", toplist_definition)
        if trace_service_definition is not None:
            pulumi.set(__self__, "trace_service_definition", trace_service_definition)

    @property
    @pulumi.getter(name="alertGraphDefinition")
    def alert_graph_definition(self) -> Optional[pulumi.Input['DashboardWidgetAlertGraphDefinitionArgs']]:
        return pulumi.get(self, "alert_graph_definition")

    @alert_graph_definition.setter
    def alert_graph_definition(self, value: Optional[pulumi.Input['DashboardWidgetAlertGraphDefinitionArgs']]):
        pulumi.set(self, "alert_graph_definition", value)

    @property
    @pulumi.getter(name="alertValueDefinition")
    def alert_value_definition(self) -> Optional[pulumi.Input['DashboardWidgetAlertValueDefinitionArgs']]:
        return pulumi.get(self, "alert_value_definition")

    @alert_value_definition.setter
    def alert_value_definition(self, value: Optional[pulumi.Input['DashboardWidgetAlertValueDefinitionArgs']]):
        pulumi.set(self, "alert_value_definition", value)

    @property
    @pulumi.getter(name="changeDefinition")
    def change_definition(self) -> Optional[pulumi.Input['DashboardWidgetChangeDefinitionArgs']]:
        return pulumi.get(self, "change_definition")

    @change_definition.setter
    def change_definition(self, value: Optional[pulumi.Input['DashboardWidgetChangeDefinitionArgs']]):
        pulumi.set(self, "change_definition", value)

    @property
    @pulumi.getter(name="checkStatusDefinition")
    def check_status_definition(self) -> Optional[pulumi.Input['DashboardWidgetCheckStatusDefinitionArgs']]:
        return pulumi.get(self, "check_status_definition")

    @check_status_definition.setter
    def check_status_definition(self, value: Optional[pulumi.Input['DashboardWidgetCheckStatusDefinitionArgs']]):
        pulumi.set(self, "check_status_definition", value)

    @property
    @pulumi.getter(name="distributionDefinition")
    def distribution_definition(self) -> Optional[pulumi.Input['DashboardWidgetDistributionDefinitionArgs']]:
        return pulumi.get(self, "distribution_definition")

    @distribution_definition.setter
    def distribution_definition(self, value: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionArgs']]):
        pulumi.set(self, "distribution_definition", value)

    @property
    @pulumi.getter(name="eventStreamDefinition")
    def event_stream_definition(self) -> Optional[pulumi.Input['DashboardWidgetEventStreamDefinitionArgs']]:
        return pulumi.get(self, "event_stream_definition")

    @event_stream_definition.setter
    def event_stream_definition(self, value: Optional[pulumi.Input['DashboardWidgetEventStreamDefinitionArgs']]):
        pulumi.set(self, "event_stream_definition", value)

    @property
    @pulumi.getter(name="eventTimelineDefinition")
    def event_timeline_definition(self) -> Optional[pulumi.Input['DashboardWidgetEventTimelineDefinitionArgs']]:
        return pulumi.get(self, "event_timeline_definition")

    @event_timeline_definition.setter
    def event_timeline_definition(self, value: Optional[pulumi.Input['DashboardWidgetEventTimelineDefinitionArgs']]):
        pulumi.set(self, "event_timeline_definition", value)

    @property
    @pulumi.getter(name="freeTextDefinition")
    def free_text_definition(self) -> Optional[pulumi.Input['DashboardWidgetFreeTextDefinitionArgs']]:
        return pulumi.get(self, "free_text_definition")

    @free_text_definition.setter
    def free_text_definition(self, value: Optional[pulumi.Input['DashboardWidgetFreeTextDefinitionArgs']]):
        pulumi.set(self, "free_text_definition", value)

    @property
    @pulumi.getter(name="groupDefinition")
    def group_definition(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionArgs']]:
        return pulumi.get(self, "group_definition")

    @group_definition.setter
    def group_definition(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionArgs']]):
        pulumi.set(self, "group_definition", value)

    @property
    @pulumi.getter(name="heatmapDefinition")
    def heatmap_definition(self) -> Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionArgs']]:
        return pulumi.get(self, "heatmap_definition")

    @heatmap_definition.setter
    def heatmap_definition(self, value: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionArgs']]):
        pulumi.set(self, "heatmap_definition", value)

    @property
    @pulumi.getter(name="hostmapDefinition")
    def hostmap_definition(self) -> Optional[pulumi.Input['DashboardWidgetHostmapDefinitionArgs']]:
        return pulumi.get(self, "hostmap_definition")

    @hostmap_definition.setter
    def hostmap_definition(self, value: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionArgs']]):
        pulumi.set(self, "hostmap_definition", value)

    @property
    @pulumi.getter(name="iframeDefinition")
    def iframe_definition(self) -> Optional[pulumi.Input['DashboardWidgetIframeDefinitionArgs']]:
        return pulumi.get(self, "iframe_definition")

    @iframe_definition.setter
    def iframe_definition(self, value: Optional[pulumi.Input['DashboardWidgetIframeDefinitionArgs']]):
        pulumi.set(self, "iframe_definition", value)

    @property
    @pulumi.getter(name="imageDefinition")
    def image_definition(self) -> Optional[pulumi.Input['DashboardWidgetImageDefinitionArgs']]:
        return pulumi.get(self, "image_definition")

    @image_definition.setter
    def image_definition(self, value: Optional[pulumi.Input['DashboardWidgetImageDefinitionArgs']]):
        pulumi.set(self, "image_definition", value)

    @property
    @pulumi.getter
    def layout(self) -> Optional[pulumi.Input['DashboardWidgetLayoutArgs']]:
        """
        . The structure of this block is described below
        - A widget should have exactly one of the following nested blocks describing the widget definition:
        - `alert_graph_definition`: The definition for a Alert Graph widget. Exactly one nested block is allowed with the following structure:
        - `alert_id`: (Required) The ID of the monitor used by the widget.
        - `viz_type`: (Required) Type of visualization to use when displaying the widget. Either "timeseries" or "toplist".
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right"
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `alert_value_definition`: The definition for an Alert Value widget. Exactly one nested block is allowed with the following structure:
        - `alert_id`: (Required) The ID of the monitor used by the widget.
        - `precision`: (Optional) The precision to use when displaying the value. Use "*" for maximum precision.
        - `unit`: (Optional) The unit for the value displayed in the widget.
        - `text_align`: (Optional) The alignment of the text in the widget.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right"
        - `change_definition`: The definition for a Change widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `change_type`: (Optional) Whether to show absolute or relative change. One of "absolute", "relative".
        """
        return pulumi.get(self, "layout")

    @layout.setter
    def layout(self, value: Optional[pulumi.Input['DashboardWidgetLayoutArgs']]):
        pulumi.set(self, "layout", value)

    @property
    @pulumi.getter(name="logStreamDefinition")
    def log_stream_definition(self) -> Optional[pulumi.Input['DashboardWidgetLogStreamDefinitionArgs']]:
        return pulumi.get(self, "log_stream_definition")

    @log_stream_definition.setter
    def log_stream_definition(self, value: Optional[pulumi.Input['DashboardWidgetLogStreamDefinitionArgs']]):
        pulumi.set(self, "log_stream_definition", value)

    @property
    @pulumi.getter(name="manageStatusDefinition")
    def manage_status_definition(self) -> Optional[pulumi.Input['DashboardWidgetManageStatusDefinitionArgs']]:
        return pulumi.get(self, "manage_status_definition")

    @manage_status_definition.setter
    def manage_status_definition(self, value: Optional[pulumi.Input['DashboardWidgetManageStatusDefinitionArgs']]):
        pulumi.set(self, "manage_status_definition", value)

    @property
    @pulumi.getter(name="noteDefinition")
    def note_definition(self) -> Optional[pulumi.Input['DashboardWidgetNoteDefinitionArgs']]:
        return pulumi.get(self, "note_definition")

    @note_definition.setter
    def note_definition(self, value: Optional[pulumi.Input['DashboardWidgetNoteDefinitionArgs']]):
        pulumi.set(self, "note_definition", value)

    @property
    @pulumi.getter(name="queryTableDefinition")
    def query_table_definition(self) -> Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionArgs']]:
        return pulumi.get(self, "query_table_definition")

    @query_table_definition.setter
    def query_table_definition(self, value: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionArgs']]):
        pulumi.set(self, "query_table_definition", value)

    @property
    @pulumi.getter(name="queryValueDefinition")
    def query_value_definition(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionArgs']]:
        return pulumi.get(self, "query_value_definition")

    @query_value_definition.setter
    def query_value_definition(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionArgs']]):
        pulumi.set(self, "query_value_definition", value)

    @property
    @pulumi.getter(name="scatterplotDefinition")
    def scatterplot_definition(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionArgs']]:
        return pulumi.get(self, "scatterplot_definition")

    @scatterplot_definition.setter
    def scatterplot_definition(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionArgs']]):
        pulumi.set(self, "scatterplot_definition", value)

    @property
    @pulumi.getter(name="serviceLevelObjectiveDefinition")
    def service_level_objective_definition(self) -> Optional[pulumi.Input['DashboardWidgetServiceLevelObjectiveDefinitionArgs']]:
        return pulumi.get(self, "service_level_objective_definition")

    @service_level_objective_definition.setter
    def service_level_objective_definition(self, value: Optional[pulumi.Input['DashboardWidgetServiceLevelObjectiveDefinitionArgs']]):
        pulumi.set(self, "service_level_objective_definition", value)

    @property
    @pulumi.getter(name="servicemapDefinition")
    def servicemap_definition(self) -> Optional[pulumi.Input['DashboardWidgetServicemapDefinitionArgs']]:
        return pulumi.get(self, "servicemap_definition")

    @servicemap_definition.setter
    def servicemap_definition(self, value: Optional[pulumi.Input['DashboardWidgetServicemapDefinitionArgs']]):
        pulumi.set(self, "servicemap_definition", value)

    @property
    @pulumi.getter(name="timeseriesDefinition")
    def timeseries_definition(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionArgs']]:
        return pulumi.get(self, "timeseries_definition")

    @timeseries_definition.setter
    def timeseries_definition(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionArgs']]):
        pulumi.set(self, "timeseries_definition", value)

    @property
    @pulumi.getter(name="toplistDefinition")
    def toplist_definition(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionArgs']]:
        return pulumi.get(self, "toplist_definition")

    @toplist_definition.setter
    def toplist_definition(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionArgs']]):
        pulumi.set(self, "toplist_definition", value)

    @property
    @pulumi.getter(name="traceServiceDefinition")
    def trace_service_definition(self) -> Optional[pulumi.Input['DashboardWidgetTraceServiceDefinitionArgs']]:
        return pulumi.get(self, "trace_service_definition")

    @trace_service_definition.setter
    def trace_service_definition(self, value: Optional[pulumi.Input['DashboardWidgetTraceServiceDefinitionArgs']]):
        pulumi.set(self, "trace_service_definition", value)


@pulumi.input_type
class DashboardWidgetAlertGraphDefinitionArgs:
    def __init__(__self__, *,
                 alert_id: pulumi.Input[str],
                 viz_type: pulumi.Input[str],
                 time: Optional[pulumi.Input['DashboardWidgetAlertGraphDefinitionTimeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        pulumi.set(__self__, "alert_id", alert_id)
        pulumi.set(__self__, "viz_type", viz_type)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "alert_id")

    @alert_id.setter
    def alert_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "alert_id", value)

    @property
    @pulumi.getter(name="vizType")
    def viz_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "viz_type")

    @viz_type.setter
    def viz_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "viz_type", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input['DashboardWidgetAlertGraphDefinitionTimeArgs']]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input['DashboardWidgetAlertGraphDefinitionTimeArgs']]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetAlertGraphDefinitionTimeArgs:
    def __init__(__self__, *,
                 live_span: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)


@pulumi.input_type
class DashboardWidgetAlertValueDefinitionArgs:
    def __init__(__self__, *,
                 alert_id: pulumi.Input[str],
                 precision: Optional[pulumi.Input[float]] = None,
                 text_align: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None,
                 unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] precision: The precision to use when displaying the tile.
        :param pulumi.Input[str] text_align: The alignment of the text in the widget.
               - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
               - `q`: (Optional) The metric query to use in the widget
               - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
               - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
               - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        pulumi.set(__self__, "alert_id", alert_id)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "alert_id")

    @alert_id.setter
    def alert_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "alert_id", value)

    @property
    @pulumi.getter
    def precision(self) -> Optional[pulumi.Input[float]]:
        """
        The precision to use when displaying the tile.
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "precision", value)

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the text in the widget.
        - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
        - `q`: (Optional) The metric query to use in the widget
        - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
        - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
        - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "text_align")

    @text_align.setter
    def text_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_align", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)

    @property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unit", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionArgs:
    def __init__(__self__, *,
                 requests: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetChangeDefinitionRequestArgs']]]] = None,
                 time: Optional[pulumi.Input['DashboardWidgetChangeDefinitionTimeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetChangeDefinitionRequestArgs']]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetChangeDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input['DashboardWidgetChangeDefinitionTimeArgs']]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input['DashboardWidgetChangeDefinitionTimeArgs']]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestApmQueryArgs']] = None,
                 change_type: Optional[pulumi.Input[str]] = None,
                 compare_to: Optional[pulumi.Input[str]] = None,
                 increase_good: Optional[pulumi.Input[bool]] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestLogQueryArgs']] = None,
                 order_by: Optional[pulumi.Input[str]] = None,
                 order_dir: Optional[pulumi.Input[str]] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 show_present: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] compare_to: Choose from when to compare current data to. One of "hour_before", "day_before", "week_before" or "month_before".
        :param pulumi.Input[bool] increase_good: Boolean indicating whether an increase in the value is good (thus displayed in green) or not (thus displayed in red).
        :param pulumi.Input[str] order_by: One of "change", "name", "present" (present value) or "past" (past value).
        :param pulumi.Input[str] order_dir: Either "asc" (ascending) or "desc" (descending).
        :param pulumi.Input[bool] show_present: If set to "true", displays current value.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `check_status_definition`: The definition for a Check Status widget. Exactly one nested block is allowed with the following structure:
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if change_type is not None:
            pulumi.set(__self__, "change_type", change_type)
        if compare_to is not None:
            pulumi.set(__self__, "compare_to", compare_to)
        if increase_good is not None:
            pulumi.set(__self__, "increase_good", increase_good)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if order_by is not None:
            pulumi.set(__self__, "order_by", order_by)
        if order_dir is not None:
            pulumi.set(__self__, "order_dir", order_dir)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if show_present is not None:
            pulumi.set(__self__, "show_present", show_present)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestApmQueryArgs']]:
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="changeType")
    def change_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "change_type")

    @change_type.setter
    def change_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "change_type", value)

    @property
    @pulumi.getter(name="compareTo")
    def compare_to(self) -> Optional[pulumi.Input[str]]:
        """
        Choose from when to compare current data to. One of "hour_before", "day_before", "week_before" or "month_before".
        """
        return pulumi.get(self, "compare_to")

    @compare_to.setter
    def compare_to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compare_to", value)

    @property
    @pulumi.getter(name="increaseGood")
    def increase_good(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether an increase in the value is good (thus displayed in green) or not (thus displayed in red).
        """
        return pulumi.get(self, "increase_good")

    @increase_good.setter
    def increase_good(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "increase_good", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestLogQueryArgs']]:
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="orderBy")
    def order_by(self) -> Optional[pulumi.Input[str]]:
        """
        One of "change", "name", "present" (present value) or "past" (past value).
        """
        return pulumi.get(self, "order_by")

    @order_by.setter
    def order_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order_by", value)

    @property
    @pulumi.getter(name="orderDir")
    def order_dir(self) -> Optional[pulumi.Input[str]]:
        """
        Either "asc" (ascending) or "desc" (descending).
        """
        return pulumi.get(self, "order_dir")

    @order_dir.setter
    def order_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order_dir", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestProcessQueryArgs']]:
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter(name="showPresent")
    def show_present(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to "true", displays current value.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `check_status_definition`: The definition for a Check Status widget. Exactly one nested block is allowed with the following structure:
        """
        return pulumi.get(self, "show_present")

    @show_present.setter
    def show_present(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_present", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestApmQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetChangeDefinitionRequestApmQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetChangeDefinitionRequestApmQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestApmQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetChangeDefinitionRequestApmQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetChangeDefinitionRequestApmQueryGroupByArgs']]] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param pulumi.Input['DashboardWidgetChangeDefinitionRequestApmQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetChangeDefinitionRequestApmQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetChangeDefinitionRequestApmQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetChangeDefinitionRequestApmQueryGroupByArgs']]]]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetChangeDefinitionRequestApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestApmQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestApmQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestApmQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestApmQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetChangeDefinitionRequestApmQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestApmQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestApmQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestApmQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestApmQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestLogQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetChangeDefinitionRequestLogQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetChangeDefinitionRequestLogQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestLogQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetChangeDefinitionRequestLogQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetChangeDefinitionRequestLogQueryGroupByArgs']]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input['DashboardWidgetChangeDefinitionRequestLogQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetChangeDefinitionRequestLogQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetChangeDefinitionRequestLogQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetChangeDefinitionRequestLogQueryGroupByArgs']]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetChangeDefinitionRequestLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestLogQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestLogQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestLogQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestLogQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetChangeDefinitionRequestLogQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestLogQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestLogQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestLogQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestLogQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionTimeArgs:
    def __init__(__self__, *,
                 live_span: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)


@pulumi.input_type
class DashboardWidgetCheckStatusDefinitionArgs:
    def __init__(__self__, *,
                 check: pulumi.Input[str],
                 grouping: pulumi.Input[str],
                 group: Optional[pulumi.Input[str]] = None,
                 group_bies: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 tags: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 time: Optional[pulumi.Input['DashboardWidgetCheckStatusDefinitionTimeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] check: The check to use in the widget.
        :param pulumi.Input[str] grouping: Either "check" or "cluster", depending on whether the widget should use a single check or a cluster of checks.
        :param pulumi.Input[str] group: The check group to use in the widget.
        :param pulumi.Input[List[pulumi.Input[str]]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input[List[pulumi.Input[str]]] tags: List of tags to use in the widget.
               - `title`: (Optional) The title of the widget.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `distribution_definition`: The definition for a Distribution widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        pulumi.set(__self__, "check", check)
        pulumi.set(__self__, "grouping", grouping)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def check(self) -> pulumi.Input[str]:
        """
        The check to use in the widget.
        """
        return pulumi.get(self, "check")

    @check.setter
    def check(self, value: pulumi.Input[str]):
        pulumi.set(self, "check", value)

    @property
    @pulumi.getter
    def grouping(self) -> pulumi.Input[str]:
        """
        Either "check" or "cluster", depending on whether the widget should use a single check or a cluster of checks.
        """
        return pulumi.get(self, "grouping")

    @grouping.setter
    def grouping(self, value: pulumi.Input[str]):
        pulumi.set(self, "grouping", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        The check group to use in the widget.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        List of tags to use in the widget.
        - `title`: (Optional) The title of the widget.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `distribution_definition`: The definition for a Distribution widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input['DashboardWidgetCheckStatusDefinitionTimeArgs']]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input['DashboardWidgetCheckStatusDefinitionTimeArgs']]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetCheckStatusDefinitionTimeArgs:
    def __init__(__self__, *,
                 live_span: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)


@pulumi.input_type
class DashboardWidgetDistributionDefinitionArgs:
    def __init__(__self__, *,
                 legend_size: Optional[pulumi.Input[str]] = None,
                 requests: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetDistributionDefinitionRequestArgs']]]] = None,
                 show_legend: Optional[pulumi.Input[bool]] = None,
                 time: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionTimeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "legend_size")

    @legend_size.setter
    def legend_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "legend_size", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetDistributionDefinitionRequestArgs']]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetDistributionDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "show_legend")

    @show_legend.setter
    def show_legend(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_legend", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input['DashboardWidgetDistributionDefinitionTimeArgs']]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionTimeArgs']]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetDistributionDefinitionRequestArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestApmQueryArgs']] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 style: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestStyleArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetDistributionDefinitionRequestStyleArgs'] style: Style of the widget graph. One nested block is allowed with the following structure:
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestApmQueryArgs']]:
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestLogQueryArgs']]:
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestProcessQueryArgs']]:
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestStyleArgs']]:
        """
        Style of the widget graph. One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class DashboardWidgetDistributionDefinitionRequestApmQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetDistributionDefinitionRequestApmQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetDistributionDefinitionRequestApmQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestApmQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetDistributionDefinitionRequestApmQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetDistributionDefinitionRequestApmQueryGroupByArgs']]] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param pulumi.Input['DashboardWidgetDistributionDefinitionRequestApmQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetDistributionDefinitionRequestApmQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetDistributionDefinitionRequestApmQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetDistributionDefinitionRequestApmQueryGroupByArgs']]]]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetDistributionDefinitionRequestApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestApmQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestApmQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetDistributionDefinitionRequestApmQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetDistributionDefinitionRequestApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetDistributionDefinitionRequestApmQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetDistributionDefinitionRequestLogQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetDistributionDefinitionRequestLogQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetDistributionDefinitionRequestLogQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestLogQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetDistributionDefinitionRequestLogQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetDistributionDefinitionRequestLogQueryGroupByArgs']]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input['DashboardWidgetDistributionDefinitionRequestLogQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetDistributionDefinitionRequestLogQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetDistributionDefinitionRequestLogQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetDistributionDefinitionRequestLogQueryGroupByArgs']]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetDistributionDefinitionRequestLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestLogQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestLogQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetDistributionDefinitionRequestLogQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetDistributionDefinitionRequestLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetDistributionDefinitionRequestLogQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetDistributionDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetDistributionDefinitionRequestStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
               - `q`: (Required) The event query to use in the widget.
               - `tags_execution`: (Optional) The execution method for multi-value filters.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
        - `q`: (Required) The event query to use in the widget.
        - `tags_execution`: (Optional) The execution method for multi-value filters.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)


@pulumi.input_type
class DashboardWidgetDistributionDefinitionTimeArgs:
    def __init__(__self__, *,
                 live_span: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)


@pulumi.input_type
class DashboardWidgetEventStreamDefinitionArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str],
                 event_size: Optional[pulumi.Input[str]] = None,
                 tags_execution: Optional[pulumi.Input[str]] = None,
                 time: Optional[pulumi.Input['DashboardWidgetEventStreamDefinitionTimeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] event_size: The size of the events in the widget. Either "s" (small, title only) or "l" (large, full event).
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `tags_execution`: (Optional) The execution method for multi-value filters. Can be either "and" or "or".
               - `event_timeline_definition`: The definition for a Event Timeline widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `tags_execution`: (Optional) The execution method for multi-value filters. Can be either "and" or "or".
               - `free_text_definition`: The definition for a Free Text. Exactly one nested block is allowed with the following structure:
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        pulumi.set(__self__, "query", query)
        if event_size is not None:
            pulumi.set(__self__, "event_size", event_size)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="eventSize")
    def event_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the events in the widget. Either "s" (small, title only) or "l" (large, full event).
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `tags_execution`: (Optional) The execution method for multi-value filters. Can be either "and" or "or".
        - `event_timeline_definition`: The definition for a Event Timeline widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `tags_execution`: (Optional) The execution method for multi-value filters. Can be either "and" or "or".
        - `free_text_definition`: The definition for a Free Text. Exactly one nested block is allowed with the following structure:
        """
        return pulumi.get(self, "event_size")

    @event_size.setter
    def event_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_size", value)

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tags_execution")

    @tags_execution.setter
    def tags_execution(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tags_execution", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input['DashboardWidgetEventStreamDefinitionTimeArgs']]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input['DashboardWidgetEventStreamDefinitionTimeArgs']]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetEventStreamDefinitionTimeArgs:
    def __init__(__self__, *,
                 live_span: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)


@pulumi.input_type
class DashboardWidgetEventTimelineDefinitionArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str],
                 tags_execution: Optional[pulumi.Input[str]] = None,
                 time: Optional[pulumi.Input['DashboardWidgetEventTimelineDefinitionTimeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        pulumi.set(__self__, "query", query)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tags_execution")

    @tags_execution.setter
    def tags_execution(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tags_execution", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input['DashboardWidgetEventTimelineDefinitionTimeArgs']]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input['DashboardWidgetEventTimelineDefinitionTimeArgs']]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetEventTimelineDefinitionTimeArgs:
    def __init__(__self__, *,
                 live_span: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)


@pulumi.input_type
class DashboardWidgetFreeTextDefinitionArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[str],
                 color: Optional[pulumi.Input[str]] = None,
                 font_size: Optional[pulumi.Input[str]] = None,
                 text_align: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] text: The text to display in the widget.
        :param pulumi.Input[str] color: The color of the text in the widget.
        :param pulumi.Input[str] font_size: The size of the text in the widget.
        :param pulumi.Input[str] text_align: The alignment of the text in the widget.
               - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
               - `q`: (Optional) The metric query to use in the widget
               - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
               - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
               - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        pulumi.set(__self__, "text", text)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if font_size is not None:
            pulumi.set(__self__, "font_size", font_size)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)

    @property
    @pulumi.getter
    def text(self) -> pulumi.Input[str]:
        """
        The text to display in the widget.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[str]):
        pulumi.set(self, "text", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        The color of the text in the widget.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the text in the widget.
        """
        return pulumi.get(self, "font_size")

    @font_size.setter
    def font_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "font_size", value)

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the text in the widget.
        - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
        - `q`: (Optional) The metric query to use in the widget
        - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
        - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
        - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "text_align")

    @text_align.setter
    def text_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_align", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionArgs:
    def __init__(__self__, *,
                 layout_type: pulumi.Input[str],
                 widgets: pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetArgs']]],
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] layout_type: Layout type of the dashboard. Available values are: `ordered` (previous timeboard) or `free` (previous screenboard layout).
               <br>**Note: This value cannot be changed. Converting a dashboard from `free` <> `ordered` requires destroying and re-creating the dashboard.** Instead of using `ForceNew`, this is a manual action as many underlying widget configs need to be updated to work for the updated layout, otherwise the new dashboard won't be created properly.
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetArgs']]] widgets: Nested block describing a widget. The structure of this block is described below. Multiple `widget` blocks are allowed within a `Dashboard` resource.
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        pulumi.set(__self__, "layout_type", layout_type)
        pulumi.set(__self__, "widgets", widgets)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="layoutType")
    def layout_type(self) -> pulumi.Input[str]:
        """
        Layout type of the dashboard. Available values are: `ordered` (previous timeboard) or `free` (previous screenboard layout).
        <br>**Note: This value cannot be changed. Converting a dashboard from `free` <> `ordered` requires destroying and re-creating the dashboard.** Instead of using `ForceNew`, this is a manual action as many underlying widget configs need to be updated to work for the updated layout, otherwise the new dashboard won't be created properly.
        """
        return pulumi.get(self, "layout_type")

    @layout_type.setter
    def layout_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "layout_type", value)

    @property
    @pulumi.getter
    def widgets(self) -> pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetArgs']]]:
        """
        Nested block describing a widget. The structure of this block is described below. Multiple `widget` blocks are allowed within a `Dashboard` resource.
        """
        return pulumi.get(self, "widgets")

    @widgets.setter
    def widgets(self, value: pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetArgs']]]):
        pulumi.set(self, "widgets", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetArgs:
    def __init__(__self__, *,
                 alert_graph_definition: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetAlertGraphDefinitionArgs']] = None,
                 alert_value_definition: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetAlertValueDefinitionArgs']] = None,
                 change_definition: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionArgs']] = None,
                 check_status_definition: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetCheckStatusDefinitionArgs']] = None,
                 distribution_definition: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionArgs']] = None,
                 event_stream_definition: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetEventStreamDefinitionArgs']] = None,
                 event_timeline_definition: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetEventTimelineDefinitionArgs']] = None,
                 free_text_definition: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetFreeTextDefinitionArgs']] = None,
                 heatmap_definition: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionArgs']] = None,
                 hostmap_definition: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionArgs']] = None,
                 iframe_definition: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetIframeDefinitionArgs']] = None,
                 image_definition: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetImageDefinitionArgs']] = None,
                 layout: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetLayoutArgs']] = None,
                 log_stream_definition: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionArgs']] = None,
                 manage_status_definition: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetManageStatusDefinitionArgs']] = None,
                 note_definition: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetNoteDefinitionArgs']] = None,
                 query_table_definition: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionArgs']] = None,
                 query_value_definition: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionArgs']] = None,
                 scatterplot_definition: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionArgs']] = None,
                 service_level_objective_definition: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinitionArgs']] = None,
                 servicemap_definition: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetServicemapDefinitionArgs']] = None,
                 timeseries_definition: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionArgs']] = None,
                 toplist_definition: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionArgs']] = None,
                 trace_service_definition: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTraceServiceDefinitionArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetLayoutArgs'] layout: . The structure of this block is described below
               - A widget should have exactly one of the following nested blocks describing the widget definition:
               - `alert_graph_definition`: The definition for a Alert Graph widget. Exactly one nested block is allowed with the following structure:
               - `alert_id`: (Required) The ID of the monitor used by the widget.
               - `viz_type`: (Required) Type of visualization to use when displaying the widget. Either "timeseries" or "toplist".
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right"
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `alert_value_definition`: The definition for an Alert Value widget. Exactly one nested block is allowed with the following structure:
               - `alert_id`: (Required) The ID of the monitor used by the widget.
               - `precision`: (Optional) The precision to use when displaying the value. Use "*" for maximum precision.
               - `unit`: (Optional) The unit for the value displayed in the widget.
               - `text_align`: (Optional) The alignment of the text in the widget.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right"
               - `change_definition`: The definition for a Change widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `change_type`: (Optional) Whether to show absolute or relative change. One of "absolute", "relative".
        """
        if alert_graph_definition is not None:
            pulumi.set(__self__, "alert_graph_definition", alert_graph_definition)
        if alert_value_definition is not None:
            pulumi.set(__self__, "alert_value_definition", alert_value_definition)
        if change_definition is not None:
            pulumi.set(__self__, "change_definition", change_definition)
        if check_status_definition is not None:
            pulumi.set(__self__, "check_status_definition", check_status_definition)
        if distribution_definition is not None:
            pulumi.set(__self__, "distribution_definition", distribution_definition)
        if event_stream_definition is not None:
            pulumi.set(__self__, "event_stream_definition", event_stream_definition)
        if event_timeline_definition is not None:
            pulumi.set(__self__, "event_timeline_definition", event_timeline_definition)
        if free_text_definition is not None:
            pulumi.set(__self__, "free_text_definition", free_text_definition)
        if heatmap_definition is not None:
            pulumi.set(__self__, "heatmap_definition", heatmap_definition)
        if hostmap_definition is not None:
            pulumi.set(__self__, "hostmap_definition", hostmap_definition)
        if iframe_definition is not None:
            pulumi.set(__self__, "iframe_definition", iframe_definition)
        if image_definition is not None:
            pulumi.set(__self__, "image_definition", image_definition)
        if layout is not None:
            pulumi.set(__self__, "layout", layout)
        if log_stream_definition is not None:
            pulumi.set(__self__, "log_stream_definition", log_stream_definition)
        if manage_status_definition is not None:
            pulumi.set(__self__, "manage_status_definition", manage_status_definition)
        if note_definition is not None:
            pulumi.set(__self__, "note_definition", note_definition)
        if query_table_definition is not None:
            pulumi.set(__self__, "query_table_definition", query_table_definition)
        if query_value_definition is not None:
            pulumi.set(__self__, "query_value_definition", query_value_definition)
        if scatterplot_definition is not None:
            pulumi.set(__self__, "scatterplot_definition", scatterplot_definition)
        if service_level_objective_definition is not None:
            pulumi.set(__self__, "service_level_objective_definition", service_level_objective_definition)
        if servicemap_definition is not None:
            pulumi.set(__self__, "servicemap_definition", servicemap_definition)
        if timeseries_definition is not None:
            pulumi.set(__self__, "timeseries_definition", timeseries_definition)
        if toplist_definition is not None:
            pulumi.set(__self__, "toplist_definition", toplist_definition)
        if trace_service_definition is not None:
            pulumi.set(__self__, "trace_service_definition", trace_service_definition)

    @property
    @pulumi.getter(name="alertGraphDefinition")
    def alert_graph_definition(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetAlertGraphDefinitionArgs']]:
        return pulumi.get(self, "alert_graph_definition")

    @alert_graph_definition.setter
    def alert_graph_definition(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetAlertGraphDefinitionArgs']]):
        pulumi.set(self, "alert_graph_definition", value)

    @property
    @pulumi.getter(name="alertValueDefinition")
    def alert_value_definition(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetAlertValueDefinitionArgs']]:
        return pulumi.get(self, "alert_value_definition")

    @alert_value_definition.setter
    def alert_value_definition(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetAlertValueDefinitionArgs']]):
        pulumi.set(self, "alert_value_definition", value)

    @property
    @pulumi.getter(name="changeDefinition")
    def change_definition(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionArgs']]:
        return pulumi.get(self, "change_definition")

    @change_definition.setter
    def change_definition(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionArgs']]):
        pulumi.set(self, "change_definition", value)

    @property
    @pulumi.getter(name="checkStatusDefinition")
    def check_status_definition(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetCheckStatusDefinitionArgs']]:
        return pulumi.get(self, "check_status_definition")

    @check_status_definition.setter
    def check_status_definition(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetCheckStatusDefinitionArgs']]):
        pulumi.set(self, "check_status_definition", value)

    @property
    @pulumi.getter(name="distributionDefinition")
    def distribution_definition(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionArgs']]:
        return pulumi.get(self, "distribution_definition")

    @distribution_definition.setter
    def distribution_definition(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionArgs']]):
        pulumi.set(self, "distribution_definition", value)

    @property
    @pulumi.getter(name="eventStreamDefinition")
    def event_stream_definition(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetEventStreamDefinitionArgs']]:
        return pulumi.get(self, "event_stream_definition")

    @event_stream_definition.setter
    def event_stream_definition(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetEventStreamDefinitionArgs']]):
        pulumi.set(self, "event_stream_definition", value)

    @property
    @pulumi.getter(name="eventTimelineDefinition")
    def event_timeline_definition(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetEventTimelineDefinitionArgs']]:
        return pulumi.get(self, "event_timeline_definition")

    @event_timeline_definition.setter
    def event_timeline_definition(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetEventTimelineDefinitionArgs']]):
        pulumi.set(self, "event_timeline_definition", value)

    @property
    @pulumi.getter(name="freeTextDefinition")
    def free_text_definition(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetFreeTextDefinitionArgs']]:
        return pulumi.get(self, "free_text_definition")

    @free_text_definition.setter
    def free_text_definition(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetFreeTextDefinitionArgs']]):
        pulumi.set(self, "free_text_definition", value)

    @property
    @pulumi.getter(name="heatmapDefinition")
    def heatmap_definition(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionArgs']]:
        return pulumi.get(self, "heatmap_definition")

    @heatmap_definition.setter
    def heatmap_definition(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionArgs']]):
        pulumi.set(self, "heatmap_definition", value)

    @property
    @pulumi.getter(name="hostmapDefinition")
    def hostmap_definition(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionArgs']]:
        return pulumi.get(self, "hostmap_definition")

    @hostmap_definition.setter
    def hostmap_definition(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionArgs']]):
        pulumi.set(self, "hostmap_definition", value)

    @property
    @pulumi.getter(name="iframeDefinition")
    def iframe_definition(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetIframeDefinitionArgs']]:
        return pulumi.get(self, "iframe_definition")

    @iframe_definition.setter
    def iframe_definition(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetIframeDefinitionArgs']]):
        pulumi.set(self, "iframe_definition", value)

    @property
    @pulumi.getter(name="imageDefinition")
    def image_definition(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetImageDefinitionArgs']]:
        return pulumi.get(self, "image_definition")

    @image_definition.setter
    def image_definition(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetImageDefinitionArgs']]):
        pulumi.set(self, "image_definition", value)

    @property
    @pulumi.getter
    def layout(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetLayoutArgs']]:
        """
        . The structure of this block is described below
        - A widget should have exactly one of the following nested blocks describing the widget definition:
        - `alert_graph_definition`: The definition for a Alert Graph widget. Exactly one nested block is allowed with the following structure:
        - `alert_id`: (Required) The ID of the monitor used by the widget.
        - `viz_type`: (Required) Type of visualization to use when displaying the widget. Either "timeseries" or "toplist".
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right"
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `alert_value_definition`: The definition for an Alert Value widget. Exactly one nested block is allowed with the following structure:
        - `alert_id`: (Required) The ID of the monitor used by the widget.
        - `precision`: (Optional) The precision to use when displaying the value. Use "*" for maximum precision.
        - `unit`: (Optional) The unit for the value displayed in the widget.
        - `text_align`: (Optional) The alignment of the text in the widget.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right"
        - `change_definition`: The definition for a Change widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `change_type`: (Optional) Whether to show absolute or relative change. One of "absolute", "relative".
        """
        return pulumi.get(self, "layout")

    @layout.setter
    def layout(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetLayoutArgs']]):
        pulumi.set(self, "layout", value)

    @property
    @pulumi.getter(name="logStreamDefinition")
    def log_stream_definition(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionArgs']]:
        return pulumi.get(self, "log_stream_definition")

    @log_stream_definition.setter
    def log_stream_definition(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionArgs']]):
        pulumi.set(self, "log_stream_definition", value)

    @property
    @pulumi.getter(name="manageStatusDefinition")
    def manage_status_definition(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetManageStatusDefinitionArgs']]:
        return pulumi.get(self, "manage_status_definition")

    @manage_status_definition.setter
    def manage_status_definition(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetManageStatusDefinitionArgs']]):
        pulumi.set(self, "manage_status_definition", value)

    @property
    @pulumi.getter(name="noteDefinition")
    def note_definition(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetNoteDefinitionArgs']]:
        return pulumi.get(self, "note_definition")

    @note_definition.setter
    def note_definition(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetNoteDefinitionArgs']]):
        pulumi.set(self, "note_definition", value)

    @property
    @pulumi.getter(name="queryTableDefinition")
    def query_table_definition(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionArgs']]:
        return pulumi.get(self, "query_table_definition")

    @query_table_definition.setter
    def query_table_definition(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionArgs']]):
        pulumi.set(self, "query_table_definition", value)

    @property
    @pulumi.getter(name="queryValueDefinition")
    def query_value_definition(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionArgs']]:
        return pulumi.get(self, "query_value_definition")

    @query_value_definition.setter
    def query_value_definition(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionArgs']]):
        pulumi.set(self, "query_value_definition", value)

    @property
    @pulumi.getter(name="scatterplotDefinition")
    def scatterplot_definition(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionArgs']]:
        return pulumi.get(self, "scatterplot_definition")

    @scatterplot_definition.setter
    def scatterplot_definition(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionArgs']]):
        pulumi.set(self, "scatterplot_definition", value)

    @property
    @pulumi.getter(name="serviceLevelObjectiveDefinition")
    def service_level_objective_definition(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinitionArgs']]:
        return pulumi.get(self, "service_level_objective_definition")

    @service_level_objective_definition.setter
    def service_level_objective_definition(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinitionArgs']]):
        pulumi.set(self, "service_level_objective_definition", value)

    @property
    @pulumi.getter(name="servicemapDefinition")
    def servicemap_definition(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetServicemapDefinitionArgs']]:
        return pulumi.get(self, "servicemap_definition")

    @servicemap_definition.setter
    def servicemap_definition(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetServicemapDefinitionArgs']]):
        pulumi.set(self, "servicemap_definition", value)

    @property
    @pulumi.getter(name="timeseriesDefinition")
    def timeseries_definition(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionArgs']]:
        return pulumi.get(self, "timeseries_definition")

    @timeseries_definition.setter
    def timeseries_definition(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionArgs']]):
        pulumi.set(self, "timeseries_definition", value)

    @property
    @pulumi.getter(name="toplistDefinition")
    def toplist_definition(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionArgs']]:
        return pulumi.get(self, "toplist_definition")

    @toplist_definition.setter
    def toplist_definition(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionArgs']]):
        pulumi.set(self, "toplist_definition", value)

    @property
    @pulumi.getter(name="traceServiceDefinition")
    def trace_service_definition(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTraceServiceDefinitionArgs']]:
        return pulumi.get(self, "trace_service_definition")

    @trace_service_definition.setter
    def trace_service_definition(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTraceServiceDefinitionArgs']]):
        pulumi.set(self, "trace_service_definition", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetAlertGraphDefinitionArgs:
    def __init__(__self__, *,
                 alert_id: pulumi.Input[str],
                 viz_type: pulumi.Input[str],
                 time: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetAlertGraphDefinitionTimeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        pulumi.set(__self__, "alert_id", alert_id)
        pulumi.set(__self__, "viz_type", viz_type)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "alert_id")

    @alert_id.setter
    def alert_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "alert_id", value)

    @property
    @pulumi.getter(name="vizType")
    def viz_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "viz_type")

    @viz_type.setter
    def viz_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "viz_type", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetAlertGraphDefinitionTimeArgs']]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetAlertGraphDefinitionTimeArgs']]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetAlertGraphDefinitionTimeArgs:
    def __init__(__self__, *,
                 live_span: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetAlertValueDefinitionArgs:
    def __init__(__self__, *,
                 alert_id: pulumi.Input[str],
                 precision: Optional[pulumi.Input[float]] = None,
                 text_align: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None,
                 unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] precision: The precision to use when displaying the tile.
        :param pulumi.Input[str] text_align: The alignment of the text in the widget.
               - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
               - `q`: (Optional) The metric query to use in the widget
               - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
               - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
               - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        pulumi.set(__self__, "alert_id", alert_id)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "alert_id")

    @alert_id.setter
    def alert_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "alert_id", value)

    @property
    @pulumi.getter
    def precision(self) -> Optional[pulumi.Input[float]]:
        """
        The precision to use when displaying the tile.
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "precision", value)

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the text in the widget.
        - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
        - `q`: (Optional) The metric query to use in the widget
        - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
        - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
        - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "text_align")

    @text_align.setter
    def text_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_align", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)

    @property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unit", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionArgs:
    def __init__(__self__, *,
                 requests: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestArgs']]]] = None,
                 time: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionTimeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestArgs']]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionTimeArgs']]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionTimeArgs']]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryArgs']] = None,
                 change_type: Optional[pulumi.Input[str]] = None,
                 compare_to: Optional[pulumi.Input[str]] = None,
                 increase_good: Optional[pulumi.Input[bool]] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryArgs']] = None,
                 order_by: Optional[pulumi.Input[str]] = None,
                 order_dir: Optional[pulumi.Input[str]] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 show_present: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] compare_to: Choose from when to compare current data to. One of "hour_before", "day_before", "week_before" or "month_before".
        :param pulumi.Input[bool] increase_good: Boolean indicating whether an increase in the value is good (thus displayed in green) or not (thus displayed in red).
        :param pulumi.Input[str] order_by: One of "change", "name", "present" (present value) or "past" (past value).
        :param pulumi.Input[str] order_dir: Either "asc" (ascending) or "desc" (descending).
        :param pulumi.Input[bool] show_present: If set to "true", displays current value.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `check_status_definition`: The definition for a Check Status widget. Exactly one nested block is allowed with the following structure:
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if change_type is not None:
            pulumi.set(__self__, "change_type", change_type)
        if compare_to is not None:
            pulumi.set(__self__, "compare_to", compare_to)
        if increase_good is not None:
            pulumi.set(__self__, "increase_good", increase_good)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if order_by is not None:
            pulumi.set(__self__, "order_by", order_by)
        if order_dir is not None:
            pulumi.set(__self__, "order_dir", order_dir)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if show_present is not None:
            pulumi.set(__self__, "show_present", show_present)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryArgs']]:
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="changeType")
    def change_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "change_type")

    @change_type.setter
    def change_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "change_type", value)

    @property
    @pulumi.getter(name="compareTo")
    def compare_to(self) -> Optional[pulumi.Input[str]]:
        """
        Choose from when to compare current data to. One of "hour_before", "day_before", "week_before" or "month_before".
        """
        return pulumi.get(self, "compare_to")

    @compare_to.setter
    def compare_to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compare_to", value)

    @property
    @pulumi.getter(name="increaseGood")
    def increase_good(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether an increase in the value is good (thus displayed in green) or not (thus displayed in red).
        """
        return pulumi.get(self, "increase_good")

    @increase_good.setter
    def increase_good(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "increase_good", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryArgs']]:
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="orderBy")
    def order_by(self) -> Optional[pulumi.Input[str]]:
        """
        One of "change", "name", "present" (present value) or "past" (past value).
        """
        return pulumi.get(self, "order_by")

    @order_by.setter
    def order_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order_by", value)

    @property
    @pulumi.getter(name="orderDir")
    def order_dir(self) -> Optional[pulumi.Input[str]]:
        """
        Either "asc" (ascending) or "desc" (descending).
        """
        return pulumi.get(self, "order_dir")

    @order_dir.setter
    def order_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order_dir", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQueryArgs']]:
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter(name="showPresent")
    def show_present(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to "true", displays current value.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `check_status_definition`: The definition for a Check Status widget. Exactly one nested block is allowed with the following structure:
        """
        return pulumi.get(self, "show_present")

    @show_present.setter
    def show_present(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_present", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupByArgs']]] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupByArgs']]]]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupByArgs']]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupByArgs']]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionTimeArgs:
    def __init__(__self__, *,
                 live_span: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetCheckStatusDefinitionArgs:
    def __init__(__self__, *,
                 check: pulumi.Input[str],
                 grouping: pulumi.Input[str],
                 group: Optional[pulumi.Input[str]] = None,
                 group_bies: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 tags: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 time: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetCheckStatusDefinitionTimeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] check: The check to use in the widget.
        :param pulumi.Input[str] grouping: Either "check" or "cluster", depending on whether the widget should use a single check or a cluster of checks.
        :param pulumi.Input[str] group: The check group to use in the widget.
        :param pulumi.Input[List[pulumi.Input[str]]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input[List[pulumi.Input[str]]] tags: List of tags to use in the widget.
               - `title`: (Optional) The title of the widget.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `distribution_definition`: The definition for a Distribution widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        pulumi.set(__self__, "check", check)
        pulumi.set(__self__, "grouping", grouping)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def check(self) -> pulumi.Input[str]:
        """
        The check to use in the widget.
        """
        return pulumi.get(self, "check")

    @check.setter
    def check(self, value: pulumi.Input[str]):
        pulumi.set(self, "check", value)

    @property
    @pulumi.getter
    def grouping(self) -> pulumi.Input[str]:
        """
        Either "check" or "cluster", depending on whether the widget should use a single check or a cluster of checks.
        """
        return pulumi.get(self, "grouping")

    @grouping.setter
    def grouping(self, value: pulumi.Input[str]):
        pulumi.set(self, "grouping", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        The check group to use in the widget.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        List of tags to use in the widget.
        - `title`: (Optional) The title of the widget.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `distribution_definition`: The definition for a Distribution widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetCheckStatusDefinitionTimeArgs']]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetCheckStatusDefinitionTimeArgs']]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetCheckStatusDefinitionTimeArgs:
    def __init__(__self__, *,
                 live_span: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionArgs:
    def __init__(__self__, *,
                 legend_size: Optional[pulumi.Input[str]] = None,
                 requests: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestArgs']]]] = None,
                 show_legend: Optional[pulumi.Input[bool]] = None,
                 time: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionTimeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "legend_size")

    @legend_size.setter
    def legend_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "legend_size", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestArgs']]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "show_legend")

    @show_legend.setter
    def show_legend(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_legend", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionTimeArgs']]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionTimeArgs']]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryArgs']] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 style: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyleArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyleArgs'] style: Style of the widget graph. One nested block is allowed with the following structure:
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryArgs']]:
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryArgs']]:
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQueryArgs']]:
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyleArgs']]:
        """
        Style of the widget graph. One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupByArgs']]] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupByArgs']]]]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupByArgs']]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupByArgs']]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
               - `q`: (Required) The event query to use in the widget.
               - `tags_execution`: (Optional) The execution method for multi-value filters.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
        - `q`: (Required) The event query to use in the widget.
        - `tags_execution`: (Optional) The execution method for multi-value filters.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionTimeArgs:
    def __init__(__self__, *,
                 live_span: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetEventStreamDefinitionArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str],
                 event_size: Optional[pulumi.Input[str]] = None,
                 tags_execution: Optional[pulumi.Input[str]] = None,
                 time: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetEventStreamDefinitionTimeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] event_size: The size of the events in the widget. Either "s" (small, title only) or "l" (large, full event).
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `tags_execution`: (Optional) The execution method for multi-value filters. Can be either "and" or "or".
               - `event_timeline_definition`: The definition for a Event Timeline widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `tags_execution`: (Optional) The execution method for multi-value filters. Can be either "and" or "or".
               - `free_text_definition`: The definition for a Free Text. Exactly one nested block is allowed with the following structure:
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        pulumi.set(__self__, "query", query)
        if event_size is not None:
            pulumi.set(__self__, "event_size", event_size)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="eventSize")
    def event_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the events in the widget. Either "s" (small, title only) or "l" (large, full event).
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `tags_execution`: (Optional) The execution method for multi-value filters. Can be either "and" or "or".
        - `event_timeline_definition`: The definition for a Event Timeline widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `tags_execution`: (Optional) The execution method for multi-value filters. Can be either "and" or "or".
        - `free_text_definition`: The definition for a Free Text. Exactly one nested block is allowed with the following structure:
        """
        return pulumi.get(self, "event_size")

    @event_size.setter
    def event_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_size", value)

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tags_execution")

    @tags_execution.setter
    def tags_execution(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tags_execution", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetEventStreamDefinitionTimeArgs']]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetEventStreamDefinitionTimeArgs']]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetEventStreamDefinitionTimeArgs:
    def __init__(__self__, *,
                 live_span: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetEventTimelineDefinitionArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str],
                 tags_execution: Optional[pulumi.Input[str]] = None,
                 time: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetEventTimelineDefinitionTimeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        pulumi.set(__self__, "query", query)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tags_execution")

    @tags_execution.setter
    def tags_execution(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tags_execution", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetEventTimelineDefinitionTimeArgs']]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetEventTimelineDefinitionTimeArgs']]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetEventTimelineDefinitionTimeArgs:
    def __init__(__self__, *,
                 live_span: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetFreeTextDefinitionArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[str],
                 color: Optional[pulumi.Input[str]] = None,
                 font_size: Optional[pulumi.Input[str]] = None,
                 text_align: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] text: The text to display in the widget.
        :param pulumi.Input[str] color: The color of the text in the widget.
        :param pulumi.Input[str] font_size: The size of the text in the widget.
        :param pulumi.Input[str] text_align: The alignment of the text in the widget.
               - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
               - `q`: (Optional) The metric query to use in the widget
               - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
               - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
               - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        pulumi.set(__self__, "text", text)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if font_size is not None:
            pulumi.set(__self__, "font_size", font_size)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)

    @property
    @pulumi.getter
    def text(self) -> pulumi.Input[str]:
        """
        The text to display in the widget.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[str]):
        pulumi.set(self, "text", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        The color of the text in the widget.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the text in the widget.
        """
        return pulumi.get(self, "font_size")

    @font_size.setter
    def font_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "font_size", value)

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the text in the widget.
        - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
        - `q`: (Optional) The metric query to use in the widget
        - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
        - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
        - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "text_align")

    @text_align.setter
    def text_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_align", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionArgs:
    def __init__(__self__, *,
                 events: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEventArgs']]]] = None,
                 legend_size: Optional[pulumi.Input[str]] = None,
                 requests: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestArgs']]]] = None,
                 show_legend: Optional[pulumi.Input[bool]] = None,
                 time: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionTimeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None,
                 yaxis: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxisArgs']] = None):
        """
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        if events is not None:
            pulumi.set(__self__, "events", events)
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter
    def events(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEventArgs']]]]:
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEventArgs']]]]):
        pulumi.set(self, "events", value)

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "legend_size")

    @legend_size.setter
    def legend_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "legend_size", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestArgs']]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "show_legend")

    @show_legend.setter
    def show_legend(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_legend", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionTimeArgs']]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionTimeArgs']]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)

    @property
    @pulumi.getter
    def yaxis(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxisArgs']]:
        return pulumi.get(self, "yaxis")

    @yaxis.setter
    def yaxis(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxisArgs']]):
        pulumi.set(self, "yaxis", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEventArgs:
    def __init__(__self__, *,
                 q: pulumi.Input[str],
                 tags_execution: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "q", q)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)

    @property
    @pulumi.getter
    def q(self) -> pulumi.Input[str]:
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: pulumi.Input[str]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tags_execution")

    @tags_execution.setter
    def tags_execution(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tags_execution", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryArgs']] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 style: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyleArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyleArgs'] style: Style of the widget graph. One nested block is allowed with the following structure:
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryArgs']]:
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryArgs']]:
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQueryArgs']]:
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyleArgs']]:
        """
        Style of the widget graph. One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupByArgs']]] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupByArgs']]]]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupByArgs']]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupByArgs']]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
               - `q`: (Required) The event query to use in the widget.
               - `tags_execution`: (Optional) The execution method for multi-value filters.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
        - `q`: (Required) The event query to use in the widget.
        - `tags_execution`: (Optional) The execution method for multi-value filters.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionTimeArgs:
    def __init__(__self__, *,
                 live_span: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxisArgs:
    def __init__(__self__, *,
                 include_zero: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 max: Optional[pulumi.Input[str]] = None,
                 min: Optional[pulumi.Input[str]] = None,
                 scale: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] include_zero: Always include zero or fit the axis to the data range.
        :param pulumi.Input[str] label: The label of the axis to display on the graph.
        :param pulumi.Input[str] max: Specify the minimum value to show on y-axis.
        :param pulumi.Input[str] min: Specify the minimum value to show on y-axis.
        :param pulumi.Input[str] scale: Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[pulumi.Input[bool]]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @include_zero.setter
    def include_zero(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_zero", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionArgs:
    def __init__(__self__, *,
                 groups: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 no_group_hosts: Optional[pulumi.Input[bool]] = None,
                 no_metric_hosts: Optional[pulumi.Input[bool]] = None,
                 node_type: Optional[pulumi.Input[str]] = None,
                 request: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestArgs']] = None,
                 scopes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 style: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyleArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[List[pulumi.Input[str]]] groups: The check group to use in the widget.
        :param pulumi.Input[bool] no_group_hosts: Boolean indicating whether to show ungrouped nodes.
        :param pulumi.Input[bool] no_metric_hosts: Boolean indicating whether to show nodes with no metrics.
        :param pulumi.Input[str] node_type: The type of node used. Either "host" or "container".
        :param pulumi.Input[List[pulumi.Input[str]]] scopes: The list of tags to filter nodes by.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyleArgs'] style: Style of the widget graph. One nested block is allowed with the following structure:
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if no_group_hosts is not None:
            pulumi.set(__self__, "no_group_hosts", no_group_hosts)
        if no_metric_hosts is not None:
            pulumi.set(__self__, "no_metric_hosts", no_metric_hosts)
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        The check group to use in the widget.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter(name="noGroupHosts")
    def no_group_hosts(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether to show ungrouped nodes.
        """
        return pulumi.get(self, "no_group_hosts")

    @no_group_hosts.setter
    def no_group_hosts(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_group_hosts", value)

    @property
    @pulumi.getter(name="noMetricHosts")
    def no_metric_hosts(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether to show nodes with no metrics.
        """
        return pulumi.get(self, "no_metric_hosts")

    @no_metric_hosts.setter
    def no_metric_hosts(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_metric_hosts", value)

    @property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of node used. Either "host" or "container".
        """
        return pulumi.get(self, "node_type")

    @node_type.setter
    def node_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_type", value)

    @property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestArgs']]:
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestArgs']]):
        pulumi.set(self, "request", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        The list of tags to filter nodes by.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyleArgs']]:
        """
        Style of the widget graph. One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyleArgs']]):
        pulumi.set(self, "style", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestArgs:
    def __init__(__self__, *,
                 fills: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillArgs']]]] = None,
                 sizes: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeArgs']]]] = None):
        if fills is not None:
            pulumi.set(__self__, "fills", fills)
        if sizes is not None:
            pulumi.set(__self__, "sizes", sizes)

    @property
    @pulumi.getter
    def fills(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillArgs']]]]:
        return pulumi.get(self, "fills")

    @fills.setter
    def fills(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillArgs']]]]):
        pulumi.set(self, "fills", value)

    @property
    @pulumi.getter
    def sizes(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeArgs']]]]:
        return pulumi.get(self, "sizes")

    @sizes.setter
    def sizes(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeArgs']]]]):
        pulumi.set(self, "sizes", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryArgs']] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None):
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryArgs']]:
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryArgs']]:
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQueryArgs']]:
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupByArgs']]] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupByArgs']]]]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupByArgs']]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupByArgs']]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryArgs']] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None):
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryArgs']]:
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryArgs']]:
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQueryArgs']]:
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupByArgs']]] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupByArgs']]]]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupByArgs']]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupByArgs']]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyleArgs:
    def __init__(__self__, *,
                 fill_max: Optional[pulumi.Input[str]] = None,
                 fill_min: Optional[pulumi.Input[str]] = None,
                 palette: Optional[pulumi.Input[str]] = None,
                 palette_flip: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] fill_max: Max value to use to color the map.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `iframe_definition`: The definition for a Iframe widget. Exactly one nested block is allowed with the following structure:
        :param pulumi.Input[str] fill_min: Min value to use to color the map.
        :param pulumi.Input[str] palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
               - `q`: (Required) The event query to use in the widget.
               - `tags_execution`: (Optional) The execution method for multi-value filters.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        :param pulumi.Input[bool] palette_flip: Boolean indicating whether to flip the palette tones.
        """
        if fill_max is not None:
            pulumi.set(__self__, "fill_max", fill_max)
        if fill_min is not None:
            pulumi.set(__self__, "fill_min", fill_min)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_flip is not None:
            pulumi.set(__self__, "palette_flip", palette_flip)

    @property
    @pulumi.getter(name="fillMax")
    def fill_max(self) -> Optional[pulumi.Input[str]]:
        """
        Max value to use to color the map.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `iframe_definition`: The definition for a Iframe widget. Exactly one nested block is allowed with the following structure:
        """
        return pulumi.get(self, "fill_max")

    @fill_max.setter
    def fill_max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fill_max", value)

    @property
    @pulumi.getter(name="fillMin")
    def fill_min(self) -> Optional[pulumi.Input[str]]:
        """
        Min value to use to color the map.
        """
        return pulumi.get(self, "fill_min")

    @fill_min.setter
    def fill_min(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fill_min", value)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
        - `q`: (Required) The event query to use in the widget.
        - `tags_execution`: (Optional) The execution method for multi-value filters.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter(name="paletteFlip")
    def palette_flip(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether to flip the palette tones.
        """
        return pulumi.get(self, "palette_flip")

    @palette_flip.setter
    def palette_flip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "palette_flip", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetIframeDefinitionArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] url: Read only field - The URL of the dashboard.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Read only field - The URL of the dashboard.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetImageDefinitionArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 margin: Optional[pulumi.Input[str]] = None,
                 sizing: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: Read only field - The URL of the dashboard.
        :param pulumi.Input[str] margin: The margins to use around the image. Either "small" or "large".
               - `log_stream_definition`: The definition for a Log Stream widget. Exactly one nested block is allowed with the following structure:
        :param pulumi.Input[str] sizing: The preferred method to adapt the dimensions of the image to those of the widget. One of "center" (center the image in the tile), "zoom" (zoom the image to cover the whole tile) or "fit" (fit the image dimensions to those of the tile).
        """
        pulumi.set(__self__, "url", url)
        if margin is not None:
            pulumi.set(__self__, "margin", margin)
        if sizing is not None:
            pulumi.set(__self__, "sizing", sizing)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Read only field - The URL of the dashboard.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def margin(self) -> Optional[pulumi.Input[str]]:
        """
        The margins to use around the image. Either "small" or "large".
        - `log_stream_definition`: The definition for a Log Stream widget. Exactly one nested block is allowed with the following structure:
        """
        return pulumi.get(self, "margin")

    @margin.setter
    def margin(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "margin", value)

    @property
    @pulumi.getter
    def sizing(self) -> Optional[pulumi.Input[str]]:
        """
        The preferred method to adapt the dimensions of the image to those of the widget. One of "center" (center the image in the tile), "zoom" (zoom the image to cover the whole tile) or "fit" (fit the image dimensions to those of the tile).
        """
        return pulumi.get(self, "sizing")

    @sizing.setter
    def sizing(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sizing", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetLayoutArgs:
    def __init__(__self__, *,
                 height: pulumi.Input[float],
                 width: pulumi.Input[float],
                 x: pulumi.Input[float],
                 y: pulumi.Input[float]):
        """
        :param pulumi.Input[float] height: The height of the widget.
        :param pulumi.Input[float] width: The width of the widget.
        :param pulumi.Input[float] x: The position of the widget on the x (horizontal) axis. Should be greater or equal to 0.
        :param pulumi.Input[float] y: The position of the widget on the y (vertical) axis. Should be greater or equal to 0.
        """
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "width", width)
        pulumi.set(__self__, "x", x)
        pulumi.set(__self__, "y", y)

    @property
    @pulumi.getter
    def height(self) -> pulumi.Input[float]:
        """
        The height of the widget.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: pulumi.Input[float]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def width(self) -> pulumi.Input[float]:
        """
        The width of the widget.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: pulumi.Input[float]):
        pulumi.set(self, "width", value)

    @property
    @pulumi.getter
    def x(self) -> pulumi.Input[float]:
        """
        The position of the widget on the x (horizontal) axis. Should be greater or equal to 0.
        """
        return pulumi.get(self, "x")

    @x.setter
    def x(self, value: pulumi.Input[float]):
        pulumi.set(self, "x", value)

    @property
    @pulumi.getter
    def y(self) -> pulumi.Input[float]:
        """
        The position of the widget on the y (vertical) axis. Should be greater or equal to 0.
        """
        return pulumi.get(self, "y")

    @y.setter
    def y(self, value: pulumi.Input[float]):
        pulumi.set(self, "y", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionArgs:
    def __init__(__self__, *,
                 columns: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 indexes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 logset: Optional[pulumi.Input[str]] = None,
                 message_display: Optional[pulumi.Input[str]] = None,
                 query: Optional[pulumi.Input[str]] = None,
                 show_date_column: Optional[pulumi.Input[bool]] = None,
                 show_message_column: Optional[pulumi.Input[bool]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSortArgs']] = None,
                 time: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionTimeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[List[pulumi.Input[str]]] columns: Stringified list of columns to use. Example: `"["column1","column2","column3"]"`.
        :param pulumi.Input[str] logset: ID of the logset to use.
               - `query`: (Optional) The query to use in the widget.
        :param pulumi.Input[str] message_display: The amount of lines the message column should display. One of: `inline`, `expanded-md`, and `expanded-lg`.
        :param pulumi.Input[bool] show_date_column: If the date column should be displayed.
        :param pulumi.Input[bool] show_message_column: If the message column should be displayed.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if logset is not None:
            warnings.warn("This parameter has been deprecated. Use 'indexes' instead", DeprecationWarning)
            pulumi.log.warn("logset is deprecated: This parameter has been deprecated. Use 'indexes' instead")
        if logset is not None:
            pulumi.set(__self__, "logset", logset)
        if message_display is not None:
            pulumi.set(__self__, "message_display", message_display)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if show_date_column is not None:
            pulumi.set(__self__, "show_date_column", show_date_column)
        if show_message_column is not None:
            pulumi.set(__self__, "show_message_column", show_message_column)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        Stringified list of columns to use. Example: `"["column1","column2","column3"]"`.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter
    def logset(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the logset to use.
        - `query`: (Optional) The query to use in the widget.
        """
        return pulumi.get(self, "logset")

    @logset.setter
    def logset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logset", value)

    @property
    @pulumi.getter(name="messageDisplay")
    def message_display(self) -> Optional[pulumi.Input[str]]:
        """
        The amount of lines the message column should display. One of: `inline`, `expanded-md`, and `expanded-lg`.
        """
        return pulumi.get(self, "message_display")

    @message_display.setter
    def message_display(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_display", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="showDateColumn")
    def show_date_column(self) -> Optional[pulumi.Input[bool]]:
        """
        If the date column should be displayed.
        """
        return pulumi.get(self, "show_date_column")

    @show_date_column.setter
    def show_date_column(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_date_column", value)

    @property
    @pulumi.getter(name="showMessageColumn")
    def show_message_column(self) -> Optional[pulumi.Input[bool]]:
        """
        If the message column should be displayed.
        """
        return pulumi.get(self, "show_message_column")

    @show_message_column.setter
    def show_message_column(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_message_column", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSortArgs']]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionTimeArgs']]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionTimeArgs']]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSortArgs:
    def __init__(__self__, *,
                 column: pulumi.Input[str],
                 order: pulumi.Input[str]):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def column(self) -> pulumi.Input[str]:
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: pulumi.Input[str]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionTimeArgs:
    def __init__(__self__, *,
                 live_span: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetManageStatusDefinitionArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str],
                 color_preference: Optional[pulumi.Input[str]] = None,
                 count: Optional[pulumi.Input[float]] = None,
                 display_format: Optional[pulumi.Input[str]] = None,
                 hide_zero_counts: Optional[pulumi.Input[bool]] = None,
                 show_last_triggered: Optional[pulumi.Input[bool]] = None,
                 sort: Optional[pulumi.Input[str]] = None,
                 start: Optional[pulumi.Input[float]] = None,
                 summary_type: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] color_preference: Whether to colorize text or background. One of "text", "background".
        :param pulumi.Input[str] display_format: The display setting to use. One of "counts", "list", or "countsAndList".
        :param pulumi.Input[bool] hide_zero_counts: Boolean indicating whether to hide empty categories.
        :param pulumi.Input[bool] show_last_triggered: Boolean indicating whether to show when monitors/groups last triggered.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `note_definition`: The definition for a Note widget. Exactly one nested block is allowed with the following structure:
        :param pulumi.Input[str] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        :param pulumi.Input[str] summary_type: The monitor summary type to use. One of "monitors", "groups", or "combined". Defaults to "monitors".
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        pulumi.set(__self__, "query", query)
        if color_preference is not None:
            pulumi.set(__self__, "color_preference", color_preference)
        if count is not None:
            warnings.warn("This parameter has been deprecated", DeprecationWarning)
            pulumi.log.warn("count is deprecated: This parameter has been deprecated")
        if count is not None:
            pulumi.set(__self__, "count", count)
        if display_format is not None:
            pulumi.set(__self__, "display_format", display_format)
        if hide_zero_counts is not None:
            pulumi.set(__self__, "hide_zero_counts", hide_zero_counts)
        if show_last_triggered is not None:
            pulumi.set(__self__, "show_last_triggered", show_last_triggered)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if start is not None:
            warnings.warn("This parameter has been deprecated", DeprecationWarning)
            pulumi.log.warn("start is deprecated: This parameter has been deprecated")
        if start is not None:
            pulumi.set(__self__, "start", start)
        if summary_type is not None:
            pulumi.set(__self__, "summary_type", summary_type)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="colorPreference")
    def color_preference(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to colorize text or background. One of "text", "background".
        """
        return pulumi.get(self, "color_preference")

    @color_preference.setter
    def color_preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color_preference", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter(name="displayFormat")
    def display_format(self) -> Optional[pulumi.Input[str]]:
        """
        The display setting to use. One of "counts", "list", or "countsAndList".
        """
        return pulumi.get(self, "display_format")

    @display_format.setter
    def display_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_format", value)

    @property
    @pulumi.getter(name="hideZeroCounts")
    def hide_zero_counts(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether to hide empty categories.
        """
        return pulumi.get(self, "hide_zero_counts")

    @hide_zero_counts.setter
    def hide_zero_counts(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_zero_counts", value)

    @property
    @pulumi.getter(name="showLastTriggered")
    def show_last_triggered(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether to show when monitors/groups last triggered.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `note_definition`: The definition for a Note widget. Exactly one nested block is allowed with the following structure:
        """
        return pulumi.get(self, "show_last_triggered")

    @show_last_triggered.setter
    def show_last_triggered(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_last_triggered", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input[str]]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "start", value)

    @property
    @pulumi.getter(name="summaryType")
    def summary_type(self) -> Optional[pulumi.Input[str]]:
        """
        The monitor summary type to use. One of "monitors", "groups", or "combined". Defaults to "monitors".
        """
        return pulumi.get(self, "summary_type")

    @summary_type.setter
    def summary_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "summary_type", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetNoteDefinitionArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 background_color: Optional[pulumi.Input[str]] = None,
                 font_size: Optional[pulumi.Input[str]] = None,
                 show_tick: Optional[pulumi.Input[bool]] = None,
                 text_align: Optional[pulumi.Input[str]] = None,
                 tick_edge: Optional[pulumi.Input[str]] = None,
                 tick_pos: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] content: Content of the note.
        :param pulumi.Input[str] background_color: Background color of the note.
        :param pulumi.Input[str] font_size: The size of the text in the widget.
        :param pulumi.Input[bool] show_tick: Whether to show a tick or not.
        :param pulumi.Input[str] text_align: The alignment of the text in the widget.
               - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
               - `q`: (Optional) The metric query to use in the widget
               - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
               - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
               - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] tick_edge: When tick = true, string indicating on which side of the widget the tick should be displayed. One of "bottom", "top", "left", "right".
               - `query_value_definition`: The definition for a Query Value widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
               - `q`: (Optional) The metric query to use in the widget.
               - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
               - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
               - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] tick_pos: When tick = true, string with a percent sign indicating the position of the tick. Example: use tick_pos = "50%" for centered alignment.
        """
        pulumi.set(__self__, "content", content)
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if font_size is not None:
            pulumi.set(__self__, "font_size", font_size)
        if show_tick is not None:
            pulumi.set(__self__, "show_tick", show_tick)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if tick_edge is not None:
            pulumi.set(__self__, "tick_edge", tick_edge)
        if tick_pos is not None:
            pulumi.set(__self__, "tick_pos", tick_pos)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        Content of the note.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[pulumi.Input[str]]:
        """
        Background color of the note.
        """
        return pulumi.get(self, "background_color")

    @background_color.setter
    def background_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "background_color", value)

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the text in the widget.
        """
        return pulumi.get(self, "font_size")

    @font_size.setter
    def font_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "font_size", value)

    @property
    @pulumi.getter(name="showTick")
    def show_tick(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to show a tick or not.
        """
        return pulumi.get(self, "show_tick")

    @show_tick.setter
    def show_tick(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_tick", value)

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the text in the widget.
        - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
        - `q`: (Optional) The metric query to use in the widget
        - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
        - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
        - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "text_align")

    @text_align.setter
    def text_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_align", value)

    @property
    @pulumi.getter(name="tickEdge")
    def tick_edge(self) -> Optional[pulumi.Input[str]]:
        """
        When tick = true, string indicating on which side of the widget the tick should be displayed. One of "bottom", "top", "left", "right".
        - `query_value_definition`: The definition for a Query Value widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
        - `q`: (Optional) The metric query to use in the widget.
        - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
        - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
        - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "tick_edge")

    @tick_edge.setter
    def tick_edge(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tick_edge", value)

    @property
    @pulumi.getter(name="tickPos")
    def tick_pos(self) -> Optional[pulumi.Input[str]]:
        """
        When tick = true, string with a percent sign indicating the position of the tick. Example: use tick_pos = "50%" for centered alignment.
        """
        return pulumi.get(self, "tick_pos")

    @tick_pos.setter
    def tick_pos(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tick_pos", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionArgs:
    def __init__(__self__, *,
                 requests: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestArgs']]]] = None,
                 time: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionTimeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestArgs']]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionTimeArgs']]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionTimeArgs']]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestArgs:
    def __init__(__self__, *,
                 aggregator: Optional[pulumi.Input[str]] = None,
                 alias: Optional[pulumi.Input[str]] = None,
                 apm_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryArgs']] = None,
                 conditional_formats: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormatArgs']]]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryArgs']] = None,
                 order: Optional[pulumi.Input[str]] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregator: The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
               - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        :param pulumi.Input[str] alias: The alias for the column name. Default is the metric name.
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple request blocks are allowed. The structure of this block is described below.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `trace_service_definition`: The definition for a Trace Service widget. Exactly one nested block is allowed with the following structure:
               - `env`: (Required) APM environment.
               - `service`: (Required) APM service.
               - `span_name`: (Required) APM span name.
               - `show_hits`: (Optional) APM span name.
               - `show_hits`: (Optional) Whether to show the hits metrics or not.
               - `show_errors`: (Optional) Whether to show the error metrics or not.
               - `show_latency`: (Optional) Whether to show the latency metrics or not.
               - `show_breakdown`: (Optional) Whether to show the latency breakdown or not.
               - `show_distribution`: (Optional) Whether to show the latency distribution or not.
               - `show_resource_list`: (Optional) Whether to show the resource list or not.
               - `size_format`: (Optional) Size of the widget. Available values are: `small`, `medium`, or `large`.
               - `display_format`: (Optional) Number of columns to display. Available values are: `one_column`, `two_column`, or `three_column`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
        - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        The alias for the column name. Default is the metric name.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryArgs']]:
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple request blocks are allowed. The structure of this block is described below.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `trace_service_definition`: The definition for a Trace Service widget. Exactly one nested block is allowed with the following structure:
        - `env`: (Required) APM environment.
        - `service`: (Required) APM service.
        - `span_name`: (Required) APM span name.
        - `show_hits`: (Optional) APM span name.
        - `show_hits`: (Optional) Whether to show the hits metrics or not.
        - `show_errors`: (Optional) Whether to show the error metrics or not.
        - `show_latency`: (Optional) Whether to show the latency metrics or not.
        - `show_breakdown`: (Optional) Whether to show the latency breakdown or not.
        - `show_distribution`: (Optional) Whether to show the latency distribution or not.
        - `show_resource_list`: (Optional) Whether to show the resource list or not.
        - `size_format`: (Optional) Size of the widget. Available values are: `small`, `medium`, or `large`.
        - `display_format`: (Optional) Number of columns to display. Available values are: `one_column`, `two_column`, or `three_column`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryArgs']]:
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQueryArgs']]:
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupByArgs']]] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupByArgs']]]]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: Comparator to apply from: One of `>`, `>=`, `<`, or `<=`.
        :param pulumi.Input[str] palette: Color palette to apply; One of `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `green`, `green_on_white`, `grey`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `white_on_red`, `white_on_yellow`, or `yellow_on_white`.
        :param pulumi.Input[float] value: Value for the comparator.
        :param pulumi.Input[str] custom_bg_color: Color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: Color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[str] image_url: Displays an image as the background.
               .
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        Comparator to apply from: One of `>`, `>=`, `<`, or `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        Color palette to apply; One of `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `green`, `green_on_white`, `grey`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `white_on_red`, `white_on_yellow`, or `yellow_on_white`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        Value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        Color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        Color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        .
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupByArgs']]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupByArgs']]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionTimeArgs:
    def __init__(__self__, *,
                 live_span: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionArgs:
    def __init__(__self__, *,
                 autoscale: Optional[pulumi.Input[bool]] = None,
                 custom_unit: Optional[pulumi.Input[str]] = None,
                 precision: Optional[pulumi.Input[float]] = None,
                 requests: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestArgs']]]] = None,
                 text_align: Optional[pulumi.Input[str]] = None,
                 time: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTimeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] autoscale: Boolean indicating whether to automatically scale the tile.
        :param pulumi.Input[str] custom_unit: The unit for the value displayed in the widget.
        :param pulumi.Input[float] precision: The precision to use when displaying the tile.
        :param pulumi.Input[str] text_align: The alignment of the text in the widget.
               - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
               - `q`: (Optional) The metric query to use in the widget
               - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
               - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
               - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if custom_unit is not None:
            pulumi.set(__self__, "custom_unit", custom_unit)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether to automatically scale the tile.
        """
        return pulumi.get(self, "autoscale")

    @autoscale.setter
    def autoscale(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "autoscale", value)

    @property
    @pulumi.getter(name="customUnit")
    def custom_unit(self) -> Optional[pulumi.Input[str]]:
        """
        The unit for the value displayed in the widget.
        """
        return pulumi.get(self, "custom_unit")

    @custom_unit.setter
    def custom_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_unit", value)

    @property
    @pulumi.getter
    def precision(self) -> Optional[pulumi.Input[float]]:
        """
        The precision to use when displaying the tile.
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "precision", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestArgs']]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the text in the widget.
        - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
        - `q`: (Optional) The metric query to use in the widget
        - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
        - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
        - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "text_align")

    @text_align.setter
    def text_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_align", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTimeArgs']]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTimeArgs']]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestArgs:
    def __init__(__self__, *,
                 aggregator: Optional[pulumi.Input[str]] = None,
                 apm_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryArgs']] = None,
                 conditional_formats: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormatArgs']]]] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregator: The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
               - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple request blocks are allowed. The structure of this block is described below.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `trace_service_definition`: The definition for a Trace Service widget. Exactly one nested block is allowed with the following structure:
               - `env`: (Required) APM environment.
               - `service`: (Required) APM service.
               - `span_name`: (Required) APM span name.
               - `show_hits`: (Optional) APM span name.
               - `show_hits`: (Optional) Whether to show the hits metrics or not.
               - `show_errors`: (Optional) Whether to show the error metrics or not.
               - `show_latency`: (Optional) Whether to show the latency metrics or not.
               - `show_breakdown`: (Optional) Whether to show the latency breakdown or not.
               - `show_distribution`: (Optional) Whether to show the latency distribution or not.
               - `show_resource_list`: (Optional) Whether to show the resource list or not.
               - `size_format`: (Optional) Size of the widget. Available values are: `small`, `medium`, or `large`.
               - `display_format`: (Optional) Number of columns to display. Available values are: `one_column`, `two_column`, or `three_column`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
        - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryArgs']]:
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple request blocks are allowed. The structure of this block is described below.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `trace_service_definition`: The definition for a Trace Service widget. Exactly one nested block is allowed with the following structure:
        - `env`: (Required) APM environment.
        - `service`: (Required) APM service.
        - `span_name`: (Required) APM span name.
        - `show_hits`: (Optional) APM span name.
        - `show_hits`: (Optional) Whether to show the hits metrics or not.
        - `show_errors`: (Optional) Whether to show the error metrics or not.
        - `show_latency`: (Optional) Whether to show the latency metrics or not.
        - `show_breakdown`: (Optional) Whether to show the latency breakdown or not.
        - `show_distribution`: (Optional) Whether to show the latency distribution or not.
        - `show_resource_list`: (Optional) Whether to show the resource list or not.
        - `size_format`: (Optional) Size of the widget. Available values are: `small`, `medium`, or `large`.
        - `display_format`: (Optional) Number of columns to display. Available values are: `one_column`, `two_column`, or `three_column`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryArgs']]:
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQueryArgs']]:
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupByArgs']]] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupByArgs']]]]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: Comparator to apply from: One of `>`, `>=`, `<`, or `<=`.
        :param pulumi.Input[str] palette: Color palette to apply; One of `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `green`, `green_on_white`, `grey`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `white_on_red`, `white_on_yellow`, or `yellow_on_white`.
        :param pulumi.Input[float] value: Value for the comparator.
        :param pulumi.Input[str] custom_bg_color: Color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: Color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[str] image_url: Displays an image as the background.
               .
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        Comparator to apply from: One of `>`, `>=`, `<`, or `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        Color palette to apply; One of `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `green`, `green_on_white`, `grey`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `white_on_red`, `white_on_yellow`, or `yellow_on_white`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        Value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        Color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        Color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        .
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupByArgs']]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupByArgs']]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTimeArgs:
    def __init__(__self__, *,
                 live_span: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionArgs:
    def __init__(__self__, *,
                 color_by_groups: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 request: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestArgs']] = None,
                 time: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionTimeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None,
                 xaxis: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxisArgs']] = None,
                 yaxis: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxisArgs']] = None):
        """
        :param pulumi.Input[List[pulumi.Input[str]]] color_by_groups: List of groups used for colors.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `servicemap_definition`: The definition for a Service Map widget. Exactly one nested block is allowed with the following structure:
               - `filters`: (Required) Your environment and primary tag (or * if enabled for your account).
               - `service`: (Required) The ID of the service you want to map.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `service_level_objective_definition`: The definition for a Service Level Objective widget. Exactly one nested block is allowed with the following structure:
               - `view_type`: (Required) Type of view to use when displaying the widget. Only "detail" is currently supported.
               - `slo_id`: (Required) The ID of the service level objective used by the widget.
               - `show_error_budget`: (Optional) Whether to show the error budget or not.
               - `view_mode`: (Required) View mode for the widget. One of "overall", "component", or "both".
               - `time_windows`: (Required) List of time windows to display in the widget. Each value in the list must be one of "7d", "30d", "90d", "week_to_date",  "previous_week", "month_to_date", or "previous_month".
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `timeseries_definition`: The definition for a Timeseries  widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
               - `q`: (Optional) The metric query to use in the widget.
               - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
               - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
               - `network_query`: (Optional) The network query to use in the widget. The structure of this block is described below.
               - `rum_query`: (Optional) The rum query to use in the widget. The structure of this block is described below.
               - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        if color_by_groups is not None:
            pulumi.set(__self__, "color_by_groups", color_by_groups)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if xaxis is not None:
            pulumi.set(__self__, "xaxis", xaxis)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter(name="colorByGroups")
    def color_by_groups(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        List of groups used for colors.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `servicemap_definition`: The definition for a Service Map widget. Exactly one nested block is allowed with the following structure:
        - `filters`: (Required) Your environment and primary tag (or * if enabled for your account).
        - `service`: (Required) The ID of the service you want to map.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `service_level_objective_definition`: The definition for a Service Level Objective widget. Exactly one nested block is allowed with the following structure:
        - `view_type`: (Required) Type of view to use when displaying the widget. Only "detail" is currently supported.
        - `slo_id`: (Required) The ID of the service level objective used by the widget.
        - `show_error_budget`: (Optional) Whether to show the error budget or not.
        - `view_mode`: (Required) View mode for the widget. One of "overall", "component", or "both".
        - `time_windows`: (Required) List of time windows to display in the widget. Each value in the list must be one of "7d", "30d", "90d", "week_to_date",  "previous_week", "month_to_date", or "previous_month".
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `timeseries_definition`: The definition for a Timeseries  widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
        - `q`: (Optional) The metric query to use in the widget.
        - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
        - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
        - `network_query`: (Optional) The network query to use in the widget. The structure of this block is described below.
        - `rum_query`: (Optional) The rum query to use in the widget. The structure of this block is described below.
        - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "color_by_groups")

    @color_by_groups.setter
    def color_by_groups(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "color_by_groups", value)

    @property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestArgs']]:
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestArgs']]):
        pulumi.set(self, "request", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionTimeArgs']]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionTimeArgs']]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)

    @property
    @pulumi.getter
    def xaxis(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxisArgs']]:
        return pulumi.get(self, "xaxis")

    @xaxis.setter
    def xaxis(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxisArgs']]):
        pulumi.set(self, "xaxis", value)

    @property
    @pulumi.getter
    def yaxis(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxisArgs']]:
        return pulumi.get(self, "yaxis")

    @yaxis.setter
    def yaxis(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxisArgs']]):
        pulumi.set(self, "yaxis", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestArgs:
    def __init__(__self__, *,
                 xes: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXArgs']]]] = None,
                 ys: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYArgs']]]] = None):
        """
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXArgs']]] xes: The position of the widget on the x (horizontal) axis. Should be greater or equal to 0.
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYArgs']]] ys: The position of the widget on the y (vertical) axis. Should be greater or equal to 0.
        """
        if xes is not None:
            pulumi.set(__self__, "xes", xes)
        if ys is not None:
            pulumi.set(__self__, "ys", ys)

    @property
    @pulumi.getter
    def xes(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXArgs']]]]:
        """
        The position of the widget on the x (horizontal) axis. Should be greater or equal to 0.
        """
        return pulumi.get(self, "xes")

    @xes.setter
    def xes(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXArgs']]]]):
        pulumi.set(self, "xes", value)

    @property
    @pulumi.getter
    def ys(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYArgs']]]]:
        """
        The position of the widget on the y (vertical) axis. Should be greater or equal to 0.
        """
        return pulumi.get(self, "ys")

    @ys.setter
    def ys(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYArgs']]]]):
        pulumi.set(self, "ys", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXArgs:
    def __init__(__self__, *,
                 aggregator: Optional[pulumi.Input[str]] = None,
                 apm_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryArgs']] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregator: The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
               - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
        - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryArgs']]:
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryArgs']]:
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQueryArgs']]:
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupByArgs']]] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupByArgs']]]]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupByArgs']]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupByArgs']]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYArgs:
    def __init__(__self__, *,
                 aggregator: Optional[pulumi.Input[str]] = None,
                 apm_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryArgs']] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregator: The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
               - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
        - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryArgs']]:
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryArgs']]:
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQueryArgs']]:
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupByArgs']]] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupByArgs']]]]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupByArgs']]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupByArgs']]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionTimeArgs:
    def __init__(__self__, *,
                 live_span: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxisArgs:
    def __init__(__self__, *,
                 include_zero: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 max: Optional[pulumi.Input[str]] = None,
                 min: Optional[pulumi.Input[str]] = None,
                 scale: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] include_zero: Always include zero or fit the axis to the data range.
        :param pulumi.Input[str] label: The label of the axis to display on the graph.
        :param pulumi.Input[str] max: Specify the minimum value to show on y-axis.
        :param pulumi.Input[str] min: Specify the minimum value to show on y-axis.
        :param pulumi.Input[str] scale: Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[pulumi.Input[bool]]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @include_zero.setter
    def include_zero(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_zero", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxisArgs:
    def __init__(__self__, *,
                 include_zero: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 max: Optional[pulumi.Input[str]] = None,
                 min: Optional[pulumi.Input[str]] = None,
                 scale: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] include_zero: Always include zero or fit the axis to the data range.
        :param pulumi.Input[str] label: The label of the axis to display on the graph.
        :param pulumi.Input[str] max: Specify the minimum value to show on y-axis.
        :param pulumi.Input[str] min: Specify the minimum value to show on y-axis.
        :param pulumi.Input[str] scale: Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[pulumi.Input[bool]]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @include_zero.setter
    def include_zero(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_zero", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinitionArgs:
    def __init__(__self__, *,
                 slo_id: pulumi.Input[str],
                 time_windows: pulumi.Input[List[pulumi.Input[str]]],
                 view_mode: pulumi.Input[str],
                 view_type: pulumi.Input[str],
                 show_error_budget: Optional[pulumi.Input[bool]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        pulumi.set(__self__, "slo_id", slo_id)
        pulumi.set(__self__, "time_windows", time_windows)
        pulumi.set(__self__, "view_mode", view_mode)
        pulumi.set(__self__, "view_type", view_type)
        if show_error_budget is not None:
            pulumi.set(__self__, "show_error_budget", show_error_budget)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "slo_id")

    @slo_id.setter
    def slo_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "slo_id", value)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> pulumi.Input[List[pulumi.Input[str]]]:
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: pulumi.Input[List[pulumi.Input[str]]]):
        pulumi.set(self, "time_windows", value)

    @property
    @pulumi.getter(name="viewMode")
    def view_mode(self) -> pulumi.Input[str]:
        return pulumi.get(self, "view_mode")

    @view_mode.setter
    def view_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "view_mode", value)

    @property
    @pulumi.getter(name="viewType")
    def view_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "view_type")

    @view_type.setter
    def view_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "view_type", value)

    @property
    @pulumi.getter(name="showErrorBudget")
    def show_error_budget(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "show_error_budget")

    @show_error_budget.setter
    def show_error_budget(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_error_budget", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetServicemapDefinitionArgs:
    def __init__(__self__, *,
                 filters: pulumi.Input[List[pulumi.Input[str]]],
                 service: pulumi.Input[str],
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "service", service)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def filters(self) -> pulumi.Input[List[pulumi.Input[str]]]:
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: pulumi.Input[List[pulumi.Input[str]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionArgs:
    def __init__(__self__, *,
                 events: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEventArgs']]]] = None,
                 legend_size: Optional[pulumi.Input[str]] = None,
                 markers: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarkerArgs']]]] = None,
                 requests: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestArgs']]]] = None,
                 show_legend: Optional[pulumi.Input[bool]] = None,
                 time: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionTimeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None,
                 yaxis: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxisArgs']] = None):
        """
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarkerArgs']]] markers: Nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple marker blocks are allowed within a given tile_def block.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
               - `q`: (Required) The event query to use in the widget.
               - `tags_execution`: (Optional) The execution method for multi-value filters.
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
               - `toplist_definition`: The definition for a Toplist  widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
               - `q`: (Optional) The metric query to use in the widget.
               - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
               - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
               - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        if events is not None:
            pulumi.set(__self__, "events", events)
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if markers is not None:
            pulumi.set(__self__, "markers", markers)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter
    def events(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEventArgs']]]]:
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEventArgs']]]]):
        pulumi.set(self, "events", value)

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "legend_size")

    @legend_size.setter
    def legend_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "legend_size", value)

    @property
    @pulumi.getter
    def markers(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarkerArgs']]]]:
        """
        Nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple marker blocks are allowed within a given tile_def block.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
        - `q`: (Required) The event query to use in the widget.
        - `tags_execution`: (Optional) The execution method for multi-value filters.
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        - `toplist_definition`: The definition for a Toplist  widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
        - `q`: (Optional) The metric query to use in the widget.
        - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
        - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
        - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "markers")

    @markers.setter
    def markers(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarkerArgs']]]]):
        pulumi.set(self, "markers", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestArgs']]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "show_legend")

    @show_legend.setter
    def show_legend(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_legend", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionTimeArgs']]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionTimeArgs']]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)

    @property
    @pulumi.getter
    def yaxis(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxisArgs']]:
        return pulumi.get(self, "yaxis")

    @yaxis.setter
    def yaxis(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxisArgs']]):
        pulumi.set(self, "yaxis", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEventArgs:
    def __init__(__self__, *,
                 q: pulumi.Input[str],
                 tags_execution: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "q", q)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)

    @property
    @pulumi.getter
    def q(self) -> pulumi.Input[str]:
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: pulumi.Input[str]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tags_execution")

    @tags_execution.setter
    def tags_execution(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tags_execution", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarkerArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 display_type: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Value for the comparator.
        :param pulumi.Input[str] display_type: Type of display to use for the request. Available values are: `area`, `bars`, or `line`.
        :param pulumi.Input[str] label: The label of the axis to display on the graph.
        """
        pulumi.set(__self__, "value", value)
        if display_type is not None:
            pulumi.set(__self__, "display_type", display_type)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="displayType")
    def display_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of display to use for the request. Available values are: `area`, `bars`, or `line`.
        """
        return pulumi.get(self, "display_type")

    @display_type.setter
    def display_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_type", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryArgs']] = None,
                 display_type: Optional[pulumi.Input[str]] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryArgs']] = None,
                 metadatas: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadataArgs']]]] = None,
                 network_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 rum_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryArgs']] = None,
                 style: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyleArgs']] = None):
        """
        :param pulumi.Input[str] display_type: Type of display to use for the request. Available values are: `area`, `bars`, or `line`.
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadataArgs']]] metadatas: . Used to define expression aliases. Multiple nested blocks are allowed with the following structure:
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyleArgs'] style: Style of the widget graph. One nested block is allowed with the following structure:
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if display_type is not None:
            pulumi.set(__self__, "display_type", display_type)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if network_query is not None:
            pulumi.set(__self__, "network_query", network_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryArgs']]:
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="displayType")
    def display_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of display to use for the request. Available values are: `area`, `bars`, or `line`.
        """
        return pulumi.get(self, "display_type")

    @display_type.setter
    def display_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_type", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryArgs']]:
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadataArgs']]]]:
        """
        . Used to define expression aliases. Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "metadatas")

    @metadatas.setter
    def metadatas(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadataArgs']]]]):
        pulumi.set(self, "metadatas", value)

    @property
    @pulumi.getter(name="networkQuery")
    def network_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryArgs']]:
        return pulumi.get(self, "network_query")

    @network_query.setter
    def network_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryArgs']]):
        pulumi.set(self, "network_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQueryArgs']]:
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryArgs']]:
        return pulumi.get(self, "rum_query")

    @rum_query.setter
    def rum_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryArgs']]):
        pulumi.set(self, "rum_query", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyleArgs']]:
        """
        Style of the widget graph. One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupByArgs']]] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupByArgs']]]]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupByArgs']]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupByArgs']]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadataArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 alias_name: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        if alias_name is not None:
            pulumi.set(__self__, "alias_name", alias_name)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter(name="aliasName")
    def alias_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "alias_name")

    @alias_name.setter
    def alias_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias_name", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs']]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs']]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupByArgs']]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupByArgs']]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyleArgs:
    def __init__(__self__, *,
                 line_type: Optional[pulumi.Input[str]] = None,
                 line_width: Optional[pulumi.Input[str]] = None,
                 palette: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] line_type: Type of lines displayed. Available values are: `dashed`, `dotted`, or `solid`.
        :param pulumi.Input[str] line_width: Width of line displayed. Available values are: `normal`, `thick`, or `thin`.
        :param pulumi.Input[str] palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
               - `q`: (Required) The event query to use in the widget.
               - `tags_execution`: (Optional) The execution method for multi-value filters.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        if line_type is not None:
            pulumi.set(__self__, "line_type", line_type)
        if line_width is not None:
            pulumi.set(__self__, "line_width", line_width)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter(name="lineType")
    def line_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of lines displayed. Available values are: `dashed`, `dotted`, or `solid`.
        """
        return pulumi.get(self, "line_type")

    @line_type.setter
    def line_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "line_type", value)

    @property
    @pulumi.getter(name="lineWidth")
    def line_width(self) -> Optional[pulumi.Input[str]]:
        """
        Width of line displayed. Available values are: `normal`, `thick`, or `thin`.
        """
        return pulumi.get(self, "line_width")

    @line_width.setter
    def line_width(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "line_width", value)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
        - `q`: (Required) The event query to use in the widget.
        - `tags_execution`: (Optional) The execution method for multi-value filters.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionTimeArgs:
    def __init__(__self__, *,
                 live_span: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxisArgs:
    def __init__(__self__, *,
                 include_zero: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 max: Optional[pulumi.Input[str]] = None,
                 min: Optional[pulumi.Input[str]] = None,
                 scale: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] include_zero: Always include zero or fit the axis to the data range.
        :param pulumi.Input[str] label: The label of the axis to display on the graph.
        :param pulumi.Input[str] max: Specify the minimum value to show on y-axis.
        :param pulumi.Input[str] min: Specify the minimum value to show on y-axis.
        :param pulumi.Input[str] scale: Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[pulumi.Input[bool]]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @include_zero.setter
    def include_zero(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_zero", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionArgs:
    def __init__(__self__, *,
                 requests: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestArgs']]]] = None,
                 time: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionTimeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestArgs']]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionTimeArgs']]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionTimeArgs']]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryArgs']] = None,
                 conditional_formats: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormatArgs']]]] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 style: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyleArgs']] = None):
        """
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple request blocks are allowed. The structure of this block is described below.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `trace_service_definition`: The definition for a Trace Service widget. Exactly one nested block is allowed with the following structure:
               - `env`: (Required) APM environment.
               - `service`: (Required) APM service.
               - `span_name`: (Required) APM span name.
               - `show_hits`: (Optional) APM span name.
               - `show_hits`: (Optional) Whether to show the hits metrics or not.
               - `show_errors`: (Optional) Whether to show the error metrics or not.
               - `show_latency`: (Optional) Whether to show the latency metrics or not.
               - `show_breakdown`: (Optional) Whether to show the latency breakdown or not.
               - `show_distribution`: (Optional) Whether to show the latency distribution or not.
               - `show_resource_list`: (Optional) Whether to show the resource list or not.
               - `size_format`: (Optional) Size of the widget. Available values are: `small`, `medium`, or `large`.
               - `display_format`: (Optional) Number of columns to display. Available values are: `one_column`, `two_column`, or `three_column`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyleArgs'] style: Style of the widget graph. One nested block is allowed with the following structure:
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryArgs']]:
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple request blocks are allowed. The structure of this block is described below.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `trace_service_definition`: The definition for a Trace Service widget. Exactly one nested block is allowed with the following structure:
        - `env`: (Required) APM environment.
        - `service`: (Required) APM service.
        - `span_name`: (Required) APM span name.
        - `show_hits`: (Optional) APM span name.
        - `show_hits`: (Optional) Whether to show the hits metrics or not.
        - `show_errors`: (Optional) Whether to show the error metrics or not.
        - `show_latency`: (Optional) Whether to show the latency metrics or not.
        - `show_breakdown`: (Optional) Whether to show the latency breakdown or not.
        - `show_distribution`: (Optional) Whether to show the latency distribution or not.
        - `show_resource_list`: (Optional) Whether to show the resource list or not.
        - `size_format`: (Optional) Size of the widget. Available values are: `small`, `medium`, or `large`.
        - `display_format`: (Optional) Number of columns to display. Available values are: `one_column`, `two_column`, or `three_column`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryArgs']]:
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQueryArgs']]:
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyleArgs']]:
        """
        Style of the widget graph. One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupByArgs']]] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupByArgs']]]]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: Comparator to apply from: One of `>`, `>=`, `<`, or `<=`.
        :param pulumi.Input[str] palette: Color palette to apply; One of `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `green`, `green_on_white`, `grey`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `white_on_red`, `white_on_yellow`, or `yellow_on_white`.
        :param pulumi.Input[float] value: Value for the comparator.
        :param pulumi.Input[str] custom_bg_color: Color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: Color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[str] image_url: Displays an image as the background.
               .
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        Comparator to apply from: One of `>`, `>=`, `<`, or `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        Color palette to apply; One of `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `green`, `green_on_white`, `grey`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `white_on_red`, `white_on_yellow`, or `yellow_on_white`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        Value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        Color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        Color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        .
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupByArgs']]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupByArgs']]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
               - `q`: (Required) The event query to use in the widget.
               - `tags_execution`: (Optional) The execution method for multi-value filters.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
        - `q`: (Required) The event query to use in the widget.
        - `tags_execution`: (Optional) The execution method for multi-value filters.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionTimeArgs:
    def __init__(__self__, *,
                 live_span: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTraceServiceDefinitionArgs:
    def __init__(__self__, *,
                 env: pulumi.Input[str],
                 service: pulumi.Input[str],
                 span_name: pulumi.Input[str],
                 display_format: Optional[pulumi.Input[str]] = None,
                 show_breakdown: Optional[pulumi.Input[bool]] = None,
                 show_distribution: Optional[pulumi.Input[bool]] = None,
                 show_errors: Optional[pulumi.Input[bool]] = None,
                 show_hits: Optional[pulumi.Input[bool]] = None,
                 show_latency: Optional[pulumi.Input[bool]] = None,
                 show_resource_list: Optional[pulumi.Input[bool]] = None,
                 size_format: Optional[pulumi.Input[str]] = None,
                 time: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTraceServiceDefinitionTimeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] display_format: The display setting to use. One of "counts", "list", or "countsAndList".
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "span_name", span_name)
        if display_format is not None:
            pulumi.set(__self__, "display_format", display_format)
        if show_breakdown is not None:
            pulumi.set(__self__, "show_breakdown", show_breakdown)
        if show_distribution is not None:
            pulumi.set(__self__, "show_distribution", show_distribution)
        if show_errors is not None:
            pulumi.set(__self__, "show_errors", show_errors)
        if show_hits is not None:
            pulumi.set(__self__, "show_hits", show_hits)
        if show_latency is not None:
            pulumi.set(__self__, "show_latency", show_latency)
        if show_resource_list is not None:
            pulumi.set(__self__, "show_resource_list", show_resource_list)
        if size_format is not None:
            pulumi.set(__self__, "size_format", size_format)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter(name="spanName")
    def span_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "span_name")

    @span_name.setter
    def span_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "span_name", value)

    @property
    @pulumi.getter(name="displayFormat")
    def display_format(self) -> Optional[pulumi.Input[str]]:
        """
        The display setting to use. One of "counts", "list", or "countsAndList".
        """
        return pulumi.get(self, "display_format")

    @display_format.setter
    def display_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_format", value)

    @property
    @pulumi.getter(name="showBreakdown")
    def show_breakdown(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "show_breakdown")

    @show_breakdown.setter
    def show_breakdown(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_breakdown", value)

    @property
    @pulumi.getter(name="showDistribution")
    def show_distribution(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "show_distribution")

    @show_distribution.setter
    def show_distribution(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_distribution", value)

    @property
    @pulumi.getter(name="showErrors")
    def show_errors(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "show_errors")

    @show_errors.setter
    def show_errors(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_errors", value)

    @property
    @pulumi.getter(name="showHits")
    def show_hits(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "show_hits")

    @show_hits.setter
    def show_hits(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_hits", value)

    @property
    @pulumi.getter(name="showLatency")
    def show_latency(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "show_latency")

    @show_latency.setter
    def show_latency(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_latency", value)

    @property
    @pulumi.getter(name="showResourceList")
    def show_resource_list(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "show_resource_list")

    @show_resource_list.setter
    def show_resource_list(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_resource_list", value)

    @property
    @pulumi.getter(name="sizeFormat")
    def size_format(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "size_format")

    @size_format.setter
    def size_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size_format", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTraceServiceDefinitionTimeArgs']]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetTraceServiceDefinitionTimeArgs']]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetTraceServiceDefinitionTimeArgs:
    def __init__(__self__, *,
                 live_span: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionArgs:
    def __init__(__self__, *,
                 events: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHeatmapDefinitionEventArgs']]]] = None,
                 legend_size: Optional[pulumi.Input[str]] = None,
                 requests: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestArgs']]]] = None,
                 show_legend: Optional[pulumi.Input[bool]] = None,
                 time: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionTimeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None,
                 yaxis: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionYaxisArgs']] = None):
        """
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        if events is not None:
            pulumi.set(__self__, "events", events)
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter
    def events(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHeatmapDefinitionEventArgs']]]]:
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHeatmapDefinitionEventArgs']]]]):
        pulumi.set(self, "events", value)

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "legend_size")

    @legend_size.setter
    def legend_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "legend_size", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestArgs']]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "show_legend")

    @show_legend.setter
    def show_legend(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_legend", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionTimeArgs']]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionTimeArgs']]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)

    @property
    @pulumi.getter
    def yaxis(self) -> Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionYaxisArgs']]:
        return pulumi.get(self, "yaxis")

    @yaxis.setter
    def yaxis(self, value: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionYaxisArgs']]):
        pulumi.set(self, "yaxis", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionEventArgs:
    def __init__(__self__, *,
                 q: pulumi.Input[str],
                 tags_execution: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "q", q)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)

    @property
    @pulumi.getter
    def q(self) -> pulumi.Input[str]:
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: pulumi.Input[str]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tags_execution")

    @tags_execution.setter
    def tags_execution(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tags_execution", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestApmQueryArgs']] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 style: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestStyleArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetHeatmapDefinitionRequestStyleArgs'] style: Style of the widget graph. One nested block is allowed with the following structure:
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestApmQueryArgs']]:
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestLogQueryArgs']]:
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestProcessQueryArgs']]:
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestStyleArgs']]:
        """
        Style of the widget graph. One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestApmQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetHeatmapDefinitionRequestApmQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestApmQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestApmQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetHeatmapDefinitionRequestApmQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestApmQueryGroupByArgs']]] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param pulumi.Input['DashboardWidgetHeatmapDefinitionRequestApmQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetHeatmapDefinitionRequestApmQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetHeatmapDefinitionRequestApmQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestApmQueryGroupByArgs']]]]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestApmQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestApmQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestApmQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestApmQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestLogQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetHeatmapDefinitionRequestLogQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestLogQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestLogQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetHeatmapDefinitionRequestLogQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestLogQueryGroupByArgs']]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input['DashboardWidgetHeatmapDefinitionRequestLogQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetHeatmapDefinitionRequestLogQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetHeatmapDefinitionRequestLogQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestLogQueryGroupByArgs']]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestLogQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestLogQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestLogQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestLogQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
               - `q`: (Required) The event query to use in the widget.
               - `tags_execution`: (Optional) The execution method for multi-value filters.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
        - `q`: (Required) The event query to use in the widget.
        - `tags_execution`: (Optional) The execution method for multi-value filters.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionTimeArgs:
    def __init__(__self__, *,
                 live_span: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionYaxisArgs:
    def __init__(__self__, *,
                 include_zero: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 max: Optional[pulumi.Input[str]] = None,
                 min: Optional[pulumi.Input[str]] = None,
                 scale: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] include_zero: Always include zero or fit the axis to the data range.
        :param pulumi.Input[str] label: The label of the axis to display on the graph.
        :param pulumi.Input[str] max: Specify the minimum value to show on y-axis.
        :param pulumi.Input[str] min: Specify the minimum value to show on y-axis.
        :param pulumi.Input[str] scale: Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[pulumi.Input[bool]]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @include_zero.setter
    def include_zero(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_zero", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionArgs:
    def __init__(__self__, *,
                 groups: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 no_group_hosts: Optional[pulumi.Input[bool]] = None,
                 no_metric_hosts: Optional[pulumi.Input[bool]] = None,
                 node_type: Optional[pulumi.Input[str]] = None,
                 request: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestArgs']] = None,
                 scopes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 style: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionStyleArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[List[pulumi.Input[str]]] groups: The check group to use in the widget.
        :param pulumi.Input[bool] no_group_hosts: Boolean indicating whether to show ungrouped nodes.
        :param pulumi.Input[bool] no_metric_hosts: Boolean indicating whether to show nodes with no metrics.
        :param pulumi.Input[str] node_type: The type of node used. Either "host" or "container".
        :param pulumi.Input[List[pulumi.Input[str]]] scopes: The list of tags to filter nodes by.
        :param pulumi.Input['DashboardWidgetHostmapDefinitionStyleArgs'] style: Style of the widget graph. One nested block is allowed with the following structure:
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if no_group_hosts is not None:
            pulumi.set(__self__, "no_group_hosts", no_group_hosts)
        if no_metric_hosts is not None:
            pulumi.set(__self__, "no_metric_hosts", no_metric_hosts)
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        The check group to use in the widget.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter(name="noGroupHosts")
    def no_group_hosts(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether to show ungrouped nodes.
        """
        return pulumi.get(self, "no_group_hosts")

    @no_group_hosts.setter
    def no_group_hosts(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_group_hosts", value)

    @property
    @pulumi.getter(name="noMetricHosts")
    def no_metric_hosts(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether to show nodes with no metrics.
        """
        return pulumi.get(self, "no_metric_hosts")

    @no_metric_hosts.setter
    def no_metric_hosts(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_metric_hosts", value)

    @property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of node used. Either "host" or "container".
        """
        return pulumi.get(self, "node_type")

    @node_type.setter
    def node_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_type", value)

    @property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestArgs']]:
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestArgs']]):
        pulumi.set(self, "request", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        The list of tags to filter nodes by.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['DashboardWidgetHostmapDefinitionStyleArgs']]:
        """
        Style of the widget graph. One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionStyleArgs']]):
        pulumi.set(self, "style", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestArgs:
    def __init__(__self__, *,
                 fills: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillArgs']]]] = None,
                 sizes: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeArgs']]]] = None):
        if fills is not None:
            pulumi.set(__self__, "fills", fills)
        if sizes is not None:
            pulumi.set(__self__, "sizes", sizes)

    @property
    @pulumi.getter
    def fills(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillArgs']]]]:
        return pulumi.get(self, "fills")

    @fills.setter
    def fills(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillArgs']]]]):
        pulumi.set(self, "fills", value)

    @property
    @pulumi.getter
    def sizes(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeArgs']]]]:
        return pulumi.get(self, "sizes")

    @sizes.setter
    def sizes(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeArgs']]]]):
        pulumi.set(self, "sizes", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestFillArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillApmQueryArgs']] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None):
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillApmQueryArgs']]:
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillLogQueryArgs']]:
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillProcessQueryArgs']]:
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestFillApmQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillApmQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillApmQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillApmQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupByArgs']]] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillApmQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillApmQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillApmQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupByArgs']]]]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillApmQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillApmQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestFillApmQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestFillApmQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestFillLogQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillLogQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillLogQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillLogQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupByArgs']]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillLogQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillLogQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillLogQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupByArgs']]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillLogQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillLogQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestFillLogQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestFillLogQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestFillProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestSizeArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeApmQueryArgs']] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None):
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeApmQueryArgs']]:
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeLogQueryArgs']]:
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeProcessQueryArgs']]:
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestSizeApmQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeApmQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeApmQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeApmQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupByArgs']]] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeApmQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeApmQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeApmQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupByArgs']]]]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeApmQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeApmQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestSizeApmQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestSizeApmQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestSizeLogQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeLogQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeLogQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeLogQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupByArgs']]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeLogQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeLogQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeLogQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupByArgs']]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeLogQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeLogQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestSizeLogQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestSizeLogQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestSizeProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionStyleArgs:
    def __init__(__self__, *,
                 fill_max: Optional[pulumi.Input[str]] = None,
                 fill_min: Optional[pulumi.Input[str]] = None,
                 palette: Optional[pulumi.Input[str]] = None,
                 palette_flip: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] fill_max: Max value to use to color the map.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `iframe_definition`: The definition for a Iframe widget. Exactly one nested block is allowed with the following structure:
        :param pulumi.Input[str] fill_min: Min value to use to color the map.
        :param pulumi.Input[str] palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
               - `q`: (Required) The event query to use in the widget.
               - `tags_execution`: (Optional) The execution method for multi-value filters.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        :param pulumi.Input[bool] palette_flip: Boolean indicating whether to flip the palette tones.
        """
        if fill_max is not None:
            pulumi.set(__self__, "fill_max", fill_max)
        if fill_min is not None:
            pulumi.set(__self__, "fill_min", fill_min)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_flip is not None:
            pulumi.set(__self__, "palette_flip", palette_flip)

    @property
    @pulumi.getter(name="fillMax")
    def fill_max(self) -> Optional[pulumi.Input[str]]:
        """
        Max value to use to color the map.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `iframe_definition`: The definition for a Iframe widget. Exactly one nested block is allowed with the following structure:
        """
        return pulumi.get(self, "fill_max")

    @fill_max.setter
    def fill_max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fill_max", value)

    @property
    @pulumi.getter(name="fillMin")
    def fill_min(self) -> Optional[pulumi.Input[str]]:
        """
        Min value to use to color the map.
        """
        return pulumi.get(self, "fill_min")

    @fill_min.setter
    def fill_min(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fill_min", value)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
        - `q`: (Required) The event query to use in the widget.
        - `tags_execution`: (Optional) The execution method for multi-value filters.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter(name="paletteFlip")
    def palette_flip(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether to flip the palette tones.
        """
        return pulumi.get(self, "palette_flip")

    @palette_flip.setter
    def palette_flip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "palette_flip", value)


@pulumi.input_type
class DashboardWidgetIframeDefinitionArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] url: Read only field - The URL of the dashboard.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Read only field - The URL of the dashboard.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class DashboardWidgetImageDefinitionArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 margin: Optional[pulumi.Input[str]] = None,
                 sizing: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: Read only field - The URL of the dashboard.
        :param pulumi.Input[str] margin: The margins to use around the image. Either "small" or "large".
               - `log_stream_definition`: The definition for a Log Stream widget. Exactly one nested block is allowed with the following structure:
        :param pulumi.Input[str] sizing: The preferred method to adapt the dimensions of the image to those of the widget. One of "center" (center the image in the tile), "zoom" (zoom the image to cover the whole tile) or "fit" (fit the image dimensions to those of the tile).
        """
        pulumi.set(__self__, "url", url)
        if margin is not None:
            pulumi.set(__self__, "margin", margin)
        if sizing is not None:
            pulumi.set(__self__, "sizing", sizing)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Read only field - The URL of the dashboard.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def margin(self) -> Optional[pulumi.Input[str]]:
        """
        The margins to use around the image. Either "small" or "large".
        - `log_stream_definition`: The definition for a Log Stream widget. Exactly one nested block is allowed with the following structure:
        """
        return pulumi.get(self, "margin")

    @margin.setter
    def margin(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "margin", value)

    @property
    @pulumi.getter
    def sizing(self) -> Optional[pulumi.Input[str]]:
        """
        The preferred method to adapt the dimensions of the image to those of the widget. One of "center" (center the image in the tile), "zoom" (zoom the image to cover the whole tile) or "fit" (fit the image dimensions to those of the tile).
        """
        return pulumi.get(self, "sizing")

    @sizing.setter
    def sizing(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sizing", value)


@pulumi.input_type
class DashboardWidgetLayoutArgs:
    def __init__(__self__, *,
                 height: pulumi.Input[float],
                 width: pulumi.Input[float],
                 x: pulumi.Input[float],
                 y: pulumi.Input[float]):
        """
        :param pulumi.Input[float] height: The height of the widget.
        :param pulumi.Input[float] width: The width of the widget.
        :param pulumi.Input[float] x: The position of the widget on the x (horizontal) axis. Should be greater or equal to 0.
        :param pulumi.Input[float] y: The position of the widget on the y (vertical) axis. Should be greater or equal to 0.
        """
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "width", width)
        pulumi.set(__self__, "x", x)
        pulumi.set(__self__, "y", y)

    @property
    @pulumi.getter
    def height(self) -> pulumi.Input[float]:
        """
        The height of the widget.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: pulumi.Input[float]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def width(self) -> pulumi.Input[float]:
        """
        The width of the widget.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: pulumi.Input[float]):
        pulumi.set(self, "width", value)

    @property
    @pulumi.getter
    def x(self) -> pulumi.Input[float]:
        """
        The position of the widget on the x (horizontal) axis. Should be greater or equal to 0.
        """
        return pulumi.get(self, "x")

    @x.setter
    def x(self, value: pulumi.Input[float]):
        pulumi.set(self, "x", value)

    @property
    @pulumi.getter
    def y(self) -> pulumi.Input[float]:
        """
        The position of the widget on the y (vertical) axis. Should be greater or equal to 0.
        """
        return pulumi.get(self, "y")

    @y.setter
    def y(self, value: pulumi.Input[float]):
        pulumi.set(self, "y", value)


@pulumi.input_type
class DashboardWidgetLogStreamDefinitionArgs:
    def __init__(__self__, *,
                 columns: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 indexes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 logset: Optional[pulumi.Input[str]] = None,
                 message_display: Optional[pulumi.Input[str]] = None,
                 query: Optional[pulumi.Input[str]] = None,
                 show_date_column: Optional[pulumi.Input[bool]] = None,
                 show_message_column: Optional[pulumi.Input[bool]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetLogStreamDefinitionSortArgs']] = None,
                 time: Optional[pulumi.Input['DashboardWidgetLogStreamDefinitionTimeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[List[pulumi.Input[str]]] columns: Stringified list of columns to use. Example: `"["column1","column2","column3"]"`.
        :param pulumi.Input[str] logset: ID of the logset to use.
               - `query`: (Optional) The query to use in the widget.
        :param pulumi.Input[str] message_display: The amount of lines the message column should display. One of: `inline`, `expanded-md`, and `expanded-lg`.
        :param pulumi.Input[bool] show_date_column: If the date column should be displayed.
        :param pulumi.Input[bool] show_message_column: If the message column should be displayed.
        :param pulumi.Input['DashboardWidgetLogStreamDefinitionSortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if logset is not None:
            warnings.warn("This parameter has been deprecated. Use 'indexes' instead", DeprecationWarning)
            pulumi.log.warn("logset is deprecated: This parameter has been deprecated. Use 'indexes' instead")
        if logset is not None:
            pulumi.set(__self__, "logset", logset)
        if message_display is not None:
            pulumi.set(__self__, "message_display", message_display)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if show_date_column is not None:
            pulumi.set(__self__, "show_date_column", show_date_column)
        if show_message_column is not None:
            pulumi.set(__self__, "show_message_column", show_message_column)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        Stringified list of columns to use. Example: `"["column1","column2","column3"]"`.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter
    def logset(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the logset to use.
        - `query`: (Optional) The query to use in the widget.
        """
        return pulumi.get(self, "logset")

    @logset.setter
    def logset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logset", value)

    @property
    @pulumi.getter(name="messageDisplay")
    def message_display(self) -> Optional[pulumi.Input[str]]:
        """
        The amount of lines the message column should display. One of: `inline`, `expanded-md`, and `expanded-lg`.
        """
        return pulumi.get(self, "message_display")

    @message_display.setter
    def message_display(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_display", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="showDateColumn")
    def show_date_column(self) -> Optional[pulumi.Input[bool]]:
        """
        If the date column should be displayed.
        """
        return pulumi.get(self, "show_date_column")

    @show_date_column.setter
    def show_date_column(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_date_column", value)

    @property
    @pulumi.getter(name="showMessageColumn")
    def show_message_column(self) -> Optional[pulumi.Input[bool]]:
        """
        If the message column should be displayed.
        """
        return pulumi.get(self, "show_message_column")

    @show_message_column.setter
    def show_message_column(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_message_column", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetLogStreamDefinitionSortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetLogStreamDefinitionSortArgs']]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input['DashboardWidgetLogStreamDefinitionTimeArgs']]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input['DashboardWidgetLogStreamDefinitionTimeArgs']]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetLogStreamDefinitionSortArgs:
    def __init__(__self__, *,
                 column: pulumi.Input[str],
                 order: pulumi.Input[str]):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def column(self) -> pulumi.Input[str]:
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: pulumi.Input[str]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class DashboardWidgetLogStreamDefinitionTimeArgs:
    def __init__(__self__, *,
                 live_span: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)


@pulumi.input_type
class DashboardWidgetManageStatusDefinitionArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str],
                 color_preference: Optional[pulumi.Input[str]] = None,
                 count: Optional[pulumi.Input[float]] = None,
                 display_format: Optional[pulumi.Input[str]] = None,
                 hide_zero_counts: Optional[pulumi.Input[bool]] = None,
                 show_last_triggered: Optional[pulumi.Input[bool]] = None,
                 sort: Optional[pulumi.Input[str]] = None,
                 start: Optional[pulumi.Input[float]] = None,
                 summary_type: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] color_preference: Whether to colorize text or background. One of "text", "background".
        :param pulumi.Input[str] display_format: The display setting to use. One of "counts", "list", or "countsAndList".
        :param pulumi.Input[bool] hide_zero_counts: Boolean indicating whether to hide empty categories.
        :param pulumi.Input[bool] show_last_triggered: Boolean indicating whether to show when monitors/groups last triggered.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `note_definition`: The definition for a Note widget. Exactly one nested block is allowed with the following structure:
        :param pulumi.Input[str] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        :param pulumi.Input[str] summary_type: The monitor summary type to use. One of "monitors", "groups", or "combined". Defaults to "monitors".
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        pulumi.set(__self__, "query", query)
        if color_preference is not None:
            pulumi.set(__self__, "color_preference", color_preference)
        if count is not None:
            warnings.warn("This parameter has been deprecated", DeprecationWarning)
            pulumi.log.warn("count is deprecated: This parameter has been deprecated")
        if count is not None:
            pulumi.set(__self__, "count", count)
        if display_format is not None:
            pulumi.set(__self__, "display_format", display_format)
        if hide_zero_counts is not None:
            pulumi.set(__self__, "hide_zero_counts", hide_zero_counts)
        if show_last_triggered is not None:
            pulumi.set(__self__, "show_last_triggered", show_last_triggered)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if start is not None:
            warnings.warn("This parameter has been deprecated", DeprecationWarning)
            pulumi.log.warn("start is deprecated: This parameter has been deprecated")
        if start is not None:
            pulumi.set(__self__, "start", start)
        if summary_type is not None:
            pulumi.set(__self__, "summary_type", summary_type)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="colorPreference")
    def color_preference(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to colorize text or background. One of "text", "background".
        """
        return pulumi.get(self, "color_preference")

    @color_preference.setter
    def color_preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color_preference", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter(name="displayFormat")
    def display_format(self) -> Optional[pulumi.Input[str]]:
        """
        The display setting to use. One of "counts", "list", or "countsAndList".
        """
        return pulumi.get(self, "display_format")

    @display_format.setter
    def display_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_format", value)

    @property
    @pulumi.getter(name="hideZeroCounts")
    def hide_zero_counts(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether to hide empty categories.
        """
        return pulumi.get(self, "hide_zero_counts")

    @hide_zero_counts.setter
    def hide_zero_counts(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_zero_counts", value)

    @property
    @pulumi.getter(name="showLastTriggered")
    def show_last_triggered(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether to show when monitors/groups last triggered.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `note_definition`: The definition for a Note widget. Exactly one nested block is allowed with the following structure:
        """
        return pulumi.get(self, "show_last_triggered")

    @show_last_triggered.setter
    def show_last_triggered(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_last_triggered", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input[str]]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "start", value)

    @property
    @pulumi.getter(name="summaryType")
    def summary_type(self) -> Optional[pulumi.Input[str]]:
        """
        The monitor summary type to use. One of "monitors", "groups", or "combined". Defaults to "monitors".
        """
        return pulumi.get(self, "summary_type")

    @summary_type.setter
    def summary_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "summary_type", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetNoteDefinitionArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 background_color: Optional[pulumi.Input[str]] = None,
                 font_size: Optional[pulumi.Input[str]] = None,
                 show_tick: Optional[pulumi.Input[bool]] = None,
                 text_align: Optional[pulumi.Input[str]] = None,
                 tick_edge: Optional[pulumi.Input[str]] = None,
                 tick_pos: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] content: Content of the note.
        :param pulumi.Input[str] background_color: Background color of the note.
        :param pulumi.Input[str] font_size: The size of the text in the widget.
        :param pulumi.Input[bool] show_tick: Whether to show a tick or not.
        :param pulumi.Input[str] text_align: The alignment of the text in the widget.
               - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
               - `q`: (Optional) The metric query to use in the widget
               - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
               - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
               - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] tick_edge: When tick = true, string indicating on which side of the widget the tick should be displayed. One of "bottom", "top", "left", "right".
               - `query_value_definition`: The definition for a Query Value widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
               - `q`: (Optional) The metric query to use in the widget.
               - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
               - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
               - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] tick_pos: When tick = true, string with a percent sign indicating the position of the tick. Example: use tick_pos = "50%" for centered alignment.
        """
        pulumi.set(__self__, "content", content)
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if font_size is not None:
            pulumi.set(__self__, "font_size", font_size)
        if show_tick is not None:
            pulumi.set(__self__, "show_tick", show_tick)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if tick_edge is not None:
            pulumi.set(__self__, "tick_edge", tick_edge)
        if tick_pos is not None:
            pulumi.set(__self__, "tick_pos", tick_pos)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        Content of the note.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[pulumi.Input[str]]:
        """
        Background color of the note.
        """
        return pulumi.get(self, "background_color")

    @background_color.setter
    def background_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "background_color", value)

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the text in the widget.
        """
        return pulumi.get(self, "font_size")

    @font_size.setter
    def font_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "font_size", value)

    @property
    @pulumi.getter(name="showTick")
    def show_tick(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to show a tick or not.
        """
        return pulumi.get(self, "show_tick")

    @show_tick.setter
    def show_tick(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_tick", value)

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the text in the widget.
        - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
        - `q`: (Optional) The metric query to use in the widget
        - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
        - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
        - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "text_align")

    @text_align.setter
    def text_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_align", value)

    @property
    @pulumi.getter(name="tickEdge")
    def tick_edge(self) -> Optional[pulumi.Input[str]]:
        """
        When tick = true, string indicating on which side of the widget the tick should be displayed. One of "bottom", "top", "left", "right".
        - `query_value_definition`: The definition for a Query Value widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
        - `q`: (Optional) The metric query to use in the widget.
        - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
        - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
        - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "tick_edge")

    @tick_edge.setter
    def tick_edge(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tick_edge", value)

    @property
    @pulumi.getter(name="tickPos")
    def tick_pos(self) -> Optional[pulumi.Input[str]]:
        """
        When tick = true, string with a percent sign indicating the position of the tick. Example: use tick_pos = "50%" for centered alignment.
        """
        return pulumi.get(self, "tick_pos")

    @tick_pos.setter
    def tick_pos(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tick_pos", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionArgs:
    def __init__(__self__, *,
                 requests: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestArgs']]]] = None,
                 time: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionTimeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestArgs']]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionTimeArgs']]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionTimeArgs']]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestArgs:
    def __init__(__self__, *,
                 aggregator: Optional[pulumi.Input[str]] = None,
                 alias: Optional[pulumi.Input[str]] = None,
                 apm_query: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestApmQueryArgs']] = None,
                 conditional_formats: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestConditionalFormatArgs']]]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestLogQueryArgs']] = None,
                 order: Optional[pulumi.Input[str]] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregator: The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
               - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        :param pulumi.Input[str] alias: The alias for the column name. Default is the metric name.
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple request blocks are allowed. The structure of this block is described below.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `trace_service_definition`: The definition for a Trace Service widget. Exactly one nested block is allowed with the following structure:
               - `env`: (Required) APM environment.
               - `service`: (Required) APM service.
               - `span_name`: (Required) APM span name.
               - `show_hits`: (Optional) APM span name.
               - `show_hits`: (Optional) Whether to show the hits metrics or not.
               - `show_errors`: (Optional) Whether to show the error metrics or not.
               - `show_latency`: (Optional) Whether to show the latency metrics or not.
               - `show_breakdown`: (Optional) Whether to show the latency breakdown or not.
               - `show_distribution`: (Optional) Whether to show the latency distribution or not.
               - `show_resource_list`: (Optional) Whether to show the resource list or not.
               - `size_format`: (Optional) Size of the widget. Available values are: `small`, `medium`, or `large`.
               - `display_format`: (Optional) Number of columns to display. Available values are: `one_column`, `two_column`, or `three_column`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
        - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        The alias for the column name. Default is the metric name.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestApmQueryArgs']]:
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple request blocks are allowed. The structure of this block is described below.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `trace_service_definition`: The definition for a Trace Service widget. Exactly one nested block is allowed with the following structure:
        - `env`: (Required) APM environment.
        - `service`: (Required) APM service.
        - `span_name`: (Required) APM span name.
        - `show_hits`: (Optional) APM span name.
        - `show_hits`: (Optional) Whether to show the hits metrics or not.
        - `show_errors`: (Optional) Whether to show the error metrics or not.
        - `show_latency`: (Optional) Whether to show the latency metrics or not.
        - `show_breakdown`: (Optional) Whether to show the latency breakdown or not.
        - `show_distribution`: (Optional) Whether to show the latency distribution or not.
        - `show_resource_list`: (Optional) Whether to show the resource list or not.
        - `size_format`: (Optional) Size of the widget. Available values are: `small`, `medium`, or `large`.
        - `display_format`: (Optional) Number of columns to display. Available values are: `one_column`, `two_column`, or `three_column`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestLogQueryArgs']]:
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestProcessQueryArgs']]:
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestApmQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetQueryTableDefinitionRequestApmQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestApmQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestApmQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetQueryTableDefinitionRequestApmQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestApmQueryGroupByArgs']]] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param pulumi.Input['DashboardWidgetQueryTableDefinitionRequestApmQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetQueryTableDefinitionRequestApmQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetQueryTableDefinitionRequestApmQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestApmQueryGroupByArgs']]]]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestApmQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestApmQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestApmQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestApmQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: Comparator to apply from: One of `>`, `>=`, `<`, or `<=`.
        :param pulumi.Input[str] palette: Color palette to apply; One of `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `green`, `green_on_white`, `grey`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `white_on_red`, `white_on_yellow`, or `yellow_on_white`.
        :param pulumi.Input[float] value: Value for the comparator.
        :param pulumi.Input[str] custom_bg_color: Color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: Color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[str] image_url: Displays an image as the background.
               .
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        Comparator to apply from: One of `>`, `>=`, `<`, or `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        Color palette to apply; One of `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `green`, `green_on_white`, `grey`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `white_on_red`, `white_on_yellow`, or `yellow_on_white`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        Value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        Color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        Color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        .
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestLogQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetQueryTableDefinitionRequestLogQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestLogQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestLogQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetQueryTableDefinitionRequestLogQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestLogQueryGroupByArgs']]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input['DashboardWidgetQueryTableDefinitionRequestLogQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetQueryTableDefinitionRequestLogQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetQueryTableDefinitionRequestLogQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestLogQueryGroupByArgs']]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestLogQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestLogQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestLogQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestLogQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionTimeArgs:
    def __init__(__self__, *,
                 live_span: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionArgs:
    def __init__(__self__, *,
                 autoscale: Optional[pulumi.Input[bool]] = None,
                 custom_unit: Optional[pulumi.Input[str]] = None,
                 precision: Optional[pulumi.Input[float]] = None,
                 requests: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestArgs']]]] = None,
                 text_align: Optional[pulumi.Input[str]] = None,
                 time: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionTimeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] autoscale: Boolean indicating whether to automatically scale the tile.
        :param pulumi.Input[str] custom_unit: The unit for the value displayed in the widget.
        :param pulumi.Input[float] precision: The precision to use when displaying the tile.
        :param pulumi.Input[str] text_align: The alignment of the text in the widget.
               - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
               - `q`: (Optional) The metric query to use in the widget
               - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
               - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
               - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if custom_unit is not None:
            pulumi.set(__self__, "custom_unit", custom_unit)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether to automatically scale the tile.
        """
        return pulumi.get(self, "autoscale")

    @autoscale.setter
    def autoscale(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "autoscale", value)

    @property
    @pulumi.getter(name="customUnit")
    def custom_unit(self) -> Optional[pulumi.Input[str]]:
        """
        The unit for the value displayed in the widget.
        """
        return pulumi.get(self, "custom_unit")

    @custom_unit.setter
    def custom_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_unit", value)

    @property
    @pulumi.getter
    def precision(self) -> Optional[pulumi.Input[float]]:
        """
        The precision to use when displaying the tile.
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "precision", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestArgs']]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the text in the widget.
        - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
        - `q`: (Optional) The metric query to use in the widget
        - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
        - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
        - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "text_align")

    @text_align.setter
    def text_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_align", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionTimeArgs']]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionTimeArgs']]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestArgs:
    def __init__(__self__, *,
                 aggregator: Optional[pulumi.Input[str]] = None,
                 apm_query: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestApmQueryArgs']] = None,
                 conditional_formats: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestConditionalFormatArgs']]]] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregator: The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
               - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple request blocks are allowed. The structure of this block is described below.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `trace_service_definition`: The definition for a Trace Service widget. Exactly one nested block is allowed with the following structure:
               - `env`: (Required) APM environment.
               - `service`: (Required) APM service.
               - `span_name`: (Required) APM span name.
               - `show_hits`: (Optional) APM span name.
               - `show_hits`: (Optional) Whether to show the hits metrics or not.
               - `show_errors`: (Optional) Whether to show the error metrics or not.
               - `show_latency`: (Optional) Whether to show the latency metrics or not.
               - `show_breakdown`: (Optional) Whether to show the latency breakdown or not.
               - `show_distribution`: (Optional) Whether to show the latency distribution or not.
               - `show_resource_list`: (Optional) Whether to show the resource list or not.
               - `size_format`: (Optional) Size of the widget. Available values are: `small`, `medium`, or `large`.
               - `display_format`: (Optional) Number of columns to display. Available values are: `one_column`, `two_column`, or `three_column`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
        - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestApmQueryArgs']]:
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple request blocks are allowed. The structure of this block is described below.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `trace_service_definition`: The definition for a Trace Service widget. Exactly one nested block is allowed with the following structure:
        - `env`: (Required) APM environment.
        - `service`: (Required) APM service.
        - `span_name`: (Required) APM span name.
        - `show_hits`: (Optional) APM span name.
        - `show_hits`: (Optional) Whether to show the hits metrics or not.
        - `show_errors`: (Optional) Whether to show the error metrics or not.
        - `show_latency`: (Optional) Whether to show the latency metrics or not.
        - `show_breakdown`: (Optional) Whether to show the latency breakdown or not.
        - `show_distribution`: (Optional) Whether to show the latency distribution or not.
        - `show_resource_list`: (Optional) Whether to show the resource list or not.
        - `size_format`: (Optional) Size of the widget. Available values are: `small`, `medium`, or `large`.
        - `display_format`: (Optional) Number of columns to display. Available values are: `one_column`, `two_column`, or `three_column`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestLogQueryArgs']]:
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestProcessQueryArgs']]:
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestApmQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetQueryValueDefinitionRequestApmQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestApmQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestApmQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetQueryValueDefinitionRequestApmQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestApmQueryGroupByArgs']]] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param pulumi.Input['DashboardWidgetQueryValueDefinitionRequestApmQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetQueryValueDefinitionRequestApmQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetQueryValueDefinitionRequestApmQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestApmQueryGroupByArgs']]]]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestApmQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestApmQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestApmQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestApmQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: Comparator to apply from: One of `>`, `>=`, `<`, or `<=`.
        :param pulumi.Input[str] palette: Color palette to apply; One of `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `green`, `green_on_white`, `grey`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `white_on_red`, `white_on_yellow`, or `yellow_on_white`.
        :param pulumi.Input[float] value: Value for the comparator.
        :param pulumi.Input[str] custom_bg_color: Color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: Color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[str] image_url: Displays an image as the background.
               .
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        Comparator to apply from: One of `>`, `>=`, `<`, or `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        Color palette to apply; One of `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `green`, `green_on_white`, `grey`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `white_on_red`, `white_on_yellow`, or `yellow_on_white`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        Value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        Color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        Color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        .
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestLogQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetQueryValueDefinitionRequestLogQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestLogQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestLogQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetQueryValueDefinitionRequestLogQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestLogQueryGroupByArgs']]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input['DashboardWidgetQueryValueDefinitionRequestLogQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetQueryValueDefinitionRequestLogQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetQueryValueDefinitionRequestLogQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestLogQueryGroupByArgs']]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestLogQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestLogQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestLogQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestLogQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionTimeArgs:
    def __init__(__self__, *,
                 live_span: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionArgs:
    def __init__(__self__, *,
                 color_by_groups: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 request: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestArgs']] = None,
                 time: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionTimeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None,
                 xaxis: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionXaxisArgs']] = None,
                 yaxis: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionYaxisArgs']] = None):
        """
        :param pulumi.Input[List[pulumi.Input[str]]] color_by_groups: List of groups used for colors.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `servicemap_definition`: The definition for a Service Map widget. Exactly one nested block is allowed with the following structure:
               - `filters`: (Required) Your environment and primary tag (or * if enabled for your account).
               - `service`: (Required) The ID of the service you want to map.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `service_level_objective_definition`: The definition for a Service Level Objective widget. Exactly one nested block is allowed with the following structure:
               - `view_type`: (Required) Type of view to use when displaying the widget. Only "detail" is currently supported.
               - `slo_id`: (Required) The ID of the service level objective used by the widget.
               - `show_error_budget`: (Optional) Whether to show the error budget or not.
               - `view_mode`: (Required) View mode for the widget. One of "overall", "component", or "both".
               - `time_windows`: (Required) List of time windows to display in the widget. Each value in the list must be one of "7d", "30d", "90d", "week_to_date",  "previous_week", "month_to_date", or "previous_month".
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `timeseries_definition`: The definition for a Timeseries  widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
               - `q`: (Optional) The metric query to use in the widget.
               - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
               - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
               - `network_query`: (Optional) The network query to use in the widget. The structure of this block is described below.
               - `rum_query`: (Optional) The rum query to use in the widget. The structure of this block is described below.
               - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        if color_by_groups is not None:
            pulumi.set(__self__, "color_by_groups", color_by_groups)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if xaxis is not None:
            pulumi.set(__self__, "xaxis", xaxis)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter(name="colorByGroups")
    def color_by_groups(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        List of groups used for colors.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `servicemap_definition`: The definition for a Service Map widget. Exactly one nested block is allowed with the following structure:
        - `filters`: (Required) Your environment and primary tag (or * if enabled for your account).
        - `service`: (Required) The ID of the service you want to map.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `service_level_objective_definition`: The definition for a Service Level Objective widget. Exactly one nested block is allowed with the following structure:
        - `view_type`: (Required) Type of view to use when displaying the widget. Only "detail" is currently supported.
        - `slo_id`: (Required) The ID of the service level objective used by the widget.
        - `show_error_budget`: (Optional) Whether to show the error budget or not.
        - `view_mode`: (Required) View mode for the widget. One of "overall", "component", or "both".
        - `time_windows`: (Required) List of time windows to display in the widget. Each value in the list must be one of "7d", "30d", "90d", "week_to_date",  "previous_week", "month_to_date", or "previous_month".
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `timeseries_definition`: The definition for a Timeseries  widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
        - `q`: (Optional) The metric query to use in the widget.
        - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
        - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
        - `network_query`: (Optional) The network query to use in the widget. The structure of this block is described below.
        - `rum_query`: (Optional) The rum query to use in the widget. The structure of this block is described below.
        - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "color_by_groups")

    @color_by_groups.setter
    def color_by_groups(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "color_by_groups", value)

    @property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestArgs']]:
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestArgs']]):
        pulumi.set(self, "request", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionTimeArgs']]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionTimeArgs']]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)

    @property
    @pulumi.getter
    def xaxis(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionXaxisArgs']]:
        return pulumi.get(self, "xaxis")

    @xaxis.setter
    def xaxis(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionXaxisArgs']]):
        pulumi.set(self, "xaxis", value)

    @property
    @pulumi.getter
    def yaxis(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionYaxisArgs']]:
        return pulumi.get(self, "yaxis")

    @yaxis.setter
    def yaxis(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionYaxisArgs']]):
        pulumi.set(self, "yaxis", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestArgs:
    def __init__(__self__, *,
                 xes: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXArgs']]]] = None,
                 ys: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYArgs']]]] = None):
        """
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXArgs']]] xes: The position of the widget on the x (horizontal) axis. Should be greater or equal to 0.
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYArgs']]] ys: The position of the widget on the y (vertical) axis. Should be greater or equal to 0.
        """
        if xes is not None:
            pulumi.set(__self__, "xes", xes)
        if ys is not None:
            pulumi.set(__self__, "ys", ys)

    @property
    @pulumi.getter
    def xes(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXArgs']]]]:
        """
        The position of the widget on the x (horizontal) axis. Should be greater or equal to 0.
        """
        return pulumi.get(self, "xes")

    @xes.setter
    def xes(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXArgs']]]]):
        pulumi.set(self, "xes", value)

    @property
    @pulumi.getter
    def ys(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYArgs']]]]:
        """
        The position of the widget on the y (vertical) axis. Should be greater or equal to 0.
        """
        return pulumi.get(self, "ys")

    @ys.setter
    def ys(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYArgs']]]]):
        pulumi.set(self, "ys", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestXArgs:
    def __init__(__self__, *,
                 aggregator: Optional[pulumi.Input[str]] = None,
                 apm_query: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXApmQueryArgs']] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregator: The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
               - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
        - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXApmQueryArgs']]:
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXLogQueryArgs']]:
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXProcessQueryArgs']]:
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestXApmQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXApmQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXApmQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXApmQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupByArgs']]] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXApmQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXApmQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXApmQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupByArgs']]]]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXApmQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXApmQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestXApmQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestXApmQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestXLogQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXLogQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXLogQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXLogQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupByArgs']]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXLogQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXLogQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXLogQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupByArgs']]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXLogQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXLogQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestXLogQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestXLogQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestXProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestYArgs:
    def __init__(__self__, *,
                 aggregator: Optional[pulumi.Input[str]] = None,
                 apm_query: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYApmQueryArgs']] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregator: The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
               - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
        - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYApmQueryArgs']]:
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYLogQueryArgs']]:
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYProcessQueryArgs']]:
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestYApmQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYApmQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYApmQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYApmQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupByArgs']]] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYApmQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYApmQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYApmQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupByArgs']]]]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYApmQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYApmQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestYApmQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestYApmQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestYLogQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYLogQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYLogQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYLogQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupByArgs']]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYLogQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYLogQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYLogQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupByArgs']]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYLogQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYLogQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestYLogQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestYLogQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestYProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionTimeArgs:
    def __init__(__self__, *,
                 live_span: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionXaxisArgs:
    def __init__(__self__, *,
                 include_zero: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 max: Optional[pulumi.Input[str]] = None,
                 min: Optional[pulumi.Input[str]] = None,
                 scale: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] include_zero: Always include zero or fit the axis to the data range.
        :param pulumi.Input[str] label: The label of the axis to display on the graph.
        :param pulumi.Input[str] max: Specify the minimum value to show on y-axis.
        :param pulumi.Input[str] min: Specify the minimum value to show on y-axis.
        :param pulumi.Input[str] scale: Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[pulumi.Input[bool]]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @include_zero.setter
    def include_zero(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_zero", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionYaxisArgs:
    def __init__(__self__, *,
                 include_zero: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 max: Optional[pulumi.Input[str]] = None,
                 min: Optional[pulumi.Input[str]] = None,
                 scale: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] include_zero: Always include zero or fit the axis to the data range.
        :param pulumi.Input[str] label: The label of the axis to display on the graph.
        :param pulumi.Input[str] max: Specify the minimum value to show on y-axis.
        :param pulumi.Input[str] min: Specify the minimum value to show on y-axis.
        :param pulumi.Input[str] scale: Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[pulumi.Input[bool]]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @include_zero.setter
    def include_zero(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_zero", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale", value)


@pulumi.input_type
class DashboardWidgetServiceLevelObjectiveDefinitionArgs:
    def __init__(__self__, *,
                 slo_id: pulumi.Input[str],
                 time_windows: pulumi.Input[List[pulumi.Input[str]]],
                 view_mode: pulumi.Input[str],
                 view_type: pulumi.Input[str],
                 show_error_budget: Optional[pulumi.Input[bool]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        pulumi.set(__self__, "slo_id", slo_id)
        pulumi.set(__self__, "time_windows", time_windows)
        pulumi.set(__self__, "view_mode", view_mode)
        pulumi.set(__self__, "view_type", view_type)
        if show_error_budget is not None:
            pulumi.set(__self__, "show_error_budget", show_error_budget)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "slo_id")

    @slo_id.setter
    def slo_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "slo_id", value)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> pulumi.Input[List[pulumi.Input[str]]]:
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: pulumi.Input[List[pulumi.Input[str]]]):
        pulumi.set(self, "time_windows", value)

    @property
    @pulumi.getter(name="viewMode")
    def view_mode(self) -> pulumi.Input[str]:
        return pulumi.get(self, "view_mode")

    @view_mode.setter
    def view_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "view_mode", value)

    @property
    @pulumi.getter(name="viewType")
    def view_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "view_type")

    @view_type.setter
    def view_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "view_type", value)

    @property
    @pulumi.getter(name="showErrorBudget")
    def show_error_budget(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "show_error_budget")

    @show_error_budget.setter
    def show_error_budget(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_error_budget", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetServicemapDefinitionArgs:
    def __init__(__self__, *,
                 filters: pulumi.Input[List[pulumi.Input[str]]],
                 service: pulumi.Input[str],
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "service", service)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def filters(self) -> pulumi.Input[List[pulumi.Input[str]]]:
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: pulumi.Input[List[pulumi.Input[str]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionArgs:
    def __init__(__self__, *,
                 events: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionEventArgs']]]] = None,
                 legend_size: Optional[pulumi.Input[str]] = None,
                 markers: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionMarkerArgs']]]] = None,
                 requests: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestArgs']]]] = None,
                 show_legend: Optional[pulumi.Input[bool]] = None,
                 time: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionTimeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None,
                 yaxis: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionYaxisArgs']] = None):
        """
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionMarkerArgs']]] markers: Nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple marker blocks are allowed within a given tile_def block.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
               - `q`: (Required) The event query to use in the widget.
               - `tags_execution`: (Optional) The execution method for multi-value filters.
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
               - `toplist_definition`: The definition for a Toplist  widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
               - `q`: (Optional) The metric query to use in the widget.
               - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
               - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
               - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        if events is not None:
            pulumi.set(__self__, "events", events)
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if markers is not None:
            pulumi.set(__self__, "markers", markers)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter
    def events(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionEventArgs']]]]:
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionEventArgs']]]]):
        pulumi.set(self, "events", value)

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "legend_size")

    @legend_size.setter
    def legend_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "legend_size", value)

    @property
    @pulumi.getter
    def markers(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionMarkerArgs']]]]:
        """
        Nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple marker blocks are allowed within a given tile_def block.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
        - `q`: (Required) The event query to use in the widget.
        - `tags_execution`: (Optional) The execution method for multi-value filters.
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        - `toplist_definition`: The definition for a Toplist  widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
        - `q`: (Optional) The metric query to use in the widget.
        - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
        - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
        - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "markers")

    @markers.setter
    def markers(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionMarkerArgs']]]]):
        pulumi.set(self, "markers", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestArgs']]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "show_legend")

    @show_legend.setter
    def show_legend(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_legend", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionTimeArgs']]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionTimeArgs']]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)

    @property
    @pulumi.getter
    def yaxis(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionYaxisArgs']]:
        return pulumi.get(self, "yaxis")

    @yaxis.setter
    def yaxis(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionYaxisArgs']]):
        pulumi.set(self, "yaxis", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionEventArgs:
    def __init__(__self__, *,
                 q: pulumi.Input[str],
                 tags_execution: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "q", q)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)

    @property
    @pulumi.getter
    def q(self) -> pulumi.Input[str]:
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: pulumi.Input[str]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tags_execution")

    @tags_execution.setter
    def tags_execution(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tags_execution", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionMarkerArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 display_type: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Value for the comparator.
        :param pulumi.Input[str] display_type: Type of display to use for the request. Available values are: `area`, `bars`, or `line`.
        :param pulumi.Input[str] label: The label of the axis to display on the graph.
        """
        pulumi.set(__self__, "value", value)
        if display_type is not None:
            pulumi.set(__self__, "display_type", display_type)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="displayType")
    def display_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of display to use for the request. Available values are: `area`, `bars`, or `line`.
        """
        return pulumi.get(self, "display_type")

    @display_type.setter
    def display_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_type", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestApmQueryArgs']] = None,
                 display_type: Optional[pulumi.Input[str]] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestLogQueryArgs']] = None,
                 metadatas: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestMetadataArgs']]]] = None,
                 network_query: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 rum_query: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestRumQueryArgs']] = None,
                 style: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestStyleArgs']] = None):
        """
        :param pulumi.Input[str] display_type: Type of display to use for the request. Available values are: `area`, `bars`, or `line`.
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestMetadataArgs']]] metadatas: . Used to define expression aliases. Multiple nested blocks are allowed with the following structure:
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestStyleArgs'] style: Style of the widget graph. One nested block is allowed with the following structure:
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if display_type is not None:
            pulumi.set(__self__, "display_type", display_type)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if network_query is not None:
            pulumi.set(__self__, "network_query", network_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestApmQueryArgs']]:
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="displayType")
    def display_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of display to use for the request. Available values are: `area`, `bars`, or `line`.
        """
        return pulumi.get(self, "display_type")

    @display_type.setter
    def display_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_type", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestLogQueryArgs']]:
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestMetadataArgs']]]]:
        """
        . Used to define expression aliases. Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "metadatas")

    @metadatas.setter
    def metadatas(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestMetadataArgs']]]]):
        pulumi.set(self, "metadatas", value)

    @property
    @pulumi.getter(name="networkQuery")
    def network_query(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryArgs']]:
        return pulumi.get(self, "network_query")

    @network_query.setter
    def network_query(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryArgs']]):
        pulumi.set(self, "network_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestProcessQueryArgs']]:
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestRumQueryArgs']]:
        return pulumi.get(self, "rum_query")

    @rum_query.setter
    def rum_query(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestRumQueryArgs']]):
        pulumi.set(self, "rum_query", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestStyleArgs']]:
        """
        Style of the widget graph. One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestApmQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestApmQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestApmQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestApmQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupByArgs']]] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestApmQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestApmQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestApmQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupByArgs']]]]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestApmQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestApmQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestApmQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestApmQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestLogQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestLogQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestLogQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestLogQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupByArgs']]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestLogQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestLogQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestLogQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupByArgs']]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestLogQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestLogQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestLogQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestLogQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestMetadataArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 alias_name: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        if alias_name is not None:
            pulumi.set(__self__, "alias_name", alias_name)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter(name="aliasName")
    def alias_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "alias_name")

    @alias_name.setter
    def alias_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias_name", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs']]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs']]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestRumQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestRumQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestRumQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestRumQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupByArgs']]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestRumQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestRumQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestRumQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupByArgs']]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestRumQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestRumQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestRumQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestRumQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestStyleArgs:
    def __init__(__self__, *,
                 line_type: Optional[pulumi.Input[str]] = None,
                 line_width: Optional[pulumi.Input[str]] = None,
                 palette: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] line_type: Type of lines displayed. Available values are: `dashed`, `dotted`, or `solid`.
        :param pulumi.Input[str] line_width: Width of line displayed. Available values are: `normal`, `thick`, or `thin`.
        :param pulumi.Input[str] palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
               - `q`: (Required) The event query to use in the widget.
               - `tags_execution`: (Optional) The execution method for multi-value filters.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        if line_type is not None:
            pulumi.set(__self__, "line_type", line_type)
        if line_width is not None:
            pulumi.set(__self__, "line_width", line_width)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter(name="lineType")
    def line_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of lines displayed. Available values are: `dashed`, `dotted`, or `solid`.
        """
        return pulumi.get(self, "line_type")

    @line_type.setter
    def line_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "line_type", value)

    @property
    @pulumi.getter(name="lineWidth")
    def line_width(self) -> Optional[pulumi.Input[str]]:
        """
        Width of line displayed. Available values are: `normal`, `thick`, or `thin`.
        """
        return pulumi.get(self, "line_width")

    @line_width.setter
    def line_width(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "line_width", value)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
        - `q`: (Required) The event query to use in the widget.
        - `tags_execution`: (Optional) The execution method for multi-value filters.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionTimeArgs:
    def __init__(__self__, *,
                 live_span: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionYaxisArgs:
    def __init__(__self__, *,
                 include_zero: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 max: Optional[pulumi.Input[str]] = None,
                 min: Optional[pulumi.Input[str]] = None,
                 scale: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] include_zero: Always include zero or fit the axis to the data range.
        :param pulumi.Input[str] label: The label of the axis to display on the graph.
        :param pulumi.Input[str] max: Specify the minimum value to show on y-axis.
        :param pulumi.Input[str] min: Specify the minimum value to show on y-axis.
        :param pulumi.Input[str] scale: Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[pulumi.Input[bool]]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @include_zero.setter
    def include_zero(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_zero", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionArgs:
    def __init__(__self__, *,
                 requests: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetToplistDefinitionRequestArgs']]]] = None,
                 time: Optional[pulumi.Input['DashboardWidgetToplistDefinitionTimeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetToplistDefinitionRequestArgs']]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetToplistDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionTimeArgs']]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionTimeArgs']]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestApmQueryArgs']] = None,
                 conditional_formats: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetToplistDefinitionRequestConditionalFormatArgs']]]] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 style: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestStyleArgs']] = None):
        """
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetToplistDefinitionRequestConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple request blocks are allowed. The structure of this block is described below.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `trace_service_definition`: The definition for a Trace Service widget. Exactly one nested block is allowed with the following structure:
               - `env`: (Required) APM environment.
               - `service`: (Required) APM service.
               - `span_name`: (Required) APM span name.
               - `show_hits`: (Optional) APM span name.
               - `show_hits`: (Optional) Whether to show the hits metrics or not.
               - `show_errors`: (Optional) Whether to show the error metrics or not.
               - `show_latency`: (Optional) Whether to show the latency metrics or not.
               - `show_breakdown`: (Optional) Whether to show the latency breakdown or not.
               - `show_distribution`: (Optional) Whether to show the latency distribution or not.
               - `show_resource_list`: (Optional) Whether to show the resource list or not.
               - `size_format`: (Optional) Size of the widget. Available values are: `small`, `medium`, or `large`.
               - `display_format`: (Optional) Number of columns to display. Available values are: `one_column`, `two_column`, or `three_column`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        :param pulumi.Input['DashboardWidgetToplistDefinitionRequestStyleArgs'] style: Style of the widget graph. One nested block is allowed with the following structure:
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestApmQueryArgs']]:
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetToplistDefinitionRequestConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple request blocks are allowed. The structure of this block is described below.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `trace_service_definition`: The definition for a Trace Service widget. Exactly one nested block is allowed with the following structure:
        - `env`: (Required) APM environment.
        - `service`: (Required) APM service.
        - `span_name`: (Required) APM span name.
        - `show_hits`: (Optional) APM span name.
        - `show_hits`: (Optional) Whether to show the hits metrics or not.
        - `show_errors`: (Optional) Whether to show the error metrics or not.
        - `show_latency`: (Optional) Whether to show the latency metrics or not.
        - `show_breakdown`: (Optional) Whether to show the latency breakdown or not.
        - `show_distribution`: (Optional) Whether to show the latency distribution or not.
        - `show_resource_list`: (Optional) Whether to show the resource list or not.
        - `size_format`: (Optional) Size of the widget. Available values are: `small`, `medium`, or `large`.
        - `display_format`: (Optional) Number of columns to display. Available values are: `one_column`, `two_column`, or `three_column`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetToplistDefinitionRequestConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestLogQueryArgs']]:
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestProcessQueryArgs']]:
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestStyleArgs']]:
        """
        Style of the widget graph. One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestApmQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetToplistDefinitionRequestApmQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetToplistDefinitionRequestApmQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestApmQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetToplistDefinitionRequestApmQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetToplistDefinitionRequestApmQueryGroupByArgs']]] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param pulumi.Input['DashboardWidgetToplistDefinitionRequestApmQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetToplistDefinitionRequestApmQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetToplistDefinitionRequestApmQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetToplistDefinitionRequestApmQueryGroupByArgs']]]]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetToplistDefinitionRequestApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestApmQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestApmQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestApmQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestApmQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetToplistDefinitionRequestApmQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestApmQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestApmQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestApmQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestApmQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: Comparator to apply from: One of `>`, `>=`, `<`, or `<=`.
        :param pulumi.Input[str] palette: Color palette to apply; One of `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `green`, `green_on_white`, `grey`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `white_on_red`, `white_on_yellow`, or `yellow_on_white`.
        :param pulumi.Input[float] value: Value for the comparator.
        :param pulumi.Input[str] custom_bg_color: Color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: Color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[str] image_url: Displays an image as the background.
               .
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        Comparator to apply from: One of `>`, `>=`, `<`, or `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        Color palette to apply; One of `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `green`, `green_on_white`, `grey`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `white_on_red`, `white_on_yellow`, or `yellow_on_white`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        Value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        Color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        Color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        .
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestLogQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['DashboardWidgetToplistDefinitionRequestLogQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetToplistDefinitionRequestLogQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestLogQuerySearchArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetToplistDefinitionRequestLogQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['DashboardWidgetToplistDefinitionRequestLogQueryGroupByArgs']]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input['DashboardWidgetToplistDefinitionRequestLogQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['DashboardWidgetToplistDefinitionRequestLogQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['DashboardWidgetToplistDefinitionRequestLogQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetToplistDefinitionRequestLogQueryGroupByArgs']]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['DashboardWidgetToplistDefinitionRequestLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestLogQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestLogQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestLogQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestLogQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetToplistDefinitionRequestLogQueryGroupBySortArgs'] sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestLogQueryGroupBySortArgs']]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestLogQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestLogQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestLogQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
               - `q`: (Required) The event query to use in the widget.
               - `tags_execution`: (Optional) The execution method for multi-value filters.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
        - `q`: (Required) The event query to use in the widget.
        - `tags_execution`: (Optional) The execution method for multi-value filters.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionTimeArgs:
    def __init__(__self__, *,
                 live_span: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)


@pulumi.input_type
class DashboardWidgetTraceServiceDefinitionArgs:
    def __init__(__self__, *,
                 env: pulumi.Input[str],
                 service: pulumi.Input[str],
                 span_name: pulumi.Input[str],
                 display_format: Optional[pulumi.Input[str]] = None,
                 show_breakdown: Optional[pulumi.Input[bool]] = None,
                 show_distribution: Optional[pulumi.Input[bool]] = None,
                 show_errors: Optional[pulumi.Input[bool]] = None,
                 show_hits: Optional[pulumi.Input[bool]] = None,
                 show_latency: Optional[pulumi.Input[bool]] = None,
                 show_resource_list: Optional[pulumi.Input[bool]] = None,
                 size_format: Optional[pulumi.Input[str]] = None,
                 time: Optional[pulumi.Input['DashboardWidgetTraceServiceDefinitionTimeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] display_format: The display setting to use. One of "counts", "list", or "countsAndList".
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "span_name", span_name)
        if display_format is not None:
            pulumi.set(__self__, "display_format", display_format)
        if show_breakdown is not None:
            pulumi.set(__self__, "show_breakdown", show_breakdown)
        if show_distribution is not None:
            pulumi.set(__self__, "show_distribution", show_distribution)
        if show_errors is not None:
            pulumi.set(__self__, "show_errors", show_errors)
        if show_hits is not None:
            pulumi.set(__self__, "show_hits", show_hits)
        if show_latency is not None:
            pulumi.set(__self__, "show_latency", show_latency)
        if show_resource_list is not None:
            pulumi.set(__self__, "show_resource_list", show_resource_list)
        if size_format is not None:
            pulumi.set(__self__, "size_format", size_format)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter(name="spanName")
    def span_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "span_name")

    @span_name.setter
    def span_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "span_name", value)

    @property
    @pulumi.getter(name="displayFormat")
    def display_format(self) -> Optional[pulumi.Input[str]]:
        """
        The display setting to use. One of "counts", "list", or "countsAndList".
        """
        return pulumi.get(self, "display_format")

    @display_format.setter
    def display_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_format", value)

    @property
    @pulumi.getter(name="showBreakdown")
    def show_breakdown(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "show_breakdown")

    @show_breakdown.setter
    def show_breakdown(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_breakdown", value)

    @property
    @pulumi.getter(name="showDistribution")
    def show_distribution(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "show_distribution")

    @show_distribution.setter
    def show_distribution(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_distribution", value)

    @property
    @pulumi.getter(name="showErrors")
    def show_errors(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "show_errors")

    @show_errors.setter
    def show_errors(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_errors", value)

    @property
    @pulumi.getter(name="showHits")
    def show_hits(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "show_hits")

    @show_hits.setter
    def show_hits(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_hits", value)

    @property
    @pulumi.getter(name="showLatency")
    def show_latency(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "show_latency")

    @show_latency.setter
    def show_latency(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_latency", value)

    @property
    @pulumi.getter(name="showResourceList")
    def show_resource_list(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "show_resource_list")

    @show_resource_list.setter
    def show_resource_list(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_resource_list", value)

    @property
    @pulumi.getter(name="sizeFormat")
    def size_format(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "size_format")

    @size_format.setter
    def size_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size_format", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input['DashboardWidgetTraceServiceDefinitionTimeArgs']]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input['DashboardWidgetTraceServiceDefinitionTimeArgs']]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetTraceServiceDefinitionTimeArgs:
    def __init__(__self__, *,
                 live_span: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)


@pulumi.input_type
class DowntimeRecurrenceArgs:
    def __init__(__self__, *,
                 period: pulumi.Input[float],
                 type: pulumi.Input[str],
                 until_date: Optional[pulumi.Input[float]] = None,
                 until_occurrences: Optional[pulumi.Input[float]] = None,
                 week_days: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[float] period: How often to repeat as an integer. For example to repeat every 3 days, select a type of days and a period of 3.
        :param pulumi.Input[str] type: days, weeks, months, or years
        :param pulumi.Input[float] until_date: The date at which the recurrence should end as a POSIX timestamp. `until_occurrences` and `until_date` are mutually exclusive.
        :param pulumi.Input[float] until_occurrences: How many times the downtime will be rescheduled. `until_occurrences` and `until_date` are mutually exclusive.
        :param pulumi.Input[List[pulumi.Input[str]]] week_days: A list of week days to repeat on. Choose from: Mon, Tue, Wed, Thu, Fri, Sat or Sun. Only applicable when type is weeks. First letter must be capitalized.
        """
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "type", type)
        if until_date is not None:
            pulumi.set(__self__, "until_date", until_date)
        if until_occurrences is not None:
            pulumi.set(__self__, "until_occurrences", until_occurrences)
        if week_days is not None:
            pulumi.set(__self__, "week_days", week_days)

    @property
    @pulumi.getter
    def period(self) -> pulumi.Input[float]:
        """
        How often to repeat as an integer. For example to repeat every 3 days, select a type of days and a period of 3.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[float]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        days, weeks, months, or years
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="untilDate")
    def until_date(self) -> Optional[pulumi.Input[float]]:
        """
        The date at which the recurrence should end as a POSIX timestamp. `until_occurrences` and `until_date` are mutually exclusive.
        """
        return pulumi.get(self, "until_date")

    @until_date.setter
    def until_date(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "until_date", value)

    @property
    @pulumi.getter(name="untilOccurrences")
    def until_occurrences(self) -> Optional[pulumi.Input[float]]:
        """
        How many times the downtime will be rescheduled. `until_occurrences` and `until_date` are mutually exclusive.
        """
        return pulumi.get(self, "until_occurrences")

    @until_occurrences.setter
    def until_occurrences(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "until_occurrences", value)

    @property
    @pulumi.getter(name="weekDays")
    def week_days(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        A list of week days to repeat on. Choose from: Mon, Tue, Wed, Thu, Fri, Sat or Sun. Only applicable when type is weeks. First letter must be capitalized.
        """
        return pulumi.get(self, "week_days")

    @week_days.setter
    def week_days(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "week_days", value)


@pulumi.input_type
class LogsArchiveAzureArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 container: pulumi.Input[str],
                 storage_account: pulumi.Input[str],
                 tenant_id: pulumi.Input[str],
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: Your client id.
        :param pulumi.Input[str] container: The container where the archive will be stored.
        :param pulumi.Input[str] storage_account: The associated storage account.
        :param pulumi.Input[str] tenant_id: Your tenant id.
        :param pulumi.Input[str] path: The path where the archive will be stored.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "container", container)
        pulumi.set(__self__, "storage_account", storage_account)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        Your client id.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter
    def container(self) -> pulumi.Input[str]:
        """
        The container where the archive will be stored.
        """
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: pulumi.Input[str]):
        pulumi.set(self, "container", value)

    @property
    @pulumi.getter(name="storageAccount")
    def storage_account(self) -> pulumi.Input[str]:
        """
        The associated storage account.
        """
        return pulumi.get(self, "storage_account")

    @storage_account.setter
    def storage_account(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[str]:
        """
        Your tenant id.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path where the archive will be stored.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class LogsArchiveGcsArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 client_email: pulumi.Input[str],
                 path: pulumi.Input[str],
                 project_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] bucket: Name of your gcs bucket.
        :param pulumi.Input[str] client_email: Your client email.
        :param pulumi.Input[str] path: The path where the archive will be stored.
        :param pulumi.Input[str] project_id: Your project id.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "client_email", client_email)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        Name of your gcs bucket.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> pulumi.Input[str]:
        """
        Your client email.
        """
        return pulumi.get(self, "client_email")

    @client_email.setter
    def client_email(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_email", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The path where the archive will be stored.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        Your project id.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)


@pulumi.input_type
class LogsArchiveS3Args:
    def __init__(__self__, *,
                 account_id: pulumi.Input[str],
                 bucket: pulumi.Input[str],
                 client_email: pulumi.Input[str],
                 path: pulumi.Input[str],
                 project_id: pulumi.Input[str],
                 role_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] account_id: Your AWS account id.
        :param pulumi.Input[str] bucket: Name of your gcs bucket.
        :param pulumi.Input[str] client_email: Your client email.
        :param pulumi.Input[str] path: The path where the archive will be stored.
        :param pulumi.Input[str] project_id: Your project id.
        :param pulumi.Input[str] role_name: Your AWS role name.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "client_email", client_email)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> pulumi.Input[str]:
        """
        Your AWS account id.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "account_id", value)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        Name of your gcs bucket.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> pulumi.Input[str]:
        """
        Your client email.
        """
        return pulumi.get(self, "client_email")

    @client_email.setter
    def client_email(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_email", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The path where the archive will be stored.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        Your project id.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> pulumi.Input[str]:
        """
        Your AWS role name.
        """
        return pulumi.get(self, "role_name")

    @role_name.setter
    def role_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_name", value)


@pulumi.input_type
class LogsCustomPipelineFilterArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class LogsCustomPipelineProcessorArgs:
    def __init__(__self__, *,
                 arithmetic_processor: Optional[pulumi.Input['LogsCustomPipelineProcessorArithmeticProcessorArgs']] = None,
                 attribute_remapper: Optional[pulumi.Input['LogsCustomPipelineProcessorAttributeRemapperArgs']] = None,
                 category_processor: Optional[pulumi.Input['LogsCustomPipelineProcessorCategoryProcessorArgs']] = None,
                 date_remapper: Optional[pulumi.Input['LogsCustomPipelineProcessorDateRemapperArgs']] = None,
                 geo_ip_parser: Optional[pulumi.Input['LogsCustomPipelineProcessorGeoIpParserArgs']] = None,
                 grok_parser: Optional[pulumi.Input['LogsCustomPipelineProcessorGrokParserArgs']] = None,
                 lookup_processor: Optional[pulumi.Input['LogsCustomPipelineProcessorLookupProcessorArgs']] = None,
                 message_remapper: Optional[pulumi.Input['LogsCustomPipelineProcessorMessageRemapperArgs']] = None,
                 pipeline: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineArgs']] = None,
                 service_remapper: Optional[pulumi.Input['LogsCustomPipelineProcessorServiceRemapperArgs']] = None,
                 status_remapper: Optional[pulumi.Input['LogsCustomPipelineProcessorStatusRemapperArgs']] = None,
                 string_builder_processor: Optional[pulumi.Input['LogsCustomPipelineProcessorStringBuilderProcessorArgs']] = None,
                 trace_id_remapper: Optional[pulumi.Input['LogsCustomPipelineProcessorTraceIdRemapperArgs']] = None,
                 url_parser: Optional[pulumi.Input['LogsCustomPipelineProcessorUrlParserArgs']] = None,
                 user_agent_parser: Optional[pulumi.Input['LogsCustomPipelineProcessorUserAgentParserArgs']] = None):
        if arithmetic_processor is not None:
            pulumi.set(__self__, "arithmetic_processor", arithmetic_processor)
        if attribute_remapper is not None:
            pulumi.set(__self__, "attribute_remapper", attribute_remapper)
        if category_processor is not None:
            pulumi.set(__self__, "category_processor", category_processor)
        if date_remapper is not None:
            pulumi.set(__self__, "date_remapper", date_remapper)
        if geo_ip_parser is not None:
            pulumi.set(__self__, "geo_ip_parser", geo_ip_parser)
        if grok_parser is not None:
            pulumi.set(__self__, "grok_parser", grok_parser)
        if lookup_processor is not None:
            pulumi.set(__self__, "lookup_processor", lookup_processor)
        if message_remapper is not None:
            pulumi.set(__self__, "message_remapper", message_remapper)
        if pipeline is not None:
            pulumi.set(__self__, "pipeline", pipeline)
        if service_remapper is not None:
            pulumi.set(__self__, "service_remapper", service_remapper)
        if status_remapper is not None:
            pulumi.set(__self__, "status_remapper", status_remapper)
        if string_builder_processor is not None:
            pulumi.set(__self__, "string_builder_processor", string_builder_processor)
        if trace_id_remapper is not None:
            pulumi.set(__self__, "trace_id_remapper", trace_id_remapper)
        if url_parser is not None:
            pulumi.set(__self__, "url_parser", url_parser)
        if user_agent_parser is not None:
            pulumi.set(__self__, "user_agent_parser", user_agent_parser)

    @property
    @pulumi.getter(name="arithmeticProcessor")
    def arithmetic_processor(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorArithmeticProcessorArgs']]:
        return pulumi.get(self, "arithmetic_processor")

    @arithmetic_processor.setter
    def arithmetic_processor(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorArithmeticProcessorArgs']]):
        pulumi.set(self, "arithmetic_processor", value)

    @property
    @pulumi.getter(name="attributeRemapper")
    def attribute_remapper(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorAttributeRemapperArgs']]:
        return pulumi.get(self, "attribute_remapper")

    @attribute_remapper.setter
    def attribute_remapper(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorAttributeRemapperArgs']]):
        pulumi.set(self, "attribute_remapper", value)

    @property
    @pulumi.getter(name="categoryProcessor")
    def category_processor(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorCategoryProcessorArgs']]:
        return pulumi.get(self, "category_processor")

    @category_processor.setter
    def category_processor(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorCategoryProcessorArgs']]):
        pulumi.set(self, "category_processor", value)

    @property
    @pulumi.getter(name="dateRemapper")
    def date_remapper(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorDateRemapperArgs']]:
        return pulumi.get(self, "date_remapper")

    @date_remapper.setter
    def date_remapper(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorDateRemapperArgs']]):
        pulumi.set(self, "date_remapper", value)

    @property
    @pulumi.getter(name="geoIpParser")
    def geo_ip_parser(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorGeoIpParserArgs']]:
        return pulumi.get(self, "geo_ip_parser")

    @geo_ip_parser.setter
    def geo_ip_parser(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorGeoIpParserArgs']]):
        pulumi.set(self, "geo_ip_parser", value)

    @property
    @pulumi.getter(name="grokParser")
    def grok_parser(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorGrokParserArgs']]:
        return pulumi.get(self, "grok_parser")

    @grok_parser.setter
    def grok_parser(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorGrokParserArgs']]):
        pulumi.set(self, "grok_parser", value)

    @property
    @pulumi.getter(name="lookupProcessor")
    def lookup_processor(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorLookupProcessorArgs']]:
        return pulumi.get(self, "lookup_processor")

    @lookup_processor.setter
    def lookup_processor(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorLookupProcessorArgs']]):
        pulumi.set(self, "lookup_processor", value)

    @property
    @pulumi.getter(name="messageRemapper")
    def message_remapper(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorMessageRemapperArgs']]:
        return pulumi.get(self, "message_remapper")

    @message_remapper.setter
    def message_remapper(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorMessageRemapperArgs']]):
        pulumi.set(self, "message_remapper", value)

    @property
    @pulumi.getter
    def pipeline(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineArgs']]:
        return pulumi.get(self, "pipeline")

    @pipeline.setter
    def pipeline(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineArgs']]):
        pulumi.set(self, "pipeline", value)

    @property
    @pulumi.getter(name="serviceRemapper")
    def service_remapper(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorServiceRemapperArgs']]:
        return pulumi.get(self, "service_remapper")

    @service_remapper.setter
    def service_remapper(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorServiceRemapperArgs']]):
        pulumi.set(self, "service_remapper", value)

    @property
    @pulumi.getter(name="statusRemapper")
    def status_remapper(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorStatusRemapperArgs']]:
        return pulumi.get(self, "status_remapper")

    @status_remapper.setter
    def status_remapper(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorStatusRemapperArgs']]):
        pulumi.set(self, "status_remapper", value)

    @property
    @pulumi.getter(name="stringBuilderProcessor")
    def string_builder_processor(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorStringBuilderProcessorArgs']]:
        return pulumi.get(self, "string_builder_processor")

    @string_builder_processor.setter
    def string_builder_processor(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorStringBuilderProcessorArgs']]):
        pulumi.set(self, "string_builder_processor", value)

    @property
    @pulumi.getter(name="traceIdRemapper")
    def trace_id_remapper(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorTraceIdRemapperArgs']]:
        return pulumi.get(self, "trace_id_remapper")

    @trace_id_remapper.setter
    def trace_id_remapper(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorTraceIdRemapperArgs']]):
        pulumi.set(self, "trace_id_remapper", value)

    @property
    @pulumi.getter(name="urlParser")
    def url_parser(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorUrlParserArgs']]:
        return pulumi.get(self, "url_parser")

    @url_parser.setter
    def url_parser(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorUrlParserArgs']]):
        pulumi.set(self, "url_parser", value)

    @property
    @pulumi.getter(name="userAgentParser")
    def user_agent_parser(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorUserAgentParserArgs']]:
        return pulumi.get(self, "user_agent_parser")

    @user_agent_parser.setter
    def user_agent_parser(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorUserAgentParserArgs']]):
        pulumi.set(self, "user_agent_parser", value)


@pulumi.input_type
class LogsCustomPipelineProcessorArithmeticProcessorArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 target: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 is_replace_missing: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expression: Arithmetic operation between one or more log attributes.
        :param pulumi.Input[str] target: Name of the parent attribute that contains all the extracted details from the sources.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[bool] is_replace_missing: If it replaces all missing attributes of `template` by an empty string.
               * trace_id_remapper
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_replace_missing is not None:
            pulumi.set(__self__, "is_replace_missing", is_replace_missing)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        Arithmetic operation between one or more log attributes.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="isReplaceMissing")
    def is_replace_missing(self) -> Optional[pulumi.Input[bool]]:
        """
        If it replaces all missing attributes of `template` by an empty string.
        * trace_id_remapper
        """
        return pulumi.get(self, "is_replace_missing")

    @is_replace_missing.setter
    def is_replace_missing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_replace_missing", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorAttributeRemapperArgs:
    def __init__(__self__, *,
                 source_type: pulumi.Input[str],
                 sources: pulumi.Input[List[pulumi.Input[str]]],
                 target: pulumi.Input[str],
                 target_type: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 override_on_conflict: Optional[pulumi.Input[bool]] = None,
                 preserve_source: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] source_type: Defines where the sources are from (log `attribute` or `tag`).
        :param pulumi.Input[List[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[str] target: Name of the parent attribute that contains all the extracted details from the sources.
        :param pulumi.Input[str] target_type: Defines if the target is a log `attribute` or `tag`.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        :param pulumi.Input[bool] override_on_conflict: Override the target element if already set.
        :param pulumi.Input[bool] preserve_source: Remove or preserve the remapped source element.
        """
        pulumi.set(__self__, "source_type", source_type)
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "target_type", target_type)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_on_conflict is not None:
            pulumi.set(__self__, "override_on_conflict", override_on_conflict)
        if preserve_source is not None:
            pulumi.set(__self__, "preserve_source", preserve_source)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[str]:
        """
        Defines where the sources are from (log `attribute` or `tag`).
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[List[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[List[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> pulumi.Input[str]:
        """
        Defines if the target is a log `attribute` or `tag`.
        """
        return pulumi.get(self, "target_type")

    @target_type.setter
    def target_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_type", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="overrideOnConflict")
    def override_on_conflict(self) -> Optional[pulumi.Input[bool]]:
        """
        Override the target element if already set.
        """
        return pulumi.get(self, "override_on_conflict")

    @override_on_conflict.setter
    def override_on_conflict(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "override_on_conflict", value)

    @property
    @pulumi.getter(name="preserveSource")
    def preserve_source(self) -> Optional[pulumi.Input[bool]]:
        """
        Remove or preserve the remapped source element.
        """
        return pulumi.get(self, "preserve_source")

    @preserve_source.setter
    def preserve_source(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_source", value)


@pulumi.input_type
class LogsCustomPipelineProcessorCategoryProcessorArgs:
    def __init__(__self__, *,
                 categories: pulumi.Input[List[pulumi.Input['LogsCustomPipelineProcessorCategoryProcessorCategoryArgs']]],
                 target: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[List[pulumi.Input['LogsCustomPipelineProcessorCategoryProcessorCategoryArgs']]] categories: List of filters to match or exclude a log with their corresponding name to assign a custom value to the log.
        :param pulumi.Input[str] target: Name of the parent attribute that contains all the extracted details from the sources.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "categories", categories)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def categories(self) -> pulumi.Input[List[pulumi.Input['LogsCustomPipelineProcessorCategoryProcessorCategoryArgs']]]:
        """
        List of filters to match or exclude a log with their corresponding name to assign a custom value to the log.
        """
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: pulumi.Input[List[pulumi.Input['LogsCustomPipelineProcessorCategoryProcessorCategoryArgs']]]):
        pulumi.set(self, "categories", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorCategoryProcessorCategoryArgs:
    def __init__(__self__, *,
                 filters: pulumi.Input[List[pulumi.Input['LogsCustomPipelineProcessorCategoryProcessorCategoryFilterArgs']]],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[List[pulumi.Input['LogsCustomPipelineProcessorCategoryProcessorCategoryFilterArgs']]] filters: Defines the nested pipeline filter. Only logs that match the filter criteria are processed by this pipeline.
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def filters(self) -> pulumi.Input[List[pulumi.Input['LogsCustomPipelineProcessorCategoryProcessorCategoryFilterArgs']]]:
        """
        Defines the nested pipeline filter. Only logs that match the filter criteria are processed by this pipeline.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: pulumi.Input[List[pulumi.Input['LogsCustomPipelineProcessorCategoryProcessorCategoryFilterArgs']]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorCategoryProcessorCategoryFilterArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class LogsCustomPipelineProcessorDateRemapperArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[List[pulumi.Input[str]]],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[List[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[List[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[List[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorGeoIpParserArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[List[pulumi.Input[str]]],
                 target: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[List[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[str] target: Name of the parent attribute that contains all the extracted details from the sources.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[List[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[List[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorGrokParserArgs:
    def __init__(__self__, *,
                 grok: pulumi.Input['LogsCustomPipelineProcessorGrokParserGrokArgs'],
                 source: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 samples: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] source: Name of the source attribute used to do the lookup.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        :param pulumi.Input[List[pulumi.Input[str]]] samples: List of sample logs for this parser. It can save up to 5 samples. Each sample takes up to 5000 characters.
        """
        pulumi.set(__self__, "grok", grok)
        pulumi.set(__self__, "source", source)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if samples is not None:
            pulumi.set(__self__, "samples", samples)

    @property
    @pulumi.getter
    def grok(self) -> pulumi.Input['LogsCustomPipelineProcessorGrokParserGrokArgs']:
        return pulumi.get(self, "grok")

    @grok.setter
    def grok(self, value: pulumi.Input['LogsCustomPipelineProcessorGrokParserGrokArgs']):
        pulumi.set(self, "grok", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        Name of the source attribute used to do the lookup.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def samples(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        List of sample logs for this parser. It can save up to 5 samples. Each sample takes up to 5000 characters.
        """
        return pulumi.get(self, "samples")

    @samples.setter
    def samples(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "samples", value)


@pulumi.input_type
class LogsCustomPipelineProcessorGrokParserGrokArgs:
    def __init__(__self__, *,
                 match_rules: pulumi.Input[str],
                 support_rules: pulumi.Input[str]):
        """
        :param pulumi.Input[str] match_rules: Match rules for your grok parser.
        :param pulumi.Input[str] support_rules: Support rules for your grok parser.
        """
        pulumi.set(__self__, "match_rules", match_rules)
        pulumi.set(__self__, "support_rules", support_rules)

    @property
    @pulumi.getter(name="matchRules")
    def match_rules(self) -> pulumi.Input[str]:
        """
        Match rules for your grok parser.
        """
        return pulumi.get(self, "match_rules")

    @match_rules.setter
    def match_rules(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_rules", value)

    @property
    @pulumi.getter(name="supportRules")
    def support_rules(self) -> pulumi.Input[str]:
        """
        Support rules for your grok parser.
        """
        return pulumi.get(self, "support_rules")

    @support_rules.setter
    def support_rules(self, value: pulumi.Input[str]):
        pulumi.set(self, "support_rules", value)


@pulumi.input_type
class LogsCustomPipelineProcessorLookupProcessorArgs:
    def __init__(__self__, *,
                 lookup_tables: pulumi.Input[List[pulumi.Input[str]]],
                 source: pulumi.Input[str],
                 target: pulumi.Input[str],
                 default_lookup: Optional[pulumi.Input[str]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[List[pulumi.Input[str]]] lookup_tables: List of entries of the lookup table using `"key,value"` format.
        :param pulumi.Input[str] source: Name of the source attribute used to do the lookup.
        :param pulumi.Input[str] target: Name of the parent attribute that contains all the extracted details from the sources.
        :param pulumi.Input[str] default_lookup: Default lookup value to use if there is no entry in the lookup table for the value of the source attribute.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "lookup_tables", lookup_tables)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if default_lookup is not None:
            pulumi.set(__self__, "default_lookup", default_lookup)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="lookupTables")
    def lookup_tables(self) -> pulumi.Input[List[pulumi.Input[str]]]:
        """
        List of entries of the lookup table using `"key,value"` format.
        """
        return pulumi.get(self, "lookup_tables")

    @lookup_tables.setter
    def lookup_tables(self, value: pulumi.Input[List[pulumi.Input[str]]]):
        pulumi.set(self, "lookup_tables", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        Name of the source attribute used to do the lookup.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="defaultLookup")
    def default_lookup(self) -> Optional[pulumi.Input[str]]:
        """
        Default lookup value to use if there is no entry in the lookup table for the value of the source attribute.
        """
        return pulumi.get(self, "default_lookup")

    @default_lookup.setter
    def default_lookup(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_lookup", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorMessageRemapperArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[List[pulumi.Input[str]]],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[List[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[List[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[List[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineArgs:
    def __init__(__self__, *,
                 filters: pulumi.Input[List[pulumi.Input['LogsCustomPipelineProcessorPipelineFilterArgs']]],
                 name: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 processors: Optional[pulumi.Input[List[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorArgs']]]] = None):
        """
        :param pulumi.Input[List[pulumi.Input['LogsCustomPipelineProcessorPipelineFilterArgs']]] filters: Defines the nested pipeline filter. Only logs that match the filter criteria are processed by this pipeline.
        :param pulumi.Input[str] name: Name of the processor
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[List[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorArgs']]] processors: Processors. Nested pipeline can't take any other nested pipeline as its processor.
        """
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "name", name)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if processors is not None:
            pulumi.set(__self__, "processors", processors)

    @property
    @pulumi.getter
    def filters(self) -> pulumi.Input[List[pulumi.Input['LogsCustomPipelineProcessorPipelineFilterArgs']]]:
        """
        Defines the nested pipeline filter. Only logs that match the filter criteria are processed by this pipeline.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: pulumi.Input[List[pulumi.Input['LogsCustomPipelineProcessorPipelineFilterArgs']]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def processors(self) -> Optional[pulumi.Input[List[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorArgs']]]]:
        """
        Processors. Nested pipeline can't take any other nested pipeline as its processor.
        """
        return pulumi.get(self, "processors")

    @processors.setter
    def processors(self, value: Optional[pulumi.Input[List[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorArgs']]]]):
        pulumi.set(self, "processors", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineFilterArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorArgs:
    def __init__(__self__, *,
                 arithmetic_processor: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessorArgs']] = None,
                 attribute_remapper: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorAttributeRemapperArgs']] = None,
                 category_processor: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorArgs']] = None,
                 date_remapper: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorDateRemapperArgs']] = None,
                 geo_ip_parser: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorGeoIpParserArgs']] = None,
                 grok_parser: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorGrokParserArgs']] = None,
                 lookup_processor: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorLookupProcessorArgs']] = None,
                 message_remapper: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorMessageRemapperArgs']] = None,
                 service_remapper: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorServiceRemapperArgs']] = None,
                 status_remapper: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorStatusRemapperArgs']] = None,
                 string_builder_processor: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessorArgs']] = None,
                 trace_id_remapper: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapperArgs']] = None,
                 url_parser: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorUrlParserArgs']] = None,
                 user_agent_parser: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorUserAgentParserArgs']] = None):
        if arithmetic_processor is not None:
            pulumi.set(__self__, "arithmetic_processor", arithmetic_processor)
        if attribute_remapper is not None:
            pulumi.set(__self__, "attribute_remapper", attribute_remapper)
        if category_processor is not None:
            pulumi.set(__self__, "category_processor", category_processor)
        if date_remapper is not None:
            pulumi.set(__self__, "date_remapper", date_remapper)
        if geo_ip_parser is not None:
            pulumi.set(__self__, "geo_ip_parser", geo_ip_parser)
        if grok_parser is not None:
            pulumi.set(__self__, "grok_parser", grok_parser)
        if lookup_processor is not None:
            pulumi.set(__self__, "lookup_processor", lookup_processor)
        if message_remapper is not None:
            pulumi.set(__self__, "message_remapper", message_remapper)
        if service_remapper is not None:
            pulumi.set(__self__, "service_remapper", service_remapper)
        if status_remapper is not None:
            pulumi.set(__self__, "status_remapper", status_remapper)
        if string_builder_processor is not None:
            pulumi.set(__self__, "string_builder_processor", string_builder_processor)
        if trace_id_remapper is not None:
            pulumi.set(__self__, "trace_id_remapper", trace_id_remapper)
        if url_parser is not None:
            pulumi.set(__self__, "url_parser", url_parser)
        if user_agent_parser is not None:
            pulumi.set(__self__, "user_agent_parser", user_agent_parser)

    @property
    @pulumi.getter(name="arithmeticProcessor")
    def arithmetic_processor(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessorArgs']]:
        return pulumi.get(self, "arithmetic_processor")

    @arithmetic_processor.setter
    def arithmetic_processor(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessorArgs']]):
        pulumi.set(self, "arithmetic_processor", value)

    @property
    @pulumi.getter(name="attributeRemapper")
    def attribute_remapper(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorAttributeRemapperArgs']]:
        return pulumi.get(self, "attribute_remapper")

    @attribute_remapper.setter
    def attribute_remapper(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorAttributeRemapperArgs']]):
        pulumi.set(self, "attribute_remapper", value)

    @property
    @pulumi.getter(name="categoryProcessor")
    def category_processor(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorArgs']]:
        return pulumi.get(self, "category_processor")

    @category_processor.setter
    def category_processor(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorArgs']]):
        pulumi.set(self, "category_processor", value)

    @property
    @pulumi.getter(name="dateRemapper")
    def date_remapper(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorDateRemapperArgs']]:
        return pulumi.get(self, "date_remapper")

    @date_remapper.setter
    def date_remapper(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorDateRemapperArgs']]):
        pulumi.set(self, "date_remapper", value)

    @property
    @pulumi.getter(name="geoIpParser")
    def geo_ip_parser(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorGeoIpParserArgs']]:
        return pulumi.get(self, "geo_ip_parser")

    @geo_ip_parser.setter
    def geo_ip_parser(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorGeoIpParserArgs']]):
        pulumi.set(self, "geo_ip_parser", value)

    @property
    @pulumi.getter(name="grokParser")
    def grok_parser(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorGrokParserArgs']]:
        return pulumi.get(self, "grok_parser")

    @grok_parser.setter
    def grok_parser(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorGrokParserArgs']]):
        pulumi.set(self, "grok_parser", value)

    @property
    @pulumi.getter(name="lookupProcessor")
    def lookup_processor(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorLookupProcessorArgs']]:
        return pulumi.get(self, "lookup_processor")

    @lookup_processor.setter
    def lookup_processor(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorLookupProcessorArgs']]):
        pulumi.set(self, "lookup_processor", value)

    @property
    @pulumi.getter(name="messageRemapper")
    def message_remapper(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorMessageRemapperArgs']]:
        return pulumi.get(self, "message_remapper")

    @message_remapper.setter
    def message_remapper(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorMessageRemapperArgs']]):
        pulumi.set(self, "message_remapper", value)

    @property
    @pulumi.getter(name="serviceRemapper")
    def service_remapper(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorServiceRemapperArgs']]:
        return pulumi.get(self, "service_remapper")

    @service_remapper.setter
    def service_remapper(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorServiceRemapperArgs']]):
        pulumi.set(self, "service_remapper", value)

    @property
    @pulumi.getter(name="statusRemapper")
    def status_remapper(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorStatusRemapperArgs']]:
        return pulumi.get(self, "status_remapper")

    @status_remapper.setter
    def status_remapper(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorStatusRemapperArgs']]):
        pulumi.set(self, "status_remapper", value)

    @property
    @pulumi.getter(name="stringBuilderProcessor")
    def string_builder_processor(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessorArgs']]:
        return pulumi.get(self, "string_builder_processor")

    @string_builder_processor.setter
    def string_builder_processor(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessorArgs']]):
        pulumi.set(self, "string_builder_processor", value)

    @property
    @pulumi.getter(name="traceIdRemapper")
    def trace_id_remapper(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapperArgs']]:
        return pulumi.get(self, "trace_id_remapper")

    @trace_id_remapper.setter
    def trace_id_remapper(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapperArgs']]):
        pulumi.set(self, "trace_id_remapper", value)

    @property
    @pulumi.getter(name="urlParser")
    def url_parser(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorUrlParserArgs']]:
        return pulumi.get(self, "url_parser")

    @url_parser.setter
    def url_parser(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorUrlParserArgs']]):
        pulumi.set(self, "url_parser", value)

    @property
    @pulumi.getter(name="userAgentParser")
    def user_agent_parser(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorUserAgentParserArgs']]:
        return pulumi.get(self, "user_agent_parser")

    @user_agent_parser.setter
    def user_agent_parser(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorUserAgentParserArgs']]):
        pulumi.set(self, "user_agent_parser", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessorArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 target: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 is_replace_missing: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expression: Arithmetic operation between one or more log attributes.
        :param pulumi.Input[str] target: Name of the parent attribute that contains all the extracted details from the sources.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[bool] is_replace_missing: If it replaces all missing attributes of `template` by an empty string.
               * trace_id_remapper
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_replace_missing is not None:
            pulumi.set(__self__, "is_replace_missing", is_replace_missing)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        Arithmetic operation between one or more log attributes.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="isReplaceMissing")
    def is_replace_missing(self) -> Optional[pulumi.Input[bool]]:
        """
        If it replaces all missing attributes of `template` by an empty string.
        * trace_id_remapper
        """
        return pulumi.get(self, "is_replace_missing")

    @is_replace_missing.setter
    def is_replace_missing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_replace_missing", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorAttributeRemapperArgs:
    def __init__(__self__, *,
                 source_type: pulumi.Input[str],
                 sources: pulumi.Input[List[pulumi.Input[str]]],
                 target: pulumi.Input[str],
                 target_type: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 override_on_conflict: Optional[pulumi.Input[bool]] = None,
                 preserve_source: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] source_type: Defines where the sources are from (log `attribute` or `tag`).
        :param pulumi.Input[List[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[str] target: Name of the parent attribute that contains all the extracted details from the sources.
        :param pulumi.Input[str] target_type: Defines if the target is a log `attribute` or `tag`.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        :param pulumi.Input[bool] override_on_conflict: Override the target element if already set.
        :param pulumi.Input[bool] preserve_source: Remove or preserve the remapped source element.
        """
        pulumi.set(__self__, "source_type", source_type)
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "target_type", target_type)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_on_conflict is not None:
            pulumi.set(__self__, "override_on_conflict", override_on_conflict)
        if preserve_source is not None:
            pulumi.set(__self__, "preserve_source", preserve_source)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[str]:
        """
        Defines where the sources are from (log `attribute` or `tag`).
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[List[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[List[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> pulumi.Input[str]:
        """
        Defines if the target is a log `attribute` or `tag`.
        """
        return pulumi.get(self, "target_type")

    @target_type.setter
    def target_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_type", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="overrideOnConflict")
    def override_on_conflict(self) -> Optional[pulumi.Input[bool]]:
        """
        Override the target element if already set.
        """
        return pulumi.get(self, "override_on_conflict")

    @override_on_conflict.setter
    def override_on_conflict(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "override_on_conflict", value)

    @property
    @pulumi.getter(name="preserveSource")
    def preserve_source(self) -> Optional[pulumi.Input[bool]]:
        """
        Remove or preserve the remapped source element.
        """
        return pulumi.get(self, "preserve_source")

    @preserve_source.setter
    def preserve_source(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_source", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorArgs:
    def __init__(__self__, *,
                 categories: pulumi.Input[List[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryArgs']]],
                 target: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[List[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryArgs']]] categories: List of filters to match or exclude a log with their corresponding name to assign a custom value to the log.
        :param pulumi.Input[str] target: Name of the parent attribute that contains all the extracted details from the sources.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "categories", categories)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def categories(self) -> pulumi.Input[List[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryArgs']]]:
        """
        List of filters to match or exclude a log with their corresponding name to assign a custom value to the log.
        """
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: pulumi.Input[List[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryArgs']]]):
        pulumi.set(self, "categories", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryArgs:
    def __init__(__self__, *,
                 filters: pulumi.Input[List[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilterArgs']]],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[List[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilterArgs']]] filters: Defines the nested pipeline filter. Only logs that match the filter criteria are processed by this pipeline.
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def filters(self) -> pulumi.Input[List[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilterArgs']]]:
        """
        Defines the nested pipeline filter. Only logs that match the filter criteria are processed by this pipeline.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: pulumi.Input[List[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilterArgs']]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilterArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorDateRemapperArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[List[pulumi.Input[str]]],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[List[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[List[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[List[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorGeoIpParserArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[List[pulumi.Input[str]]],
                 target: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[List[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[str] target: Name of the parent attribute that contains all the extracted details from the sources.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[List[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[List[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorGrokParserArgs:
    def __init__(__self__, *,
                 grok: pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorGrokParserGrokArgs'],
                 source: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 samples: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] source: Name of the source attribute used to do the lookup.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        :param pulumi.Input[List[pulumi.Input[str]]] samples: List of sample logs for this parser. It can save up to 5 samples. Each sample takes up to 5000 characters.
        """
        pulumi.set(__self__, "grok", grok)
        pulumi.set(__self__, "source", source)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if samples is not None:
            pulumi.set(__self__, "samples", samples)

    @property
    @pulumi.getter
    def grok(self) -> pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorGrokParserGrokArgs']:
        return pulumi.get(self, "grok")

    @grok.setter
    def grok(self, value: pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorGrokParserGrokArgs']):
        pulumi.set(self, "grok", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        Name of the source attribute used to do the lookup.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def samples(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        List of sample logs for this parser. It can save up to 5 samples. Each sample takes up to 5000 characters.
        """
        return pulumi.get(self, "samples")

    @samples.setter
    def samples(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "samples", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorGrokParserGrokArgs:
    def __init__(__self__, *,
                 match_rules: pulumi.Input[str],
                 support_rules: pulumi.Input[str]):
        """
        :param pulumi.Input[str] match_rules: Match rules for your grok parser.
        :param pulumi.Input[str] support_rules: Support rules for your grok parser.
        """
        pulumi.set(__self__, "match_rules", match_rules)
        pulumi.set(__self__, "support_rules", support_rules)

    @property
    @pulumi.getter(name="matchRules")
    def match_rules(self) -> pulumi.Input[str]:
        """
        Match rules for your grok parser.
        """
        return pulumi.get(self, "match_rules")

    @match_rules.setter
    def match_rules(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_rules", value)

    @property
    @pulumi.getter(name="supportRules")
    def support_rules(self) -> pulumi.Input[str]:
        """
        Support rules for your grok parser.
        """
        return pulumi.get(self, "support_rules")

    @support_rules.setter
    def support_rules(self, value: pulumi.Input[str]):
        pulumi.set(self, "support_rules", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorLookupProcessorArgs:
    def __init__(__self__, *,
                 lookup_tables: pulumi.Input[List[pulumi.Input[str]]],
                 source: pulumi.Input[str],
                 target: pulumi.Input[str],
                 default_lookup: Optional[pulumi.Input[str]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[List[pulumi.Input[str]]] lookup_tables: List of entries of the lookup table using `"key,value"` format.
        :param pulumi.Input[str] source: Name of the source attribute used to do the lookup.
        :param pulumi.Input[str] target: Name of the parent attribute that contains all the extracted details from the sources.
        :param pulumi.Input[str] default_lookup: Default lookup value to use if there is no entry in the lookup table for the value of the source attribute.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "lookup_tables", lookup_tables)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if default_lookup is not None:
            pulumi.set(__self__, "default_lookup", default_lookup)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="lookupTables")
    def lookup_tables(self) -> pulumi.Input[List[pulumi.Input[str]]]:
        """
        List of entries of the lookup table using `"key,value"` format.
        """
        return pulumi.get(self, "lookup_tables")

    @lookup_tables.setter
    def lookup_tables(self, value: pulumi.Input[List[pulumi.Input[str]]]):
        pulumi.set(self, "lookup_tables", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        Name of the source attribute used to do the lookup.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="defaultLookup")
    def default_lookup(self) -> Optional[pulumi.Input[str]]:
        """
        Default lookup value to use if there is no entry in the lookup table for the value of the source attribute.
        """
        return pulumi.get(self, "default_lookup")

    @default_lookup.setter
    def default_lookup(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_lookup", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorMessageRemapperArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[List[pulumi.Input[str]]],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[List[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[List[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[List[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorServiceRemapperArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[List[pulumi.Input[str]]],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[List[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[List[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[List[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorStatusRemapperArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[List[pulumi.Input[str]]],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[List[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[List[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[List[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessorArgs:
    def __init__(__self__, *,
                 target: pulumi.Input[str],
                 template: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 is_replace_missing: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] target: Name of the parent attribute that contains all the extracted details from the sources.
        :param pulumi.Input[str] template: The formula with one or more attributes and raw text.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[bool] is_replace_missing: If it replaces all missing attributes of `template` by an empty string.
               * trace_id_remapper
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "template", template)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_replace_missing is not None:
            pulumi.set(__self__, "is_replace_missing", is_replace_missing)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def template(self) -> pulumi.Input[str]:
        """
        The formula with one or more attributes and raw text.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: pulumi.Input[str]):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="isReplaceMissing")
    def is_replace_missing(self) -> Optional[pulumi.Input[bool]]:
        """
        If it replaces all missing attributes of `template` by an empty string.
        * trace_id_remapper
        """
        return pulumi.get(self, "is_replace_missing")

    @is_replace_missing.setter
    def is_replace_missing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_replace_missing", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapperArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[List[pulumi.Input[str]]],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[List[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[List[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[List[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorUrlParserArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[List[pulumi.Input[str]]],
                 target: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 normalize_ending_slashes: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[List[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[str] target: Name of the parent attribute that contains all the extracted details from the sources.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        :param pulumi.Input[bool] normalize_ending_slashes: Normalize the ending slashes or not.
        """
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if normalize_ending_slashes is not None:
            pulumi.set(__self__, "normalize_ending_slashes", normalize_ending_slashes)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[List[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[List[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="normalizeEndingSlashes")
    def normalize_ending_slashes(self) -> Optional[pulumi.Input[bool]]:
        """
        Normalize the ending slashes or not.
        """
        return pulumi.get(self, "normalize_ending_slashes")

    @normalize_ending_slashes.setter
    def normalize_ending_slashes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "normalize_ending_slashes", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorUserAgentParserArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[List[pulumi.Input[str]]],
                 target: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 is_encoded: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[List[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[str] target: Name of the parent attribute that contains all the extracted details from the sources.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[bool] is_encoded: If the source attribute is URL encoded or not.
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_encoded is not None:
            pulumi.set(__self__, "is_encoded", is_encoded)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[List[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[List[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="isEncoded")
    def is_encoded(self) -> Optional[pulumi.Input[bool]]:
        """
        If the source attribute is URL encoded or not.
        """
        return pulumi.get(self, "is_encoded")

    @is_encoded.setter
    def is_encoded(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_encoded", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorServiceRemapperArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[List[pulumi.Input[str]]],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[List[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[List[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[List[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorStatusRemapperArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[List[pulumi.Input[str]]],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[List[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[List[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[List[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorStringBuilderProcessorArgs:
    def __init__(__self__, *,
                 target: pulumi.Input[str],
                 template: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 is_replace_missing: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] target: Name of the parent attribute that contains all the extracted details from the sources.
        :param pulumi.Input[str] template: The formula with one or more attributes and raw text.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[bool] is_replace_missing: If it replaces all missing attributes of `template` by an empty string.
               * trace_id_remapper
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "template", template)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_replace_missing is not None:
            pulumi.set(__self__, "is_replace_missing", is_replace_missing)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def template(self) -> pulumi.Input[str]:
        """
        The formula with one or more attributes and raw text.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: pulumi.Input[str]):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="isReplaceMissing")
    def is_replace_missing(self) -> Optional[pulumi.Input[bool]]:
        """
        If it replaces all missing attributes of `template` by an empty string.
        * trace_id_remapper
        """
        return pulumi.get(self, "is_replace_missing")

    @is_replace_missing.setter
    def is_replace_missing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_replace_missing", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorTraceIdRemapperArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[List[pulumi.Input[str]]],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[List[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[List[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[List[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorUrlParserArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[List[pulumi.Input[str]]],
                 target: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 normalize_ending_slashes: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[List[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[str] target: Name of the parent attribute that contains all the extracted details from the sources.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        :param pulumi.Input[bool] normalize_ending_slashes: Normalize the ending slashes or not.
        """
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if normalize_ending_slashes is not None:
            pulumi.set(__self__, "normalize_ending_slashes", normalize_ending_slashes)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[List[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[List[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="normalizeEndingSlashes")
    def normalize_ending_slashes(self) -> Optional[pulumi.Input[bool]]:
        """
        Normalize the ending slashes or not.
        """
        return pulumi.get(self, "normalize_ending_slashes")

    @normalize_ending_slashes.setter
    def normalize_ending_slashes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "normalize_ending_slashes", value)


@pulumi.input_type
class LogsCustomPipelineProcessorUserAgentParserArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[List[pulumi.Input[str]]],
                 target: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 is_encoded: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[List[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[str] target: Name of the parent attribute that contains all the extracted details from the sources.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[bool] is_encoded: If the source attribute is URL encoded or not.
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_encoded is not None:
            pulumi.set(__self__, "is_encoded", is_encoded)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[List[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[List[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="isEncoded")
    def is_encoded(self) -> Optional[pulumi.Input[bool]]:
        """
        If the source attribute is URL encoded or not.
        """
        return pulumi.get(self, "is_encoded")

    @is_encoded.setter
    def is_encoded(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_encoded", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsIndexExclusionFilterArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[List[pulumi.Input['LogsIndexExclusionFilterFilterArgs']]]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_enabled: A boolean stating if the exclusion is active or not.
        :param pulumi.Input[str] name: The name of the exclusion filter.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[List[pulumi.Input['LogsIndexExclusionFilterFilterArgs']]]]:
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[List[pulumi.Input['LogsIndexExclusionFilterFilterArgs']]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean stating if the exclusion is active or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the exclusion filter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsIndexExclusionFilterFilterArgs:
    def __init__(__self__, *,
                 query: Optional[pulumi.Input[str]] = None,
                 sample_rate: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] query: Only logs matching the filter criteria and the query of the parent index will be considered for this exclusion filter.
        :param pulumi.Input[float] sample_rate: The fraction of logs excluded by the exclusion filter, when active.
        """
        if query is not None:
            pulumi.set(__self__, "query", query)
        if sample_rate is not None:
            pulumi.set(__self__, "sample_rate", sample_rate)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[str]]:
        """
        Only logs matching the filter criteria and the query of the parent index will be considered for this exclusion filter.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[pulumi.Input[float]]:
        """
        The fraction of logs excluded by the exclusion filter, when active.
        """
        return pulumi.get(self, "sample_rate")

    @sample_rate.setter
    def sample_rate(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "sample_rate", value)


@pulumi.input_type
class LogsIndexFilterArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: Only logs matching the filter criteria and the query of the parent index will be considered for this exclusion filter.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        Only logs matching the filter criteria and the query of the parent index will be considered for this exclusion filter.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class MonitorThresholdWindowsArgs:
    def __init__(__self__, *,
                 recovery_window: Optional[pulumi.Input[str]] = None,
                 trigger_window: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] recovery_window: describes how long an anomalous metric must be normal before the alert recovers.
        :param pulumi.Input[str] trigger_window: describes how long a metric must be anomalous before an alert triggers.
        """
        if recovery_window is not None:
            pulumi.set(__self__, "recovery_window", recovery_window)
        if trigger_window is not None:
            pulumi.set(__self__, "trigger_window", trigger_window)

    @property
    @pulumi.getter(name="recoveryWindow")
    def recovery_window(self) -> Optional[pulumi.Input[str]]:
        """
        describes how long an anomalous metric must be normal before the alert recovers.
        """
        return pulumi.get(self, "recovery_window")

    @recovery_window.setter
    def recovery_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recovery_window", value)

    @property
    @pulumi.getter(name="triggerWindow")
    def trigger_window(self) -> Optional[pulumi.Input[str]]:
        """
        describes how long a metric must be anomalous before an alert triggers.
        """
        return pulumi.get(self, "trigger_window")

    @trigger_window.setter
    def trigger_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trigger_window", value)


@pulumi.input_type
class MonitorThresholdsArgs:
    def __init__(__self__, *,
                 critical: Optional[pulumi.Input[float]] = None,
                 critical_recovery: Optional[pulumi.Input[float]] = None,
                 ok: Optional[pulumi.Input[float]] = None,
                 unknown: Optional[pulumi.Input[float]] = None,
                 warning: Optional[pulumi.Input[float]] = None,
                 warning_recovery: Optional[pulumi.Input[float]] = None):
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if critical_recovery is not None:
            pulumi.set(__self__, "critical_recovery", critical_recovery)
        if ok is not None:
            pulumi.set(__self__, "ok", ok)
        if unknown is not None:
            pulumi.set(__self__, "unknown", unknown)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)
        if warning_recovery is not None:
            pulumi.set(__self__, "warning_recovery", warning_recovery)

    @property
    @pulumi.getter
    def critical(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "critical")

    @critical.setter
    def critical(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "critical", value)

    @property
    @pulumi.getter(name="criticalRecovery")
    def critical_recovery(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "critical_recovery")

    @critical_recovery.setter
    def critical_recovery(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "critical_recovery", value)

    @property
    @pulumi.getter
    def ok(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "ok")

    @ok.setter
    def ok(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "ok", value)

    @property
    @pulumi.getter
    def unknown(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "unknown")

    @unknown.setter
    def unknown(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "unknown", value)

    @property
    @pulumi.getter
    def warning(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "warning")

    @warning.setter
    def warning(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "warning", value)

    @property
    @pulumi.getter(name="warningRecovery")
    def warning_recovery(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "warning_recovery")

    @warning_recovery.setter
    def warning_recovery(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "warning_recovery", value)


@pulumi.input_type
class ScreenBoardTemplateVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 default: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The variable name. Can be referenced as \$name in `graph` `request` `q` query strings.
        :param pulumi.Input[str] default: The default tag. Default: "\*" (match all).
        :param pulumi.Input[str] prefix: The tag group. Default: no tag group.
        """
        pulumi.set(__self__, "name", name)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The variable name. Can be referenced as \$name in `graph` `request` `q` query strings.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[str]]:
        """
        The default tag. Default: "\*" (match all).
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The tag group. Default: no tag group.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


@pulumi.input_type
class ScreenBoardWidgetArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 x: pulumi.Input[float],
                 y: pulumi.Input[float],
                 alert_id: Optional[pulumi.Input[float]] = None,
                 auto_refresh: Optional[pulumi.Input[bool]] = None,
                 bgcolor: Optional[pulumi.Input[str]] = None,
                 check: Optional[pulumi.Input[str]] = None,
                 color: Optional[pulumi.Input[str]] = None,
                 color_preference: Optional[pulumi.Input[str]] = None,
                 columns: Optional[pulumi.Input[str]] = None,
                 display_format: Optional[pulumi.Input[str]] = None,
                 env: Optional[pulumi.Input[str]] = None,
                 event_size: Optional[pulumi.Input[str]] = None,
                 font_size: Optional[pulumi.Input[str]] = None,
                 group: Optional[pulumi.Input[str]] = None,
                 group_bies: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 grouping: Optional[pulumi.Input[str]] = None,
                 height: Optional[pulumi.Input[float]] = None,
                 hide_zero_counts: Optional[pulumi.Input[bool]] = None,
                 html: Optional[pulumi.Input[str]] = None,
                 layout_version: Optional[pulumi.Input[str]] = None,
                 legend: Optional[pulumi.Input[bool]] = None,
                 legend_size: Optional[pulumi.Input[str]] = None,
                 logset: Optional[pulumi.Input[str]] = None,
                 manage_status_show_title: Optional[pulumi.Input[bool]] = None,
                 manage_status_title_align: Optional[pulumi.Input[str]] = None,
                 manage_status_title_size: Optional[pulumi.Input[str]] = None,
                 manage_status_title_text: Optional[pulumi.Input[str]] = None,
                 margin: Optional[pulumi.Input[str]] = None,
                 monitor: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 must_show_breakdown: Optional[pulumi.Input[bool]] = None,
                 must_show_distribution: Optional[pulumi.Input[bool]] = None,
                 must_show_errors: Optional[pulumi.Input[bool]] = None,
                 must_show_hits: Optional[pulumi.Input[bool]] = None,
                 must_show_latency: Optional[pulumi.Input[bool]] = None,
                 must_show_resource_list: Optional[pulumi.Input[bool]] = None,
                 params: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 precision: Optional[pulumi.Input[str]] = None,
                 query: Optional[pulumi.Input[str]] = None,
                 rules: Optional[pulumi.Input[List[pulumi.Input['ScreenBoardWidgetRuleArgs']]]] = None,
                 service_name: Optional[pulumi.Input[str]] = None,
                 service_service: Optional[pulumi.Input[str]] = None,
                 show_last_triggered: Optional[pulumi.Input[bool]] = None,
                 size_version: Optional[pulumi.Input[str]] = None,
                 sizing: Optional[pulumi.Input[str]] = None,
                 summary_type: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 text: Optional[pulumi.Input[str]] = None,
                 text_align: Optional[pulumi.Input[str]] = None,
                 text_size: Optional[pulumi.Input[str]] = None,
                 tick: Optional[pulumi.Input[bool]] = None,
                 tick_edge: Optional[pulumi.Input[str]] = None,
                 tick_pos: Optional[pulumi.Input[str]] = None,
                 tile_deves: Optional[pulumi.Input[List[pulumi.Input['ScreenBoardWidgetTileDefArgs']]]] = None,
                 time: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 timeframes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[float]] = None,
                 unit: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None,
                 viz_type: Optional[pulumi.Input[str]] = None,
                 width: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] type: Choose the type of representation to use for this query. For widgets of type "timeseries" and "query_value", use one of "line", "bars" or "area". For widgets of type "hostmap", use "fill" or "size".
        :param pulumi.Input[float] x: The position of the widget on the x (horizontal) axis. Should be greater or equal to 0.
        :param pulumi.Input[float] y: The position of the widget on the y (vertical) axis. Should be greater or equal to 0.
        :param pulumi.Input[float] alert_id: The ID of the monitor used by the widget.
        :param pulumi.Input[bool] auto_refresh: Boolean indicating whether the widget is refreshed automatically.
        :param pulumi.Input[str] bgcolor: The color of the background of the widget.
        :param pulumi.Input[str] check: The check to use in the widget.
        :param pulumi.Input[str] color: The color of the text in the widget.
        :param pulumi.Input[str] color_preference: Whether to colorize text or background. One of "text", "background".
        :param pulumi.Input[str] columns: Stringified list of columns to use. Example: `"[\"column1\",\"column2\",\"column3\"]"`
        :param pulumi.Input[str] display_format: The display setting to use. One of "counts", "list", or "countsAndList".
        :param pulumi.Input[str] env: The environment to use.
        :param pulumi.Input[str] event_size: The size of the events in the widget. Either "s" (small, title only) or "l" (large, full event).
        :param pulumi.Input[str] font_size: The size of the text in the widget.
        :param pulumi.Input[str] group: The list of tags to group nodes by.
        :param pulumi.Input[List[pulumi.Input[str]]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input[str] grouping: Either "check" or "cluster", depending on whether the widget should use a single check or a cluster of checks.
        :param pulumi.Input[float] height: The height of the widget. Default is 15.
        :param pulumi.Input[bool] hide_zero_counts: Boolean indicating whether to hide empty categories.
        :param pulumi.Input[str] html: The content of the widget. HTML tags supported.
        :param pulumi.Input[str] layout_version: The number of columns to use when displaying values. One of "one_column", "two_column", "three_column".
        :param pulumi.Input[bool] legend: Boolean indicating whether to display a legend in the widget.
        :param pulumi.Input[str] legend_size: The size of the legend displayed in the widget.
        :param pulumi.Input[str] logset: ID of the logset to use.
        :param pulumi.Input[bool] manage_status_show_title: Boolean indicating whether to show a title.
        :param pulumi.Input[str] manage_status_title_align: The alignment of the widget's title. One of "left", "center", or "right".
        :param pulumi.Input[str] manage_status_title_size: The size of the widget's title.
        :param pulumi.Input[str] manage_status_title_text: The title of the widget.
        :param pulumi.Input[str] margin: The margins to use around the image. Either "small" or "large".
        :param pulumi.Input[bool] must_show_breakdown: Boolean indicating whether to display breakdown.
        :param pulumi.Input[bool] must_show_distribution: Boolean indicating whether to display distribution.
        :param pulumi.Input[bool] must_show_errors: Boolean indicating whether to display errors.
        :param pulumi.Input[bool] must_show_hits: Boolean indicating whether to display hits.
        :param pulumi.Input[bool] must_show_latency: Boolean indicating whether to display latency.
        :param pulumi.Input[bool] must_show_resource_list: Boolean indicating whether to display resources.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] params: Nested block describing the monitors to display. The structure of this block is described below. At most one such block should be present in a given widget.
        :param pulumi.Input[str] precision: The precision to use when displaying the tile.
        :param pulumi.Input[str] query: The query to use in the widget.
        :param pulumi.Input[str] service_name: The name of the service to use.
        :param pulumi.Input[str] service_service: The trace service to use.
        :param pulumi.Input[bool] show_last_triggered: Boolean indicating whether to show when monitors/groups last triggered.
        :param pulumi.Input[str] size_version: The size of the widget. One of "small", "medium", "large".
        :param pulumi.Input[str] sizing: The preferred method to adapt the dimensions of the image to those of the widget. One of "center" (center the image in the tile), "zoom" (zoom the image to cover the whole tile) or "fit" (fit the image dimensions to those of the tile).
        :param pulumi.Input[str] summary_type: The monitor summary type to use. One of "monitors", "groups", or "combined". Defaults to "monitors".
        :param pulumi.Input[List[pulumi.Input[str]]] tags: List of tags to use in the widget.
        :param pulumi.Input[str] text: The query to use to get monitors. Example: "status:alert".
        :param pulumi.Input[str] text_align: The alignment of the text.
        :param pulumi.Input[str] text_size: The size of the text in the widget.
        :param pulumi.Input[bool] tick: Boolean indicating whether a tick should be displayed on the border of the widget.
        :param pulumi.Input[str] tick_edge: When tick = true, string indicating on which side of the widget the tick should be displayed. One of "bottom", "top", "left", "right".
        :param pulumi.Input[str] tick_pos: When tick = true, string with a percent sign indicating the position of the tick. Example: use tick_pos = "50%" for centered alignment.
        :param pulumi.Input[List[pulumi.Input['ScreenBoardWidgetTileDefArgs']]] tile_deves: Nested block describing the content to display in the widget. The structure of this block is described below. At most one such block should be present in a given widget.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] time: Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below. At most one such block should be present in a given widget.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. One of "left", "center", or "right".
        :param pulumi.Input[float] title_size: The size of the widget's title. Default is 16.
        :param pulumi.Input[str] unit: The unit for the value displayed in the widget.
        :param pulumi.Input[str] url: The URL to use as a data source for the widget.
        :param pulumi.Input[str] viz_type: Type of visualization to use when displaying the widget. Either "timeseries" or "toplist".
        :param pulumi.Input[float] width: The width of the widget. Default is 50.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "x", x)
        pulumi.set(__self__, "y", y)
        if alert_id is not None:
            pulumi.set(__self__, "alert_id", alert_id)
        if auto_refresh is not None:
            pulumi.set(__self__, "auto_refresh", auto_refresh)
        if bgcolor is not None:
            pulumi.set(__self__, "bgcolor", bgcolor)
        if check is not None:
            pulumi.set(__self__, "check", check)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if color_preference is not None:
            pulumi.set(__self__, "color_preference", color_preference)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if display_format is not None:
            pulumi.set(__self__, "display_format", display_format)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if event_size is not None:
            pulumi.set(__self__, "event_size", event_size)
        if font_size is not None:
            pulumi.set(__self__, "font_size", font_size)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if grouping is not None:
            pulumi.set(__self__, "grouping", grouping)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if hide_zero_counts is not None:
            pulumi.set(__self__, "hide_zero_counts", hide_zero_counts)
        if html is not None:
            pulumi.set(__self__, "html", html)
        if layout_version is not None:
            pulumi.set(__self__, "layout_version", layout_version)
        if legend is not None:
            pulumi.set(__self__, "legend", legend)
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if logset is not None:
            pulumi.set(__self__, "logset", logset)
        if manage_status_show_title is not None:
            pulumi.set(__self__, "manage_status_show_title", manage_status_show_title)
        if manage_status_title_align is not None:
            pulumi.set(__self__, "manage_status_title_align", manage_status_title_align)
        if manage_status_title_size is not None:
            pulumi.set(__self__, "manage_status_title_size", manage_status_title_size)
        if manage_status_title_text is not None:
            pulumi.set(__self__, "manage_status_title_text", manage_status_title_text)
        if margin is not None:
            pulumi.set(__self__, "margin", margin)
        if monitor is not None:
            pulumi.set(__self__, "monitor", monitor)
        if must_show_breakdown is not None:
            pulumi.set(__self__, "must_show_breakdown", must_show_breakdown)
        if must_show_distribution is not None:
            pulumi.set(__self__, "must_show_distribution", must_show_distribution)
        if must_show_errors is not None:
            pulumi.set(__self__, "must_show_errors", must_show_errors)
        if must_show_hits is not None:
            pulumi.set(__self__, "must_show_hits", must_show_hits)
        if must_show_latency is not None:
            pulumi.set(__self__, "must_show_latency", must_show_latency)
        if must_show_resource_list is not None:
            pulumi.set(__self__, "must_show_resource_list", must_show_resource_list)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if service_service is not None:
            pulumi.set(__self__, "service_service", service_service)
        if show_last_triggered is not None:
            pulumi.set(__self__, "show_last_triggered", show_last_triggered)
        if size_version is not None:
            pulumi.set(__self__, "size_version", size_version)
        if sizing is not None:
            pulumi.set(__self__, "sizing", sizing)
        if summary_type is not None:
            pulumi.set(__self__, "summary_type", summary_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if text_size is not None:
            pulumi.set(__self__, "text_size", text_size)
        if tick is not None:
            pulumi.set(__self__, "tick", tick)
        if tick_edge is not None:
            pulumi.set(__self__, "tick_edge", tick_edge)
        if tick_pos is not None:
            pulumi.set(__self__, "tick_pos", tick_pos)
        if tile_deves is not None:
            pulumi.set(__self__, "tile_deves", tile_deves)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if timeframes is not None:
            pulumi.set(__self__, "timeframes", timeframes)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if viz_type is not None:
            pulumi.set(__self__, "viz_type", viz_type)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Choose the type of representation to use for this query. For widgets of type "timeseries" and "query_value", use one of "line", "bars" or "area". For widgets of type "hostmap", use "fill" or "size".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def x(self) -> pulumi.Input[float]:
        """
        The position of the widget on the x (horizontal) axis. Should be greater or equal to 0.
        """
        return pulumi.get(self, "x")

    @x.setter
    def x(self, value: pulumi.Input[float]):
        pulumi.set(self, "x", value)

    @property
    @pulumi.getter
    def y(self) -> pulumi.Input[float]:
        """
        The position of the widget on the y (vertical) axis. Should be greater or equal to 0.
        """
        return pulumi.get(self, "y")

    @y.setter
    def y(self, value: pulumi.Input[float]):
        pulumi.set(self, "y", value)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> Optional[pulumi.Input[float]]:
        """
        The ID of the monitor used by the widget.
        """
        return pulumi.get(self, "alert_id")

    @alert_id.setter
    def alert_id(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "alert_id", value)

    @property
    @pulumi.getter(name="autoRefresh")
    def auto_refresh(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether the widget is refreshed automatically.
        """
        return pulumi.get(self, "auto_refresh")

    @auto_refresh.setter
    def auto_refresh(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_refresh", value)

    @property
    @pulumi.getter
    def bgcolor(self) -> Optional[pulumi.Input[str]]:
        """
        The color of the background of the widget.
        """
        return pulumi.get(self, "bgcolor")

    @bgcolor.setter
    def bgcolor(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bgcolor", value)

    @property
    @pulumi.getter
    def check(self) -> Optional[pulumi.Input[str]]:
        """
        The check to use in the widget.
        """
        return pulumi.get(self, "check")

    @check.setter
    def check(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "check", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        The color of the text in the widget.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="colorPreference")
    def color_preference(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to colorize text or background. One of "text", "background".
        """
        return pulumi.get(self, "color_preference")

    @color_preference.setter
    def color_preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color_preference", value)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[str]]:
        """
        Stringified list of columns to use. Example: `"[\"column1\",\"column2\",\"column3\"]"`
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter(name="displayFormat")
    def display_format(self) -> Optional[pulumi.Input[str]]:
        """
        The display setting to use. One of "counts", "list", or "countsAndList".
        """
        return pulumi.get(self, "display_format")

    @display_format.setter
    def display_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_format", value)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[str]]:
        """
        The environment to use.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter(name="eventSize")
    def event_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the events in the widget. Either "s" (small, title only) or "l" (large, full event).
        """
        return pulumi.get(self, "event_size")

    @event_size.setter
    def event_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_size", value)

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the text in the widget.
        """
        return pulumi.get(self, "font_size")

    @font_size.setter
    def font_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "font_size", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        The list of tags to group nodes by.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def grouping(self) -> Optional[pulumi.Input[str]]:
        """
        Either "check" or "cluster", depending on whether the widget should use a single check or a cluster of checks.
        """
        return pulumi.get(self, "grouping")

    @grouping.setter
    def grouping(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "grouping", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[float]]:
        """
        The height of the widget. Default is 15.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter(name="hideZeroCounts")
    def hide_zero_counts(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether to hide empty categories.
        """
        return pulumi.get(self, "hide_zero_counts")

    @hide_zero_counts.setter
    def hide_zero_counts(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_zero_counts", value)

    @property
    @pulumi.getter
    def html(self) -> Optional[pulumi.Input[str]]:
        """
        The content of the widget. HTML tags supported.
        """
        return pulumi.get(self, "html")

    @html.setter
    def html(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "html", value)

    @property
    @pulumi.getter(name="layoutVersion")
    def layout_version(self) -> Optional[pulumi.Input[str]]:
        """
        The number of columns to use when displaying values. One of "one_column", "two_column", "three_column".
        """
        return pulumi.get(self, "layout_version")

    @layout_version.setter
    def layout_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "layout_version", value)

    @property
    @pulumi.getter
    def legend(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether to display a legend in the widget.
        """
        return pulumi.get(self, "legend")

    @legend.setter
    def legend(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "legend", value)

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the legend displayed in the widget.
        """
        return pulumi.get(self, "legend_size")

    @legend_size.setter
    def legend_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "legend_size", value)

    @property
    @pulumi.getter
    def logset(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the logset to use.
        """
        return pulumi.get(self, "logset")

    @logset.setter
    def logset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logset", value)

    @property
    @pulumi.getter(name="manageStatusShowTitle")
    def manage_status_show_title(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether to show a title.
        """
        return pulumi.get(self, "manage_status_show_title")

    @manage_status_show_title.setter
    def manage_status_show_title(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "manage_status_show_title", value)

    @property
    @pulumi.getter(name="manageStatusTitleAlign")
    def manage_status_title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. One of "left", "center", or "right".
        """
        return pulumi.get(self, "manage_status_title_align")

    @manage_status_title_align.setter
    def manage_status_title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "manage_status_title_align", value)

    @property
    @pulumi.getter(name="manageStatusTitleSize")
    def manage_status_title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title.
        """
        return pulumi.get(self, "manage_status_title_size")

    @manage_status_title_size.setter
    def manage_status_title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "manage_status_title_size", value)

    @property
    @pulumi.getter(name="manageStatusTitleText")
    def manage_status_title_text(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "manage_status_title_text")

    @manage_status_title_text.setter
    def manage_status_title_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "manage_status_title_text", value)

    @property
    @pulumi.getter
    def margin(self) -> Optional[pulumi.Input[str]]:
        """
        The margins to use around the image. Either "small" or "large".
        """
        return pulumi.get(self, "margin")

    @margin.setter
    def margin(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "margin", value)

    @property
    @pulumi.getter
    def monitor(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "monitor")

    @monitor.setter
    def monitor(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "monitor", value)

    @property
    @pulumi.getter(name="mustShowBreakdown")
    def must_show_breakdown(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether to display breakdown.
        """
        return pulumi.get(self, "must_show_breakdown")

    @must_show_breakdown.setter
    def must_show_breakdown(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "must_show_breakdown", value)

    @property
    @pulumi.getter(name="mustShowDistribution")
    def must_show_distribution(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether to display distribution.
        """
        return pulumi.get(self, "must_show_distribution")

    @must_show_distribution.setter
    def must_show_distribution(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "must_show_distribution", value)

    @property
    @pulumi.getter(name="mustShowErrors")
    def must_show_errors(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether to display errors.
        """
        return pulumi.get(self, "must_show_errors")

    @must_show_errors.setter
    def must_show_errors(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "must_show_errors", value)

    @property
    @pulumi.getter(name="mustShowHits")
    def must_show_hits(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether to display hits.
        """
        return pulumi.get(self, "must_show_hits")

    @must_show_hits.setter
    def must_show_hits(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "must_show_hits", value)

    @property
    @pulumi.getter(name="mustShowLatency")
    def must_show_latency(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether to display latency.
        """
        return pulumi.get(self, "must_show_latency")

    @must_show_latency.setter
    def must_show_latency(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "must_show_latency", value)

    @property
    @pulumi.getter(name="mustShowResourceList")
    def must_show_resource_list(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether to display resources.
        """
        return pulumi.get(self, "must_show_resource_list")

    @must_show_resource_list.setter
    def must_show_resource_list(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "must_show_resource_list", value)

    @property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Nested block describing the monitors to display. The structure of this block is described below. At most one such block should be present in a given widget.
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "params", value)

    @property
    @pulumi.getter
    def precision(self) -> Optional[pulumi.Input[str]]:
        """
        The precision to use when displaying the tile.
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "precision", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[str]]:
        """
        The query to use in the widget.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[List[pulumi.Input['ScreenBoardWidgetRuleArgs']]]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[List[pulumi.Input['ScreenBoardWidgetRuleArgs']]]]):
        pulumi.set(self, "rules", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the service to use.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)

    @property
    @pulumi.getter(name="serviceService")
    def service_service(self) -> Optional[pulumi.Input[str]]:
        """
        The trace service to use.
        """
        return pulumi.get(self, "service_service")

    @service_service.setter
    def service_service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_service", value)

    @property
    @pulumi.getter(name="showLastTriggered")
    def show_last_triggered(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether to show when monitors/groups last triggered.
        """
        return pulumi.get(self, "show_last_triggered")

    @show_last_triggered.setter
    def show_last_triggered(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_last_triggered", value)

    @property
    @pulumi.getter(name="sizeVersion")
    def size_version(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget. One of "small", "medium", "large".
        """
        return pulumi.get(self, "size_version")

    @size_version.setter
    def size_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size_version", value)

    @property
    @pulumi.getter
    def sizing(self) -> Optional[pulumi.Input[str]]:
        """
        The preferred method to adapt the dimensions of the image to those of the widget. One of "center" (center the image in the tile), "zoom" (zoom the image to cover the whole tile) or "fit" (fit the image dimensions to those of the tile).
        """
        return pulumi.get(self, "sizing")

    @sizing.setter
    def sizing(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sizing", value)

    @property
    @pulumi.getter(name="summaryType")
    def summary_type(self) -> Optional[pulumi.Input[str]]:
        """
        The monitor summary type to use. One of "monitors", "groups", or "combined". Defaults to "monitors".
        """
        return pulumi.get(self, "summary_type")

    @summary_type.setter
    def summary_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "summary_type", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        List of tags to use in the widget.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[str]]:
        """
        The query to use to get monitors. Example: "status:alert".
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text", value)

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the text.
        """
        return pulumi.get(self, "text_align")

    @text_align.setter
    def text_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_align", value)

    @property
    @pulumi.getter(name="textSize")
    def text_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the text in the widget.
        """
        return pulumi.get(self, "text_size")

    @text_size.setter
    def text_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_size", value)

    @property
    @pulumi.getter
    def tick(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether a tick should be displayed on the border of the widget.
        """
        return pulumi.get(self, "tick")

    @tick.setter
    def tick(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "tick", value)

    @property
    @pulumi.getter(name="tickEdge")
    def tick_edge(self) -> Optional[pulumi.Input[str]]:
        """
        When tick = true, string indicating on which side of the widget the tick should be displayed. One of "bottom", "top", "left", "right".
        """
        return pulumi.get(self, "tick_edge")

    @tick_edge.setter
    def tick_edge(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tick_edge", value)

    @property
    @pulumi.getter(name="tickPos")
    def tick_pos(self) -> Optional[pulumi.Input[str]]:
        """
        When tick = true, string with a percent sign indicating the position of the tick. Example: use tick_pos = "50%" for centered alignment.
        """
        return pulumi.get(self, "tick_pos")

    @tick_pos.setter
    def tick_pos(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tick_pos", value)

    @property
    @pulumi.getter(name="tileDeves")
    def tile_deves(self) -> Optional[pulumi.Input[List[pulumi.Input['ScreenBoardWidgetTileDefArgs']]]]:
        """
        Nested block describing the content to display in the widget. The structure of this block is described below. At most one such block should be present in a given widget.
        """
        return pulumi.get(self, "tile_deves")

    @tile_deves.setter
    def tile_deves(self, value: Optional[pulumi.Input[List[pulumi.Input['ScreenBoardWidgetTileDefArgs']]]]):
        pulumi.set(self, "tile_deves", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below. At most one such block should be present in a given widget.
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def timeframes(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        return pulumi.get(self, "timeframes")

    @timeframes.setter
    def timeframes(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "timeframes", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. One of "left", "center", or "right".
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[float]]:
        """
        The size of the widget's title. Default is 16.
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "title_size", value)

    @property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[str]]:
        """
        The unit for the value displayed in the widget.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL to use as a data source for the widget.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="vizType")
    def viz_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of visualization to use when displaying the widget. Either "timeseries" or "toplist".
        """
        return pulumi.get(self, "viz_type")

    @viz_type.setter
    def viz_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "viz_type", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[float]]:
        """
        The width of the widget. Default is 50.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class ScreenBoardWidgetRuleArgs:
    def __init__(__self__, *,
                 color: Optional[pulumi.Input[str]] = None,
                 threshold: Optional[pulumi.Input[float]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] color: The color of the text in the widget.
        """
        if color is not None:
            pulumi.set(__self__, "color", color)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        The color of the text in the widget.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class ScreenBoardWidgetTileDefArgs:
    def __init__(__self__, *,
                 requests: pulumi.Input[List[pulumi.Input['ScreenBoardWidgetTileDefRequestArgs']]],
                 viz: pulumi.Input[str],
                 autoscale: Optional[pulumi.Input[bool]] = None,
                 custom_unit: Optional[pulumi.Input[str]] = None,
                 events: Optional[pulumi.Input[List[pulumi.Input['ScreenBoardWidgetTileDefEventArgs']]]] = None,
                 groups: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 markers: Optional[pulumi.Input[List[pulumi.Input['ScreenBoardWidgetTileDefMarkerArgs']]]] = None,
                 no_group_hosts: Optional[pulumi.Input[bool]] = None,
                 no_metric_hosts: Optional[pulumi.Input[bool]] = None,
                 node_type: Optional[pulumi.Input[str]] = None,
                 precision: Optional[pulumi.Input[str]] = None,
                 scopes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 style: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 text_align: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[List[pulumi.Input['ScreenBoardWidgetTileDefRequestArgs']]] requests: Nested block describing the request to use when displaying the widget. The structure of this block is described below. Multiple request blocks are allowed within a given tile_def block.
        :param pulumi.Input[str] viz: Should be the same as the widget's type. One of "timeseries", "query_value", "hostmap", "change", "toplist", "process".
        :param pulumi.Input[bool] autoscale: Boolean indicating whether to automatically scale the tile.
        :param pulumi.Input[str] custom_unit: The unit for the value displayed in the widget
        :param pulumi.Input[List[pulumi.Input['ScreenBoardWidgetTileDefEventArgs']]] events: Nested block describing the event overlays to use when displaying the widget. The structure of this block is described below. At most one such block should be present in a given tile_def block.
        :param pulumi.Input[List[pulumi.Input[str]]] groups: The check group to use in the widget.
        :param pulumi.Input[List[pulumi.Input['ScreenBoardWidgetTileDefMarkerArgs']]] markers: Nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple marker blocks are allowed within a given tile_def block.
        :param pulumi.Input[bool] no_group_hosts: Boolean indicating whether to show ungrouped nodes.
        :param pulumi.Input[bool] no_metric_hosts: Boolean indicating whether to show nodes with no metrics.
        :param pulumi.Input[str] node_type: The type of node used. Either "host" or "container".
        :param pulumi.Input[str] precision: The precision to use when displaying the value. Use "\*" for maximum precision.
        :param pulumi.Input[List[pulumi.Input[str]]] scopes: The list of tags to filter nodes by.
        :param pulumi.Input[Mapping[str, Any]] style: Nested block describing how to display the widget. The structure of this block is described below. At most one such block should be present in a given tile_def block.
        :param pulumi.Input[str] text_align: The alignment of the text in the widget.
        """
        pulumi.set(__self__, "requests", requests)
        pulumi.set(__self__, "viz", viz)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if custom_unit is not None:
            pulumi.set(__self__, "custom_unit", custom_unit)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if markers is not None:
            pulumi.set(__self__, "markers", markers)
        if no_group_hosts is not None:
            pulumi.set(__self__, "no_group_hosts", no_group_hosts)
        if no_metric_hosts is not None:
            pulumi.set(__self__, "no_metric_hosts", no_metric_hosts)
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)

    @property
    @pulumi.getter
    def requests(self) -> pulumi.Input[List[pulumi.Input['ScreenBoardWidgetTileDefRequestArgs']]]:
        """
        Nested block describing the request to use when displaying the widget. The structure of this block is described below. Multiple request blocks are allowed within a given tile_def block.
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: pulumi.Input[List[pulumi.Input['ScreenBoardWidgetTileDefRequestArgs']]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter
    def viz(self) -> pulumi.Input[str]:
        """
        Should be the same as the widget's type. One of "timeseries", "query_value", "hostmap", "change", "toplist", "process".
        """
        return pulumi.get(self, "viz")

    @viz.setter
    def viz(self, value: pulumi.Input[str]):
        pulumi.set(self, "viz", value)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether to automatically scale the tile.
        """
        return pulumi.get(self, "autoscale")

    @autoscale.setter
    def autoscale(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "autoscale", value)

    @property
    @pulumi.getter(name="customUnit")
    def custom_unit(self) -> Optional[pulumi.Input[str]]:
        """
        The unit for the value displayed in the widget
        """
        return pulumi.get(self, "custom_unit")

    @custom_unit.setter
    def custom_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_unit", value)

    @property
    @pulumi.getter
    def events(self) -> Optional[pulumi.Input[List[pulumi.Input['ScreenBoardWidgetTileDefEventArgs']]]]:
        """
        Nested block describing the event overlays to use when displaying the widget. The structure of this block is described below. At most one such block should be present in a given tile_def block.
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: Optional[pulumi.Input[List[pulumi.Input['ScreenBoardWidgetTileDefEventArgs']]]]):
        pulumi.set(self, "events", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        The check group to use in the widget.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def markers(self) -> Optional[pulumi.Input[List[pulumi.Input['ScreenBoardWidgetTileDefMarkerArgs']]]]:
        """
        Nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple marker blocks are allowed within a given tile_def block.
        """
        return pulumi.get(self, "markers")

    @markers.setter
    def markers(self, value: Optional[pulumi.Input[List[pulumi.Input['ScreenBoardWidgetTileDefMarkerArgs']]]]):
        pulumi.set(self, "markers", value)

    @property
    @pulumi.getter(name="noGroupHosts")
    def no_group_hosts(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether to show ungrouped nodes.
        """
        return pulumi.get(self, "no_group_hosts")

    @no_group_hosts.setter
    def no_group_hosts(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_group_hosts", value)

    @property
    @pulumi.getter(name="noMetricHosts")
    def no_metric_hosts(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether to show nodes with no metrics.
        """
        return pulumi.get(self, "no_metric_hosts")

    @no_metric_hosts.setter
    def no_metric_hosts(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_metric_hosts", value)

    @property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of node used. Either "host" or "container".
        """
        return pulumi.get(self, "node_type")

    @node_type.setter
    def node_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_type", value)

    @property
    @pulumi.getter
    def precision(self) -> Optional[pulumi.Input[str]]:
        """
        The precision to use when displaying the value. Use "\*" for maximum precision.
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "precision", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        The list of tags to filter nodes by.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Nested block describing how to display the widget. The structure of this block is described below. At most one such block should be present in a given tile_def block.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "style", value)

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the text in the widget.
        """
        return pulumi.get(self, "text_align")

    @text_align.setter
    def text_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_align", value)


@pulumi.input_type
class ScreenBoardWidgetTileDefEventArgs:
    def __init__(__self__, *,
                 q: pulumi.Input[str]):
        """
        :param pulumi.Input[str] q: The search query for event overlays.
        """
        pulumi.set(__self__, "q", q)

    @property
    @pulumi.getter
    def q(self) -> pulumi.Input[str]:
        """
        The search query for event overlays.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: pulumi.Input[str]):
        pulumi.set(self, "q", value)


@pulumi.input_type
class ScreenBoardWidgetTileDefMarkerArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 value: pulumi.Input[str],
                 label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of the widget. One of "free_text", "timeseries", "query_value", "toplist", "change", "event_timeline", "event_stream", "image", "note", "alert_graph", "alert_value", "iframe", "check_status", "trace_service", "hostmap", "manage_status", "log_stream", or "process".
        :param pulumi.Input[str] value: Mathematical expression describing the marker. Examples: "y > 1", "-5 < y < 0", "y = 19".
        :param pulumi.Input[str] label: A label for the line or range.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the widget. One of "free_text", "timeseries", "query_value", "toplist", "change", "event_timeline", "event_stream", "image", "note", "alert_graph", "alert_value", "iframe", "check_status", "trace_service", "hostmap", "manage_status", "log_stream", or "process".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Mathematical expression describing the marker. Examples: "y > 1", "-5 < y < 0", "y = 19".
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        A label for the line or range.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)


@pulumi.input_type
class ScreenBoardWidgetTileDefRequestArgs:
    def __init__(__self__, *,
                 aggregator: Optional[pulumi.Input[str]] = None,
                 apm_query: Optional[pulumi.Input['ScreenBoardWidgetTileDefRequestApmQueryArgs']] = None,
                 change_type: Optional[pulumi.Input[str]] = None,
                 compare_to: Optional[pulumi.Input[str]] = None,
                 conditional_formats: Optional[pulumi.Input[List[pulumi.Input['ScreenBoardWidgetTileDefRequestConditionalFormatArgs']]]] = None,
                 extra_col: Optional[pulumi.Input[str]] = None,
                 increase_good: Optional[pulumi.Input[bool]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 log_query: Optional[pulumi.Input['ScreenBoardWidgetTileDefRequestLogQueryArgs']] = None,
                 metadata_json: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 order_by: Optional[pulumi.Input[str]] = None,
                 order_dir: Optional[pulumi.Input[str]] = None,
                 process_query: Optional[pulumi.Input['ScreenBoardWidgetTileDefRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 query_type: Optional[pulumi.Input[str]] = None,
                 style: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 tag_filters: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 text_filter: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregator: The aggregator to use for time aggregation. One of "avg", "min", "max", "sum", "last".
        :param pulumi.Input['ScreenBoardWidgetTileDefRequestApmQueryArgs'] apm_query: The APM query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] change_type: Whether to show absolute or relative change. One of "absolute", "relative".
        :param pulumi.Input[str] compare_to: Choose from when to compare current data to. One of "hour_before", "day_before", "week_before" or "month_before".
        :param pulumi.Input[List[pulumi.Input['ScreenBoardWidgetTileDefRequestConditionalFormatArgs']]] conditional_formats: Nested block to customize the style if certain conditions are met. Currently only applies to `Query Value` and `Top List` type graphs.
        :param pulumi.Input[str] extra_col: If set to "present", displays current value. Can be left empty otherwise.
        :param pulumi.Input[bool] increase_good: Boolean indicating whether an increase in the value is good (thus displayed in green) or not (thus displayed in red).
        :param pulumi.Input[float] limit: Integer indicating the number of hosts to limit to.
        :param pulumi.Input['ScreenBoardWidgetTileDefRequestLogQueryArgs'] log_query: The log query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] metadata_json: A JSON blob representing mapping of query expressions to alias names. Note that the query expressions in `metadata_json` will be ignored if they're not present in the query. For example:
        :param pulumi.Input[str] metric: The metric you want to use for the widget.
        :param pulumi.Input[str] order_by: One of "change", "name", "present" (present value) or "past" (past value).
        :param pulumi.Input[str] order_dir: Either "asc" (ascending) or "desc" (descending).
        :param pulumi.Input['ScreenBoardWidgetTileDefRequestProcessQueryArgs'] process_query: The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] q: The search query for event overlays.
        :param pulumi.Input[str] query_type: Use "process".
        :param pulumi.Input[Mapping[str, Any]] style: Nested block describing how to display the widget. The structure of this block is described below. At most one such block should be present in a given tile_def block.
        :param pulumi.Input[List[pulumi.Input[str]]] tag_filters: Tags to use for filtering.
        :param pulumi.Input[str] text_filter: The search query for the widget.
        :param pulumi.Input[str] type: The type of the widget. One of "free_text", "timeseries", "query_value", "toplist", "change", "event_timeline", "event_stream", "image", "note", "alert_graph", "alert_value", "iframe", "check_status", "trace_service", "hostmap", "manage_status", "log_stream", or "process".
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if change_type is not None:
            pulumi.set(__self__, "change_type", change_type)
        if compare_to is not None:
            pulumi.set(__self__, "compare_to", compare_to)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if extra_col is not None:
            pulumi.set(__self__, "extra_col", extra_col)
        if increase_good is not None:
            pulumi.set(__self__, "increase_good", increase_good)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if metadata_json is not None:
            pulumi.set(__self__, "metadata_json", metadata_json)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order_by is not None:
            pulumi.set(__self__, "order_by", order_by)
        if order_dir is not None:
            pulumi.set(__self__, "order_dir", order_dir)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if query_type is not None:
            pulumi.set(__self__, "query_type", query_type)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregator to use for time aggregation. One of "avg", "min", "max", "sum", "last".
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['ScreenBoardWidgetTileDefRequestApmQueryArgs']]:
        """
        The APM query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['ScreenBoardWidgetTileDefRequestApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="changeType")
    def change_type(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to show absolute or relative change. One of "absolute", "relative".
        """
        return pulumi.get(self, "change_type")

    @change_type.setter
    def change_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "change_type", value)

    @property
    @pulumi.getter(name="compareTo")
    def compare_to(self) -> Optional[pulumi.Input[str]]:
        """
        Choose from when to compare current data to. One of "hour_before", "day_before", "week_before" or "month_before".
        """
        return pulumi.get(self, "compare_to")

    @compare_to.setter
    def compare_to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compare_to", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[List[pulumi.Input['ScreenBoardWidgetTileDefRequestConditionalFormatArgs']]]]:
        """
        Nested block to customize the style if certain conditions are met. Currently only applies to `Query Value` and `Top List` type graphs.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[List[pulumi.Input['ScreenBoardWidgetTileDefRequestConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter(name="extraCol")
    def extra_col(self) -> Optional[pulumi.Input[str]]:
        """
        If set to "present", displays current value. Can be left empty otherwise.
        """
        return pulumi.get(self, "extra_col")

    @extra_col.setter
    def extra_col(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "extra_col", value)

    @property
    @pulumi.getter(name="increaseGood")
    def increase_good(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether an increase in the value is good (thus displayed in green) or not (thus displayed in red).
        """
        return pulumi.get(self, "increase_good")

    @increase_good.setter
    def increase_good(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "increase_good", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        Integer indicating the number of hosts to limit to.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['ScreenBoardWidgetTileDefRequestLogQueryArgs']]:
        """
        The log query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['ScreenBoardWidgetTileDefRequestLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="metadataJson")
    def metadata_json(self) -> Optional[pulumi.Input[str]]:
        """
        A JSON blob representing mapping of query expressions to alias names. Note that the query expressions in `metadata_json` will be ignored if they're not present in the query. For example:
        """
        return pulumi.get(self, "metadata_json")

    @metadata_json.setter
    def metadata_json(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metadata_json", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric you want to use for the widget.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="orderBy")
    def order_by(self) -> Optional[pulumi.Input[str]]:
        """
        One of "change", "name", "present" (present value) or "past" (past value).
        """
        return pulumi.get(self, "order_by")

    @order_by.setter
    def order_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order_by", value)

    @property
    @pulumi.getter(name="orderDir")
    def order_dir(self) -> Optional[pulumi.Input[str]]:
        """
        Either "asc" (ascending) or "desc" (descending).
        """
        return pulumi.get(self, "order_dir")

    @order_dir.setter
    def order_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order_dir", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['ScreenBoardWidgetTileDefRequestProcessQueryArgs']]:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['ScreenBoardWidgetTileDefRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        """
        The search query for event overlays.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter(name="queryType")
    def query_type(self) -> Optional[pulumi.Input[str]]:
        """
        Use "process".
        """
        return pulumi.get(self, "query_type")

    @query_type.setter
    def query_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_type", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Nested block describing how to display the widget. The structure of this block is described below. At most one such block should be present in a given tile_def block.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "style", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        Tags to use for filtering.
        """
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[pulumi.Input[str]]:
        """
        The search query for the widget.
        """
        return pulumi.get(self, "text_filter")

    @text_filter.setter
    def text_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_filter", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the widget. One of "free_text", "timeseries", "query_value", "toplist", "change", "event_timeline", "event_stream", "image", "note", "alert_graph", "alert_value", "iframe", "check_status", "trace_service", "hostmap", "manage_status", "log_stream", or "process".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ScreenBoardWidgetTileDefRequestApmQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['ScreenBoardWidgetTileDefRequestApmQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['ScreenBoardWidgetTileDefRequestApmQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['ScreenBoardWidgetTileDefRequestApmQuerySearchArgs']] = None):
        """
        :param pulumi.Input['ScreenBoardWidgetTileDefRequestApmQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['ScreenBoardWidgetTileDefRequestApmQueryGroupByArgs']]] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param pulumi.Input['ScreenBoardWidgetTileDefRequestApmQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['ScreenBoardWidgetTileDefRequestApmQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['ScreenBoardWidgetTileDefRequestApmQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['ScreenBoardWidgetTileDefRequestApmQueryGroupByArgs']]]]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['ScreenBoardWidgetTileDefRequestApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['ScreenBoardWidgetTileDefRequestApmQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['ScreenBoardWidgetTileDefRequestApmQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class ScreenBoardWidgetTileDefRequestApmQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class ScreenBoardWidgetTileDefRequestApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: pulumi.Input[str],
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['ScreenBoardWidgetTileDefRequestApmQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: Integer indicating the number of hosts to limit to.
        :param pulumi.Input['ScreenBoardWidgetTileDefRequestApmQueryGroupBySortArgs'] sort: The method to use to sort monitors. Example: "status,asc".
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> pulumi.Input[str]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: pulumi.Input[str]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        Integer indicating the number of hosts to limit to.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['ScreenBoardWidgetTileDefRequestApmQueryGroupBySortArgs']]:
        """
        The method to use to sort monitors. Example: "status,asc".
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['ScreenBoardWidgetTileDefRequestApmQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class ScreenBoardWidgetTileDefRequestApmQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class ScreenBoardWidgetTileDefRequestApmQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: The query to use in the widget.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The query to use in the widget.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class ScreenBoardWidgetTileDefRequestConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 color: Optional[pulumi.Input[str]] = None,
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 invert: Optional[pulumi.Input[bool]] = None,
                 palette: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: Comparison operator. Example: ">", "<".
        :param pulumi.Input[str] color: Custom color (e.g., #205081).
        :param pulumi.Input[bool] invert: Boolean indicating whether to invert color scheme.
        :param pulumi.Input[str] palette: Color scheme to be used if the condition is met. One of: "red_on_white", "white_on_red", "yellow_on_white", "white_on_yellow", "green_on_white", "white_on_green", "gray_on_white", "white_on_gray", "custom_text", "custom_bg", "custom_image".
        :param pulumi.Input[str] value: Value that is the threshold for the conditional format.
        """
        pulumi.set(__self__, "comparator", comparator)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if invert is not None:
            pulumi.set(__self__, "invert", invert)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        Comparison operator. Example: ">", "<".
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        Custom color (e.g., #205081).
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter
    def invert(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating whether to invert color scheme.
        """
        return pulumi.get(self, "invert")

    @invert.setter
    def invert(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "invert", value)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        Color scheme to be used if the condition is met. One of: "red_on_white", "white_on_red", "yellow_on_white", "white_on_yellow", "green_on_white", "white_on_green", "gray_on_white", "white_on_gray", "custom_text", "custom_bg", "custom_image".
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value that is the threshold for the conditional format.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ScreenBoardWidgetTileDefRequestLogQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['ScreenBoardWidgetTileDefRequestLogQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['ScreenBoardWidgetTileDefRequestLogQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['ScreenBoardWidgetTileDefRequestLogQuerySearchArgs']] = None):
        """
        :param pulumi.Input['ScreenBoardWidgetTileDefRequestLogQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['ScreenBoardWidgetTileDefRequestLogQueryGroupByArgs']]] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param pulumi.Input['ScreenBoardWidgetTileDefRequestLogQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['ScreenBoardWidgetTileDefRequestLogQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['ScreenBoardWidgetTileDefRequestLogQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['ScreenBoardWidgetTileDefRequestLogQueryGroupByArgs']]]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['ScreenBoardWidgetTileDefRequestLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['ScreenBoardWidgetTileDefRequestLogQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['ScreenBoardWidgetTileDefRequestLogQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class ScreenBoardWidgetTileDefRequestLogQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class ScreenBoardWidgetTileDefRequestLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: pulumi.Input[str],
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['ScreenBoardWidgetTileDefRequestLogQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[float] limit: Integer indicating the number of hosts to limit to.
        :param pulumi.Input['ScreenBoardWidgetTileDefRequestLogQueryGroupBySortArgs'] sort: The method to use to sort monitors. Example: "status,asc".
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> pulumi.Input[str]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: pulumi.Input[str]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        Integer indicating the number of hosts to limit to.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['ScreenBoardWidgetTileDefRequestLogQueryGroupBySortArgs']]:
        """
        The method to use to sort monitors. Example: "status,asc".
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['ScreenBoardWidgetTileDefRequestLogQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class ScreenBoardWidgetTileDefRequestLogQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class ScreenBoardWidgetTileDefRequestLogQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: The query to use in the widget.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The query to use in the widget.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class ScreenBoardWidgetTileDefRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric: The metric you want to use for the widget.
        :param pulumi.Input[float] limit: Integer indicating the number of hosts to limit to.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        The metric you want to use for the widget.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        """
        Integer indicating the number of hosts to limit to.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class ServiceLevelObjectiveQueryArgs:
    def __init__(__self__, *,
                 denominator: pulumi.Input[str],
                 numerator: pulumi.Input[str]):
        """
        :param pulumi.Input[str] denominator: the sum of the `total` events
               * Example Usage:
        :param pulumi.Input[str] numerator: the sum of all the `good` events
        """
        pulumi.set(__self__, "denominator", denominator)
        pulumi.set(__self__, "numerator", numerator)

    @property
    @pulumi.getter
    def denominator(self) -> pulumi.Input[str]:
        """
        the sum of the `total` events
        * Example Usage:
        """
        return pulumi.get(self, "denominator")

    @denominator.setter
    def denominator(self, value: pulumi.Input[str]):
        pulumi.set(self, "denominator", value)

    @property
    @pulumi.getter
    def numerator(self) -> pulumi.Input[str]:
        """
        the sum of all the `good` events
        """
        return pulumi.get(self, "numerator")

    @numerator.setter
    def numerator(self, value: pulumi.Input[str]):
        pulumi.set(self, "numerator", value)


@pulumi.input_type
class ServiceLevelObjectiveThresholdArgs:
    def __init__(__self__, *,
                 target: pulumi.Input[float],
                 timeframe: pulumi.Input[str],
                 target_display: Optional[pulumi.Input[str]] = None,
                 warning: Optional[pulumi.Input[float]] = None,
                 warning_display: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] target: the objective's target `[0,100]`
        :param pulumi.Input[str] timeframe: the time frame for the objective. The mapping from these types to the types found in the Datadog Web UI can be found in the Datadog API [documentation](https://docs.datadoghq.com/api/v1/service-level-objectives/#create-a-slo-object) page. Available options to choose from are:
               * `7d`
               * `30d`
               * `90d`
        :param pulumi.Input[str] target_display: the string version to specify additional digits in the case of `99` but want 3 digits like `99.000` to display.
        :param pulumi.Input[float] warning: the objective's warning value `[0,100]`. This must be `> target` value.
        :param pulumi.Input[str] warning_display: the string version to specify additional digits in the case of `99` but want 3 digits like `99.000` to display.
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "timeframe", timeframe)
        if target_display is not None:
            pulumi.set(__self__, "target_display", target_display)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)
        if warning_display is not None:
            pulumi.set(__self__, "warning_display", warning_display)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[float]:
        """
        the objective's target `[0,100]`
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[float]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def timeframe(self) -> pulumi.Input[str]:
        """
        the time frame for the objective. The mapping from these types to the types found in the Datadog Web UI can be found in the Datadog API [documentation](https://docs.datadoghq.com/api/v1/service-level-objectives/#create-a-slo-object) page. Available options to choose from are:
        * `7d`
        * `30d`
        * `90d`
        """
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: pulumi.Input[str]):
        pulumi.set(self, "timeframe", value)

    @property
    @pulumi.getter(name="targetDisplay")
    def target_display(self) -> Optional[pulumi.Input[str]]:
        """
        the string version to specify additional digits in the case of `99` but want 3 digits like `99.000` to display.
        """
        return pulumi.get(self, "target_display")

    @target_display.setter
    def target_display(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_display", value)

    @property
    @pulumi.getter
    def warning(self) -> Optional[pulumi.Input[float]]:
        """
        the objective's warning value `[0,100]`. This must be `> target` value.
        """
        return pulumi.get(self, "warning")

    @warning.setter
    def warning(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "warning", value)

    @property
    @pulumi.getter(name="warningDisplay")
    def warning_display(self) -> Optional[pulumi.Input[str]]:
        """
        the string version to specify additional digits in the case of `99` but want 3 digits like `99.000` to display.
        """
        return pulumi.get(self, "warning_display")

    @warning_display.setter
    def warning_display(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "warning_display", value)


@pulumi.input_type
class SyntheticsTestOptionsArgs:
    def __init__(__self__, *,
                 tick_every: pulumi.Input[float],
                 accept_self_signed: Optional[pulumi.Input[bool]] = None,
                 allow_insecure: Optional[pulumi.Input[bool]] = None,
                 follow_redirects: Optional[pulumi.Input[bool]] = None,
                 min_failure_duration: Optional[pulumi.Input[float]] = None,
                 min_location_failed: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] tick_every: How often the test should run (in seconds). Current possible values are 900, 1800, 3600, 21600, 43200, 86400, 604800 plus 60 if type=api or 300 if type=browser
        :param pulumi.Input[bool] accept_self_signed: For type=ssl, true or false
        :param pulumi.Input[bool] allow_insecure: For type=api, true or false. Allow your HTTP test go on with connection even if there is an error when validating the certificate.
        :param pulumi.Input[bool] follow_redirects: For type=api, true or false
        :param pulumi.Input[float] min_failure_duration: How long the test should be in failure before alerting (integer, number of seconds, max 7200). Default is 0.
        :param pulumi.Input[float] min_location_failed: Threshold below which a synthetics test is allowed to fail before sending notifications
        """
        pulumi.set(__self__, "tick_every", tick_every)
        if accept_self_signed is not None:
            pulumi.set(__self__, "accept_self_signed", accept_self_signed)
        if allow_insecure is not None:
            pulumi.set(__self__, "allow_insecure", allow_insecure)
        if follow_redirects is not None:
            pulumi.set(__self__, "follow_redirects", follow_redirects)
        if min_failure_duration is not None:
            pulumi.set(__self__, "min_failure_duration", min_failure_duration)
        if min_location_failed is not None:
            pulumi.set(__self__, "min_location_failed", min_location_failed)

    @property
    @pulumi.getter(name="tickEvery")
    def tick_every(self) -> pulumi.Input[float]:
        """
        How often the test should run (in seconds). Current possible values are 900, 1800, 3600, 21600, 43200, 86400, 604800 plus 60 if type=api or 300 if type=browser
        """
        return pulumi.get(self, "tick_every")

    @tick_every.setter
    def tick_every(self, value: pulumi.Input[float]):
        pulumi.set(self, "tick_every", value)

    @property
    @pulumi.getter(name="acceptSelfSigned")
    def accept_self_signed(self) -> Optional[pulumi.Input[bool]]:
        """
        For type=ssl, true or false
        """
        return pulumi.get(self, "accept_self_signed")

    @accept_self_signed.setter
    def accept_self_signed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "accept_self_signed", value)

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> Optional[pulumi.Input[bool]]:
        """
        For type=api, true or false. Allow your HTTP test go on with connection even if there is an error when validating the certificate.
        """
        return pulumi.get(self, "allow_insecure")

    @allow_insecure.setter
    def allow_insecure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_insecure", value)

    @property
    @pulumi.getter(name="followRedirects")
    def follow_redirects(self) -> Optional[pulumi.Input[bool]]:
        """
        For type=api, true or false
        """
        return pulumi.get(self, "follow_redirects")

    @follow_redirects.setter
    def follow_redirects(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "follow_redirects", value)

    @property
    @pulumi.getter(name="minFailureDuration")
    def min_failure_duration(self) -> Optional[pulumi.Input[float]]:
        """
        How long the test should be in failure before alerting (integer, number of seconds, max 7200). Default is 0.
        """
        return pulumi.get(self, "min_failure_duration")

    @min_failure_duration.setter
    def min_failure_duration(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_failure_duration", value)

    @property
    @pulumi.getter(name="minLocationFailed")
    def min_location_failed(self) -> Optional[pulumi.Input[float]]:
        """
        Threshold below which a synthetics test is allowed to fail before sending notifications
        """
        return pulumi.get(self, "min_location_failed")

    @min_location_failed.setter
    def min_location_failed(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_location_failed", value)


@pulumi.input_type
class SyntheticsTestRequestArgs:
    def __init__(__self__, *,
                 body: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 method: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[float]] = None,
                 timeout: Optional[pulumi.Input[float]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] body: Request body
        :param pulumi.Input[str] host: host name
        :param pulumi.Input[str] method: no-op, use GET
        :param pulumi.Input[float] port: port number
        :param pulumi.Input[float] timeout: For type=api, any value between 0 and 60 (Default = 60)
        :param pulumi.Input[str] url: Any url
        """
        if body is not None:
            pulumi.set(__self__, "body", body)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[str]]:
        """
        Request body
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        host name
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        no-op, use GET
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[float]]:
        """
        port number
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[float]]:
        """
        For type=api, any value between 0 and 60 (Default = 60)
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        Any url
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class SyntheticsTestRequestBasicauthArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: Password for authentication
        :param pulumi.Input[str] username: Username for authentication
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Password for authentication
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Username for authentication
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class TimeBoardGraphArgs:
    def __init__(__self__, *,
                 requests: pulumi.Input[List[pulumi.Input['TimeBoardGraphRequestArgs']]],
                 title: pulumi.Input[str],
                 viz: pulumi.Input[str],
                 autoscale: Optional[pulumi.Input[bool]] = None,
                 custom_unit: Optional[pulumi.Input[str]] = None,
                 events: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 groups: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 include_no_metric_hosts: Optional[pulumi.Input[bool]] = None,
                 include_ungrouped_hosts: Optional[pulumi.Input[bool]] = None,
                 markers: Optional[pulumi.Input[List[pulumi.Input['TimeBoardGraphMarkerArgs']]]] = None,
                 node_type: Optional[pulumi.Input[str]] = None,
                 precision: Optional[pulumi.Input[str]] = None,
                 scopes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 style: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 text_align: Optional[pulumi.Input[str]] = None,
                 yaxis: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        :param pulumi.Input[List[pulumi.Input['TimeBoardGraphRequestArgs']]] requests: Nested block describing a graph definition request (a metric query to plot on the graph). The structure of this block is described below. Multiple request blocks are allowed within a graph block.
        :param pulumi.Input[str] title: The name of the graph.
        :param pulumi.Input[str] viz: The type of visualization to use for the graph. Valid choices are "change", "distribution", "heatmap", "hostmap", "query_value", timeseries", and "toplist".
        :param pulumi.Input[bool] autoscale: Boolean that determines whether to autoscale graphs.
        :param pulumi.Input[str] custom_unit: Display a custom unit on the graph (such as 'hertz')
        :param pulumi.Input[List[pulumi.Input[str]]] events: A list of event filter strings. Note that, while supported by the Datadog API, the Datadog UI does not (currently) support multiple event filters very well, so use at your own risk.
        :param pulumi.Input[List[pulumi.Input[str]]] groups: List of groups for hostmaps (shown as 'group by' in the UI).
        :param pulumi.Input[bool] include_no_metric_hosts: If set to true, will display hosts on hostmap that have no reported metrics.
        :param pulumi.Input[bool] include_ungrouped_hosts: If set to true, will display hosts without groups on hostmaps.
        :param pulumi.Input[List[pulumi.Input['TimeBoardGraphMarkerArgs']]] markers: Nested block describing lines / ranges added to graph for formatting. The structure of this block is described below. Multiple marker blocks are allowed within a graph block.
        :param pulumi.Input[str] node_type: What nodes to display in a hostmap. Can be one of 'host' (default) or 'container'.
        :param pulumi.Input[str] precision: Number of digits displayed, use `*` for full precision.
        :param pulumi.Input[List[pulumi.Input[str]]] scopes: List of scopes for hostmaps (shown as 'filter by' in the UI).
        :param pulumi.Input[Mapping[str, Any]] style: Nested block to customize the graph style.
        :param pulumi.Input[str] text_align: How to align text in the graph, can be one of 'left', 'center', or 'right'.
        :param pulumi.Input[Mapping[str, Any]] yaxis: Nested block describing modifications to the yaxis rendering. The structure of this block is described below.
        """
        pulumi.set(__self__, "requests", requests)
        pulumi.set(__self__, "title", title)
        pulumi.set(__self__, "viz", viz)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if custom_unit is not None:
            pulumi.set(__self__, "custom_unit", custom_unit)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if include_no_metric_hosts is not None:
            pulumi.set(__self__, "include_no_metric_hosts", include_no_metric_hosts)
        if include_ungrouped_hosts is not None:
            pulumi.set(__self__, "include_ungrouped_hosts", include_ungrouped_hosts)
        if markers is not None:
            pulumi.set(__self__, "markers", markers)
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter
    def requests(self) -> pulumi.Input[List[pulumi.Input['TimeBoardGraphRequestArgs']]]:
        """
        Nested block describing a graph definition request (a metric query to plot on the graph). The structure of this block is described below. Multiple request blocks are allowed within a graph block.
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: pulumi.Input[List[pulumi.Input['TimeBoardGraphRequestArgs']]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        """
        The name of the graph.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def viz(self) -> pulumi.Input[str]:
        """
        The type of visualization to use for the graph. Valid choices are "change", "distribution", "heatmap", "hostmap", "query_value", timeseries", and "toplist".
        """
        return pulumi.get(self, "viz")

    @viz.setter
    def viz(self, value: pulumi.Input[str]):
        pulumi.set(self, "viz", value)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean that determines whether to autoscale graphs.
        """
        return pulumi.get(self, "autoscale")

    @autoscale.setter
    def autoscale(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "autoscale", value)

    @property
    @pulumi.getter(name="customUnit")
    def custom_unit(self) -> Optional[pulumi.Input[str]]:
        """
        Display a custom unit on the graph (such as 'hertz')
        """
        return pulumi.get(self, "custom_unit")

    @custom_unit.setter
    def custom_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_unit", value)

    @property
    @pulumi.getter
    def events(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        A list of event filter strings. Note that, while supported by the Datadog API, the Datadog UI does not (currently) support multiple event filters very well, so use at your own risk.
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "events", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        List of groups for hostmaps (shown as 'group by' in the UI).
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter(name="includeNoMetricHosts")
    def include_no_metric_hosts(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, will display hosts on hostmap that have no reported metrics.
        """
        return pulumi.get(self, "include_no_metric_hosts")

    @include_no_metric_hosts.setter
    def include_no_metric_hosts(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_no_metric_hosts", value)

    @property
    @pulumi.getter(name="includeUngroupedHosts")
    def include_ungrouped_hosts(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, will display hosts without groups on hostmaps.
        """
        return pulumi.get(self, "include_ungrouped_hosts")

    @include_ungrouped_hosts.setter
    def include_ungrouped_hosts(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_ungrouped_hosts", value)

    @property
    @pulumi.getter
    def markers(self) -> Optional[pulumi.Input[List[pulumi.Input['TimeBoardGraphMarkerArgs']]]]:
        """
        Nested block describing lines / ranges added to graph for formatting. The structure of this block is described below. Multiple marker blocks are allowed within a graph block.
        """
        return pulumi.get(self, "markers")

    @markers.setter
    def markers(self, value: Optional[pulumi.Input[List[pulumi.Input['TimeBoardGraphMarkerArgs']]]]):
        pulumi.set(self, "markers", value)

    @property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[pulumi.Input[str]]:
        """
        What nodes to display in a hostmap. Can be one of 'host' (default) or 'container'.
        """
        return pulumi.get(self, "node_type")

    @node_type.setter
    def node_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_type", value)

    @property
    @pulumi.getter
    def precision(self) -> Optional[pulumi.Input[str]]:
        """
        Number of digits displayed, use `*` for full precision.
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "precision", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        List of scopes for hostmaps (shown as 'filter by' in the UI).
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Nested block to customize the graph style.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "style", value)

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[pulumi.Input[str]]:
        """
        How to align text in the graph, can be one of 'left', 'center', or 'right'.
        """
        return pulumi.get(self, "text_align")

    @text_align.setter
    def text_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_align", value)

    @property
    @pulumi.getter
    def yaxis(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Nested block describing modifications to the yaxis rendering. The structure of this block is described below.
        """
        return pulumi.get(self, "yaxis")

    @yaxis.setter
    def yaxis(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "yaxis", value)


@pulumi.input_type
class TimeBoardGraphMarkerArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 value: pulumi.Input[str],
                 label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: How the marker lines will look. Possible values are {"error", "warning", "info", "ok"} {"dashed", "solid", "bold"}. Example: "error dashed".
        :param pulumi.Input[str] value: Mathematical expression describing the marker. Examples: "y > 1", "-5 < y < 0", "y = 19".
        :param pulumi.Input[str] label: A label for the line or range. **Warning:** when a label is enabled but left empty through the UI, the Datadog API returns a boolean value, not a string. This makes `pulumi up` fail with a JSON decoding error.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        How the marker lines will look. Possible values are {"error", "warning", "info", "ok"} {"dashed", "solid", "bold"}. Example: "error dashed".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Mathematical expression describing the marker. Examples: "y > 1", "-5 < y < 0", "y = 19".
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        A label for the line or range. **Warning:** when a label is enabled but left empty through the UI, the Datadog API returns a boolean value, not a string. This makes `pulumi up` fail with a JSON decoding error.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)


@pulumi.input_type
class TimeBoardGraphRequestArgs:
    def __init__(__self__, *,
                 aggregator: Optional[pulumi.Input[str]] = None,
                 apm_query: Optional[pulumi.Input['TimeBoardGraphRequestApmQueryArgs']] = None,
                 change_type: Optional[pulumi.Input[str]] = None,
                 compare_to: Optional[pulumi.Input[str]] = None,
                 conditional_formats: Optional[pulumi.Input[List[pulumi.Input['TimeBoardGraphRequestConditionalFormatArgs']]]] = None,
                 extra_col: Optional[pulumi.Input[str]] = None,
                 increase_good: Optional[pulumi.Input[bool]] = None,
                 log_query: Optional[pulumi.Input['TimeBoardGraphRequestLogQueryArgs']] = None,
                 metadata_json: Optional[pulumi.Input[str]] = None,
                 order_by: Optional[pulumi.Input[str]] = None,
                 order_direction: Optional[pulumi.Input[str]] = None,
                 process_query: Optional[pulumi.Input['TimeBoardGraphRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 stacked: Optional[pulumi.Input[bool]] = None,
                 style: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregator: The aggregation method used when the number of data points outnumbers the max that can be shown.
        :param pulumi.Input['TimeBoardGraphRequestApmQueryArgs'] apm_query: The APM query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[List[pulumi.Input['TimeBoardGraphRequestConditionalFormatArgs']]] conditional_formats: Nested block to customize the graph style if certain conditions are met. Currently only applies to `Query Value` and `Top List` type graphs.
        :param pulumi.Input[str] extra_col: If set to "present", displays current value. Can be left empty otherwise.
        :param pulumi.Input['TimeBoardGraphRequestLogQueryArgs'] log_query: The log query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] metadata_json: A JSON blob representing mapping of query expressions to alias names. Note that the query expressions in `metadata_json` will be ignored if they're not present in the query. For example:
        :param pulumi.Input['TimeBoardGraphRequestProcessQueryArgs'] process_query: The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] q: The query of the request. Pro tip: Use the JSON tab inside the Datadog UI to help build you query strings.
        :param pulumi.Input[bool] stacked: Boolean value to determine if this is this a stacked area graph. Default: false (line chart).
        :param pulumi.Input[Mapping[str, Any]] style: Nested block describing hostmaps. The structure of this block is described below.
        :param pulumi.Input[str] type: How the marker lines will look. Possible values are {"error", "warning", "info", "ok"} {"dashed", "solid", "bold"}. Example: "error dashed".
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if change_type is not None:
            pulumi.set(__self__, "change_type", change_type)
        if compare_to is not None:
            pulumi.set(__self__, "compare_to", compare_to)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if extra_col is not None:
            pulumi.set(__self__, "extra_col", extra_col)
        if increase_good is not None:
            pulumi.set(__self__, "increase_good", increase_good)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if metadata_json is not None:
            pulumi.set(__self__, "metadata_json", metadata_json)
        if order_by is not None:
            pulumi.set(__self__, "order_by", order_by)
        if order_direction is not None:
            pulumi.set(__self__, "order_direction", order_direction)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if stacked is not None:
            pulumi.set(__self__, "stacked", stacked)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation method used when the number of data points outnumbers the max that can be shown.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['TimeBoardGraphRequestApmQueryArgs']]:
        """
        The APM query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['TimeBoardGraphRequestApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="changeType")
    def change_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "change_type")

    @change_type.setter
    def change_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "change_type", value)

    @property
    @pulumi.getter(name="compareTo")
    def compare_to(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "compare_to")

    @compare_to.setter
    def compare_to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compare_to", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[List[pulumi.Input['TimeBoardGraphRequestConditionalFormatArgs']]]]:
        """
        Nested block to customize the graph style if certain conditions are met. Currently only applies to `Query Value` and `Top List` type graphs.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[List[pulumi.Input['TimeBoardGraphRequestConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter(name="extraCol")
    def extra_col(self) -> Optional[pulumi.Input[str]]:
        """
        If set to "present", displays current value. Can be left empty otherwise.
        """
        return pulumi.get(self, "extra_col")

    @extra_col.setter
    def extra_col(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "extra_col", value)

    @property
    @pulumi.getter(name="increaseGood")
    def increase_good(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "increase_good")

    @increase_good.setter
    def increase_good(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "increase_good", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['TimeBoardGraphRequestLogQueryArgs']]:
        """
        The log query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['TimeBoardGraphRequestLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="metadataJson")
    def metadata_json(self) -> Optional[pulumi.Input[str]]:
        """
        A JSON blob representing mapping of query expressions to alias names. Note that the query expressions in `metadata_json` will be ignored if they're not present in the query. For example:
        """
        return pulumi.get(self, "metadata_json")

    @metadata_json.setter
    def metadata_json(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metadata_json", value)

    @property
    @pulumi.getter(name="orderBy")
    def order_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "order_by")

    @order_by.setter
    def order_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order_by", value)

    @property
    @pulumi.getter(name="orderDirection")
    def order_direction(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "order_direction")

    @order_direction.setter
    def order_direction(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order_direction", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['TimeBoardGraphRequestProcessQueryArgs']]:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['TimeBoardGraphRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        """
        The query of the request. Pro tip: Use the JSON tab inside the Datadog UI to help build you query strings.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter
    def stacked(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean value to determine if this is this a stacked area graph. Default: false (line chart).
        """
        return pulumi.get(self, "stacked")

    @stacked.setter
    def stacked(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "stacked", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Nested block describing hostmaps. The structure of this block is described below.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "style", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        How the marker lines will look. Possible values are {"error", "warning", "info", "ok"} {"dashed", "solid", "bold"}. Example: "error dashed".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class TimeBoardGraphRequestApmQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['TimeBoardGraphRequestApmQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['TimeBoardGraphRequestApmQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['TimeBoardGraphRequestApmQuerySearchArgs']] = None):
        """
        :param pulumi.Input['TimeBoardGraphRequestApmQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['TimeBoardGraphRequestApmQueryGroupByArgs']]] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param pulumi.Input['TimeBoardGraphRequestApmQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['TimeBoardGraphRequestApmQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['TimeBoardGraphRequestApmQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['TimeBoardGraphRequestApmQueryGroupByArgs']]]]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['TimeBoardGraphRequestApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['TimeBoardGraphRequestApmQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['TimeBoardGraphRequestApmQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class TimeBoardGraphRequestApmQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class TimeBoardGraphRequestApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: pulumi.Input[str],
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['TimeBoardGraphRequestApmQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input['TimeBoardGraphRequestApmQueryGroupBySortArgs'] sort: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> pulumi.Input[str]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: pulumi.Input[str]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['TimeBoardGraphRequestApmQueryGroupBySortArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['TimeBoardGraphRequestApmQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class TimeBoardGraphRequestApmQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class TimeBoardGraphRequestApmQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class TimeBoardGraphRequestConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 palette: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: Comparison operator. Example: ">", "<".
        :param pulumi.Input[str] custom_bg_color: Used when `palette` is set to `custom_bg`. Set the color of the background to a custom web color, such as "#205081".
        :param pulumi.Input[str] custom_fg_color: Used when `palette` is set to `custom_text`. Set the color of the text to a custom web color, such as "#205081".
        :param pulumi.Input[str] palette: Color scheme to be used if the condition is met. For example: "red_on_white", "white_on_red", "yellow_on_white", "white_on_yellow", "green_on_white", "white_on_green", "gray_on_white", "white_on_gray", "custom_text", "custom_bg", "custom_image".
        :param pulumi.Input[str] value: Value that is the threshold for the conditional format.
        """
        pulumi.set(__self__, "comparator", comparator)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        Comparison operator. Example: ">", "<".
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        Used when `palette` is set to `custom_bg`. Set the color of the background to a custom web color, such as "#205081".
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        Used when `palette` is set to `custom_text`. Set the color of the text to a custom web color, such as "#205081".
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        Color scheme to be used if the condition is met. For example: "red_on_white", "white_on_red", "yellow_on_white", "white_on_yellow", "green_on_white", "white_on_green", "gray_on_white", "white_on_gray", "custom_text", "custom_bg", "custom_image".
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value that is the threshold for the conditional format.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class TimeBoardGraphRequestLogQueryArgs:
    def __init__(__self__, *,
                 compute: pulumi.Input['TimeBoardGraphRequestLogQueryComputeArgs'],
                 index: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[List[pulumi.Input['TimeBoardGraphRequestLogQueryGroupByArgs']]]] = None,
                 search: Optional[pulumi.Input['TimeBoardGraphRequestLogQuerySearchArgs']] = None):
        """
        :param pulumi.Input['TimeBoardGraphRequestLogQueryComputeArgs'] compute: . Exactly one nested block is required with the following structure:
        :param pulumi.Input[List[pulumi.Input['TimeBoardGraphRequestLogQueryGroupByArgs']]] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param pulumi.Input['TimeBoardGraphRequestLogQuerySearchArgs'] search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> pulumi.Input['TimeBoardGraphRequestLogQueryComputeArgs']:
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: pulumi.Input['TimeBoardGraphRequestLogQueryComputeArgs']):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[List[pulumi.Input['TimeBoardGraphRequestLogQueryGroupByArgs']]]]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[List[pulumi.Input['TimeBoardGraphRequestLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['TimeBoardGraphRequestLogQuerySearchArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['TimeBoardGraphRequestLogQuerySearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class TimeBoardGraphRequestLogQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class TimeBoardGraphRequestLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: pulumi.Input[str],
                 limit: Optional[pulumi.Input[float]] = None,
                 sort: Optional[pulumi.Input['TimeBoardGraphRequestLogQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input['TimeBoardGraphRequestLogQueryGroupBySortArgs'] sort: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> pulumi.Input[str]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: pulumi.Input[str]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['TimeBoardGraphRequestLogQueryGroupBySortArgs']]:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['TimeBoardGraphRequestLogQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class TimeBoardGraphRequestLogQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class TimeBoardGraphRequestLogQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class TimeBoardGraphRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[float]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class TimeBoardTemplateVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 default: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The variable name. Can be referenced as \$name in `graph` `request` `q` query strings.
        :param pulumi.Input[str] default: The default tag. Default: "\*" (match all).
        :param pulumi.Input[str] prefix: The tag group. Default: no tag group.
        """
        pulumi.set(__self__, "name", name)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The variable name. Can be referenced as \$name in `graph` `request` `q` query strings.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[str]]:
        """
        The default tag. Default: "\*" (match all).
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The tag group. Default: no tag group.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


