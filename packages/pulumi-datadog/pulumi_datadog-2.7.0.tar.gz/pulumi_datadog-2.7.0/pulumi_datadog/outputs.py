# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Dict, List, Mapping, Optional, Tuple, Union
from . import _utilities, _tables
from . import outputs

__all__ = [
    'DashboardListDashItem',
    'DashboardTemplateVariable',
    'DashboardTemplateVariablePreset',
    'DashboardTemplateVariablePresetTemplateVariable',
    'DashboardWidget',
    'DashboardWidgetAlertGraphDefinition',
    'DashboardWidgetAlertGraphDefinitionTime',
    'DashboardWidgetAlertValueDefinition',
    'DashboardWidgetChangeDefinition',
    'DashboardWidgetChangeDefinitionRequest',
    'DashboardWidgetChangeDefinitionRequestApmQuery',
    'DashboardWidgetChangeDefinitionRequestApmQueryCompute',
    'DashboardWidgetChangeDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetChangeDefinitionRequestApmQueryGroupBySort',
    'DashboardWidgetChangeDefinitionRequestApmQuerySearch',
    'DashboardWidgetChangeDefinitionRequestLogQuery',
    'DashboardWidgetChangeDefinitionRequestLogQueryCompute',
    'DashboardWidgetChangeDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetChangeDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetChangeDefinitionRequestLogQuerySearch',
    'DashboardWidgetChangeDefinitionRequestProcessQuery',
    'DashboardWidgetChangeDefinitionTime',
    'DashboardWidgetCheckStatusDefinition',
    'DashboardWidgetCheckStatusDefinitionTime',
    'DashboardWidgetDistributionDefinition',
    'DashboardWidgetDistributionDefinitionRequest',
    'DashboardWidgetDistributionDefinitionRequestApmQuery',
    'DashboardWidgetDistributionDefinitionRequestApmQueryCompute',
    'DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySort',
    'DashboardWidgetDistributionDefinitionRequestApmQuerySearch',
    'DashboardWidgetDistributionDefinitionRequestLogQuery',
    'DashboardWidgetDistributionDefinitionRequestLogQueryCompute',
    'DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetDistributionDefinitionRequestLogQuerySearch',
    'DashboardWidgetDistributionDefinitionRequestProcessQuery',
    'DashboardWidgetDistributionDefinitionRequestStyle',
    'DashboardWidgetDistributionDefinitionTime',
    'DashboardWidgetEventStreamDefinition',
    'DashboardWidgetEventStreamDefinitionTime',
    'DashboardWidgetEventTimelineDefinition',
    'DashboardWidgetEventTimelineDefinitionTime',
    'DashboardWidgetFreeTextDefinition',
    'DashboardWidgetGroupDefinition',
    'DashboardWidgetGroupDefinitionWidget',
    'DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition',
    'DashboardWidgetGroupDefinitionWidgetAlertGraphDefinitionTime',
    'DashboardWidgetGroupDefinitionWidgetAlertValueDefinition',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinition',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionTime',
    'DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition',
    'DashboardWidgetGroupDefinitionWidgetCheckStatusDefinitionTime',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinition',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyle',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionTime',
    'DashboardWidgetGroupDefinitionWidgetEventStreamDefinition',
    'DashboardWidgetGroupDefinitionWidgetEventStreamDefinitionTime',
    'DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition',
    'DashboardWidgetGroupDefinitionWidgetEventTimelineDefinitionTime',
    'DashboardWidgetGroupDefinitionWidgetFreeTextDefinition',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinition',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyle',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionTime',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinition',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle',
    'DashboardWidgetGroupDefinitionWidgetIframeDefinition',
    'DashboardWidgetGroupDefinitionWidgetImageDefinition',
    'DashboardWidgetGroupDefinitionWidgetLayout',
    'DashboardWidgetGroupDefinitionWidgetLogStreamDefinition',
    'DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSort',
    'DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionTime',
    'DashboardWidgetGroupDefinitionWidgetManageStatusDefinition',
    'DashboardWidgetGroupDefinitionWidgetNoteDefinition',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinition',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormat',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionTime',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinition',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormat',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTime',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinition',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionTime',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis',
    'DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition',
    'DashboardWidgetGroupDefinitionWidgetServicemapDefinition',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionTime',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinition',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormat',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyle',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionTime',
    'DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition',
    'DashboardWidgetGroupDefinitionWidgetTraceServiceDefinitionTime',
    'DashboardWidgetHeatmapDefinition',
    'DashboardWidgetHeatmapDefinitionEvent',
    'DashboardWidgetHeatmapDefinitionRequest',
    'DashboardWidgetHeatmapDefinitionRequestApmQuery',
    'DashboardWidgetHeatmapDefinitionRequestApmQueryCompute',
    'DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySort',
    'DashboardWidgetHeatmapDefinitionRequestApmQuerySearch',
    'DashboardWidgetHeatmapDefinitionRequestLogQuery',
    'DashboardWidgetHeatmapDefinitionRequestLogQueryCompute',
    'DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetHeatmapDefinitionRequestLogQuerySearch',
    'DashboardWidgetHeatmapDefinitionRequestProcessQuery',
    'DashboardWidgetHeatmapDefinitionRequestStyle',
    'DashboardWidgetHeatmapDefinitionTime',
    'DashboardWidgetHeatmapDefinitionYaxis',
    'DashboardWidgetHostmapDefinition',
    'DashboardWidgetHostmapDefinitionRequest',
    'DashboardWidgetHostmapDefinitionRequestFill',
    'DashboardWidgetHostmapDefinitionRequestFillApmQuery',
    'DashboardWidgetHostmapDefinitionRequestFillApmQueryCompute',
    'DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy',
    'DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySort',
    'DashboardWidgetHostmapDefinitionRequestFillApmQuerySearch',
    'DashboardWidgetHostmapDefinitionRequestFillLogQuery',
    'DashboardWidgetHostmapDefinitionRequestFillLogQueryCompute',
    'DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy',
    'DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySort',
    'DashboardWidgetHostmapDefinitionRequestFillLogQuerySearch',
    'DashboardWidgetHostmapDefinitionRequestFillProcessQuery',
    'DashboardWidgetHostmapDefinitionRequestSize',
    'DashboardWidgetHostmapDefinitionRequestSizeApmQuery',
    'DashboardWidgetHostmapDefinitionRequestSizeApmQueryCompute',
    'DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy',
    'DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySort',
    'DashboardWidgetHostmapDefinitionRequestSizeApmQuerySearch',
    'DashboardWidgetHostmapDefinitionRequestSizeLogQuery',
    'DashboardWidgetHostmapDefinitionRequestSizeLogQueryCompute',
    'DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy',
    'DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySort',
    'DashboardWidgetHostmapDefinitionRequestSizeLogQuerySearch',
    'DashboardWidgetHostmapDefinitionRequestSizeProcessQuery',
    'DashboardWidgetHostmapDefinitionStyle',
    'DashboardWidgetIframeDefinition',
    'DashboardWidgetImageDefinition',
    'DashboardWidgetLayout',
    'DashboardWidgetLogStreamDefinition',
    'DashboardWidgetLogStreamDefinitionSort',
    'DashboardWidgetLogStreamDefinitionTime',
    'DashboardWidgetManageStatusDefinition',
    'DashboardWidgetNoteDefinition',
    'DashboardWidgetQueryTableDefinition',
    'DashboardWidgetQueryTableDefinitionRequest',
    'DashboardWidgetQueryTableDefinitionRequestApmQuery',
    'DashboardWidgetQueryTableDefinitionRequestApmQueryCompute',
    'DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySort',
    'DashboardWidgetQueryTableDefinitionRequestApmQuerySearch',
    'DashboardWidgetQueryTableDefinitionRequestConditionalFormat',
    'DashboardWidgetQueryTableDefinitionRequestLogQuery',
    'DashboardWidgetQueryTableDefinitionRequestLogQueryCompute',
    'DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetQueryTableDefinitionRequestLogQuerySearch',
    'DashboardWidgetQueryTableDefinitionRequestProcessQuery',
    'DashboardWidgetQueryTableDefinitionTime',
    'DashboardWidgetQueryValueDefinition',
    'DashboardWidgetQueryValueDefinitionRequest',
    'DashboardWidgetQueryValueDefinitionRequestApmQuery',
    'DashboardWidgetQueryValueDefinitionRequestApmQueryCompute',
    'DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySort',
    'DashboardWidgetQueryValueDefinitionRequestApmQuerySearch',
    'DashboardWidgetQueryValueDefinitionRequestConditionalFormat',
    'DashboardWidgetQueryValueDefinitionRequestLogQuery',
    'DashboardWidgetQueryValueDefinitionRequestLogQueryCompute',
    'DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetQueryValueDefinitionRequestLogQuerySearch',
    'DashboardWidgetQueryValueDefinitionRequestProcessQuery',
    'DashboardWidgetQueryValueDefinitionTime',
    'DashboardWidgetScatterplotDefinition',
    'DashboardWidgetScatterplotDefinitionRequest',
    'DashboardWidgetScatterplotDefinitionRequestX',
    'DashboardWidgetScatterplotDefinitionRequestXApmQuery',
    'DashboardWidgetScatterplotDefinitionRequestXApmQueryCompute',
    'DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy',
    'DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySort',
    'DashboardWidgetScatterplotDefinitionRequestXApmQuerySearch',
    'DashboardWidgetScatterplotDefinitionRequestXLogQuery',
    'DashboardWidgetScatterplotDefinitionRequestXLogQueryCompute',
    'DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy',
    'DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySort',
    'DashboardWidgetScatterplotDefinitionRequestXLogQuerySearch',
    'DashboardWidgetScatterplotDefinitionRequestXProcessQuery',
    'DashboardWidgetScatterplotDefinitionRequestY',
    'DashboardWidgetScatterplotDefinitionRequestYApmQuery',
    'DashboardWidgetScatterplotDefinitionRequestYApmQueryCompute',
    'DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy',
    'DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySort',
    'DashboardWidgetScatterplotDefinitionRequestYApmQuerySearch',
    'DashboardWidgetScatterplotDefinitionRequestYLogQuery',
    'DashboardWidgetScatterplotDefinitionRequestYLogQueryCompute',
    'DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy',
    'DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySort',
    'DashboardWidgetScatterplotDefinitionRequestYLogQuerySearch',
    'DashboardWidgetScatterplotDefinitionRequestYProcessQuery',
    'DashboardWidgetScatterplotDefinitionTime',
    'DashboardWidgetScatterplotDefinitionXaxis',
    'DashboardWidgetScatterplotDefinitionYaxis',
    'DashboardWidgetServiceLevelObjectiveDefinition',
    'DashboardWidgetServicemapDefinition',
    'DashboardWidgetTimeseriesDefinition',
    'DashboardWidgetTimeseriesDefinitionEvent',
    'DashboardWidgetTimeseriesDefinitionMarker',
    'DashboardWidgetTimeseriesDefinitionRequest',
    'DashboardWidgetTimeseriesDefinitionRequestApmQuery',
    'DashboardWidgetTimeseriesDefinitionRequestApmQueryCompute',
    'DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySort',
    'DashboardWidgetTimeseriesDefinitionRequestApmQuerySearch',
    'DashboardWidgetTimeseriesDefinitionRequestLogQuery',
    'DashboardWidgetTimeseriesDefinitionRequestLogQueryCompute',
    'DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetTimeseriesDefinitionRequestLogQuerySearch',
    'DashboardWidgetTimeseriesDefinitionRequestMetadata',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQuery',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryCompute',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySort',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQuerySearch',
    'DashboardWidgetTimeseriesDefinitionRequestProcessQuery',
    'DashboardWidgetTimeseriesDefinitionRequestRumQuery',
    'DashboardWidgetTimeseriesDefinitionRequestRumQueryCompute',
    'DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySort',
    'DashboardWidgetTimeseriesDefinitionRequestRumQuerySearch',
    'DashboardWidgetTimeseriesDefinitionRequestStyle',
    'DashboardWidgetTimeseriesDefinitionTime',
    'DashboardWidgetTimeseriesDefinitionYaxis',
    'DashboardWidgetToplistDefinition',
    'DashboardWidgetToplistDefinitionRequest',
    'DashboardWidgetToplistDefinitionRequestApmQuery',
    'DashboardWidgetToplistDefinitionRequestApmQueryCompute',
    'DashboardWidgetToplistDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetToplistDefinitionRequestApmQueryGroupBySort',
    'DashboardWidgetToplistDefinitionRequestApmQuerySearch',
    'DashboardWidgetToplistDefinitionRequestConditionalFormat',
    'DashboardWidgetToplistDefinitionRequestLogQuery',
    'DashboardWidgetToplistDefinitionRequestLogQueryCompute',
    'DashboardWidgetToplistDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetToplistDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetToplistDefinitionRequestLogQuerySearch',
    'DashboardWidgetToplistDefinitionRequestProcessQuery',
    'DashboardWidgetToplistDefinitionRequestStyle',
    'DashboardWidgetToplistDefinitionTime',
    'DashboardWidgetTraceServiceDefinition',
    'DashboardWidgetTraceServiceDefinitionTime',
    'DowntimeRecurrence',
    'LogsArchiveAzure',
    'LogsArchiveGcs',
    'LogsArchiveS3',
    'LogsCustomPipelineFilter',
    'LogsCustomPipelineProcessor',
    'LogsCustomPipelineProcessorArithmeticProcessor',
    'LogsCustomPipelineProcessorAttributeRemapper',
    'LogsCustomPipelineProcessorCategoryProcessor',
    'LogsCustomPipelineProcessorCategoryProcessorCategory',
    'LogsCustomPipelineProcessorCategoryProcessorCategoryFilter',
    'LogsCustomPipelineProcessorDateRemapper',
    'LogsCustomPipelineProcessorGeoIpParser',
    'LogsCustomPipelineProcessorGrokParser',
    'LogsCustomPipelineProcessorGrokParserGrok',
    'LogsCustomPipelineProcessorLookupProcessor',
    'LogsCustomPipelineProcessorMessageRemapper',
    'LogsCustomPipelineProcessorPipeline',
    'LogsCustomPipelineProcessorPipelineFilter',
    'LogsCustomPipelineProcessorPipelineProcessor',
    'LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor',
    'LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper',
    'LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor',
    'LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory',
    'LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter',
    'LogsCustomPipelineProcessorPipelineProcessorDateRemapper',
    'LogsCustomPipelineProcessorPipelineProcessorGeoIpParser',
    'LogsCustomPipelineProcessorPipelineProcessorGrokParser',
    'LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok',
    'LogsCustomPipelineProcessorPipelineProcessorLookupProcessor',
    'LogsCustomPipelineProcessorPipelineProcessorMessageRemapper',
    'LogsCustomPipelineProcessorPipelineProcessorServiceRemapper',
    'LogsCustomPipelineProcessorPipelineProcessorStatusRemapper',
    'LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor',
    'LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper',
    'LogsCustomPipelineProcessorPipelineProcessorUrlParser',
    'LogsCustomPipelineProcessorPipelineProcessorUserAgentParser',
    'LogsCustomPipelineProcessorServiceRemapper',
    'LogsCustomPipelineProcessorStatusRemapper',
    'LogsCustomPipelineProcessorStringBuilderProcessor',
    'LogsCustomPipelineProcessorTraceIdRemapper',
    'LogsCustomPipelineProcessorUrlParser',
    'LogsCustomPipelineProcessorUserAgentParser',
    'LogsIndexExclusionFilter',
    'LogsIndexExclusionFilterFilter',
    'LogsIndexFilter',
    'MonitorThresholdWindows',
    'MonitorThresholds',
    'ScreenBoardTemplateVariable',
    'ScreenBoardWidget',
    'ScreenBoardWidgetRule',
    'ScreenBoardWidgetTileDef',
    'ScreenBoardWidgetTileDefEvent',
    'ScreenBoardWidgetTileDefMarker',
    'ScreenBoardWidgetTileDefRequest',
    'ScreenBoardWidgetTileDefRequestApmQuery',
    'ScreenBoardWidgetTileDefRequestApmQueryCompute',
    'ScreenBoardWidgetTileDefRequestApmQueryGroupBy',
    'ScreenBoardWidgetTileDefRequestApmQueryGroupBySort',
    'ScreenBoardWidgetTileDefRequestApmQuerySearch',
    'ScreenBoardWidgetTileDefRequestConditionalFormat',
    'ScreenBoardWidgetTileDefRequestLogQuery',
    'ScreenBoardWidgetTileDefRequestLogQueryCompute',
    'ScreenBoardWidgetTileDefRequestLogQueryGroupBy',
    'ScreenBoardWidgetTileDefRequestLogQueryGroupBySort',
    'ScreenBoardWidgetTileDefRequestLogQuerySearch',
    'ScreenBoardWidgetTileDefRequestProcessQuery',
    'ServiceLevelObjectiveQuery',
    'ServiceLevelObjectiveThreshold',
    'SyntheticsTestOptions',
    'SyntheticsTestRequest',
    'SyntheticsTestRequestBasicauth',
    'TimeBoardGraph',
    'TimeBoardGraphMarker',
    'TimeBoardGraphRequest',
    'TimeBoardGraphRequestApmQuery',
    'TimeBoardGraphRequestApmQueryCompute',
    'TimeBoardGraphRequestApmQueryGroupBy',
    'TimeBoardGraphRequestApmQueryGroupBySort',
    'TimeBoardGraphRequestApmQuerySearch',
    'TimeBoardGraphRequestConditionalFormat',
    'TimeBoardGraphRequestLogQuery',
    'TimeBoardGraphRequestLogQueryCompute',
    'TimeBoardGraphRequestLogQueryGroupBy',
    'TimeBoardGraphRequestLogQueryGroupBySort',
    'TimeBoardGraphRequestLogQuerySearch',
    'TimeBoardGraphRequestProcessQuery',
    'TimeBoardTemplateVariable',
    'GetMonitorThresholdWindowsResult',
    'GetMonitorThresholdsResult',
]

@pulumi.output_type
class DashboardListDashItem(dict):
    def __init__(__self__, *,
                 dash_id: str,
                 type: str):
        """
        :param str dash_id: The ID of this dashboard.
        :param str type: The type of this dashboard. Available options are: `custom_timeboard`, `custom_screenboard`, `integration_screenboard`, `integration_timeboard`, and `host_timeboard`
        """
        pulumi.set(__self__, "dash_id", dash_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="dashId")
    def dash_id(self) -> str:
        """
        The ID of this dashboard.
        """
        return pulumi.get(self, "dash_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of this dashboard. Available options are: `custom_timeboard`, `custom_screenboard`, `integration_screenboard`, `integration_timeboard`, and `host_timeboard`
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardTemplateVariable(dict):
    def __init__(__self__, *,
                 name: str,
                 default: Optional[str] = None,
                 prefix: Optional[str] = None):
        """
        :param str name: The variable name. Can be referenced as $name in `graph` `request` `q` query strings.
        :param str default: The default tag. Default: "\*" (match all).
        :param str prefix: The tag group. Default: no tag group.
        """
        pulumi.set(__self__, "name", name)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The variable name. Can be referenced as $name in `graph` `request` `q` query strings.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def default(self) -> Optional[str]:
        """
        The default tag. Default: "\*" (match all).
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        The tag group. Default: no tag group.
        """
        return pulumi.get(self, "prefix")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardTemplateVariablePreset(dict):
    def __init__(__self__, *,
                 name: str,
                 template_variables: List['outputs.DashboardTemplateVariablePresetTemplateVariable']):
        """
        :param str name: The displayed name of the preset.
               - `template_variable`: (Required) Block describing the values that a template_variable within this preset should assume. Each referenced template_variable name must be defined on the dashboard, but not all template_variables must be included in a preset. One or more blocks can be defined per preset.
               - `name`: (Required) The name of the template_variable being referenced.
               - `value`: (Required) The value that the template_variable should assume.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "template_variables", template_variables)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The displayed name of the preset.
        - `template_variable`: (Required) Block describing the values that a template_variable within this preset should assume. Each referenced template_variable name must be defined on the dashboard, but not all template_variables must be included in a preset. One or more blocks can be defined per preset.
        - `name`: (Required) The name of the template_variable being referenced.
        - `value`: (Required) The value that the template_variable should assume.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="templateVariables")
    def template_variables(self) -> List['outputs.DashboardTemplateVariablePresetTemplateVariable']:
        return pulumi.get(self, "template_variables")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardTemplateVariablePresetTemplateVariable(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The variable name. Can be referenced as $name in `graph` `request` `q` query strings.
        :param str value: Value for the comparator.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The variable name. Can be referenced as $name in `graph` `request` `q` query strings.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value for the comparator.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidget(dict):
    def __init__(__self__, *,
                 alert_graph_definition: Optional['outputs.DashboardWidgetAlertGraphDefinition'] = None,
                 alert_value_definition: Optional['outputs.DashboardWidgetAlertValueDefinition'] = None,
                 change_definition: Optional['outputs.DashboardWidgetChangeDefinition'] = None,
                 check_status_definition: Optional['outputs.DashboardWidgetCheckStatusDefinition'] = None,
                 distribution_definition: Optional['outputs.DashboardWidgetDistributionDefinition'] = None,
                 event_stream_definition: Optional['outputs.DashboardWidgetEventStreamDefinition'] = None,
                 event_timeline_definition: Optional['outputs.DashboardWidgetEventTimelineDefinition'] = None,
                 free_text_definition: Optional['outputs.DashboardWidgetFreeTextDefinition'] = None,
                 group_definition: Optional['outputs.DashboardWidgetGroupDefinition'] = None,
                 heatmap_definition: Optional['outputs.DashboardWidgetHeatmapDefinition'] = None,
                 hostmap_definition: Optional['outputs.DashboardWidgetHostmapDefinition'] = None,
                 iframe_definition: Optional['outputs.DashboardWidgetIframeDefinition'] = None,
                 image_definition: Optional['outputs.DashboardWidgetImageDefinition'] = None,
                 layout: Optional['outputs.DashboardWidgetLayout'] = None,
                 log_stream_definition: Optional['outputs.DashboardWidgetLogStreamDefinition'] = None,
                 manage_status_definition: Optional['outputs.DashboardWidgetManageStatusDefinition'] = None,
                 note_definition: Optional['outputs.DashboardWidgetNoteDefinition'] = None,
                 query_table_definition: Optional['outputs.DashboardWidgetQueryTableDefinition'] = None,
                 query_value_definition: Optional['outputs.DashboardWidgetQueryValueDefinition'] = None,
                 scatterplot_definition: Optional['outputs.DashboardWidgetScatterplotDefinition'] = None,
                 service_level_objective_definition: Optional['outputs.DashboardWidgetServiceLevelObjectiveDefinition'] = None,
                 servicemap_definition: Optional['outputs.DashboardWidgetServicemapDefinition'] = None,
                 timeseries_definition: Optional['outputs.DashboardWidgetTimeseriesDefinition'] = None,
                 toplist_definition: Optional['outputs.DashboardWidgetToplistDefinition'] = None,
                 trace_service_definition: Optional['outputs.DashboardWidgetTraceServiceDefinition'] = None):
        """
        :param 'DashboardWidgetLayoutArgs' layout: . The structure of this block is described below
               - A widget should have exactly one of the following nested blocks describing the widget definition:
               - `alert_graph_definition`: The definition for a Alert Graph widget. Exactly one nested block is allowed with the following structure:
               - `alert_id`: (Required) The ID of the monitor used by the widget.
               - `viz_type`: (Required) Type of visualization to use when displaying the widget. Either "timeseries" or "toplist".
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right"
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `alert_value_definition`: The definition for an Alert Value widget. Exactly one nested block is allowed with the following structure:
               - `alert_id`: (Required) The ID of the monitor used by the widget.
               - `precision`: (Optional) The precision to use when displaying the value. Use "*" for maximum precision.
               - `unit`: (Optional) The unit for the value displayed in the widget.
               - `text_align`: (Optional) The alignment of the text in the widget.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right"
               - `change_definition`: The definition for a Change widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `change_type`: (Optional) Whether to show absolute or relative change. One of "absolute", "relative".
        """
        if alert_graph_definition is not None:
            pulumi.set(__self__, "alert_graph_definition", alert_graph_definition)
        if alert_value_definition is not None:
            pulumi.set(__self__, "alert_value_definition", alert_value_definition)
        if change_definition is not None:
            pulumi.set(__self__, "change_definition", change_definition)
        if check_status_definition is not None:
            pulumi.set(__self__, "check_status_definition", check_status_definition)
        if distribution_definition is not None:
            pulumi.set(__self__, "distribution_definition", distribution_definition)
        if event_stream_definition is not None:
            pulumi.set(__self__, "event_stream_definition", event_stream_definition)
        if event_timeline_definition is not None:
            pulumi.set(__self__, "event_timeline_definition", event_timeline_definition)
        if free_text_definition is not None:
            pulumi.set(__self__, "free_text_definition", free_text_definition)
        if group_definition is not None:
            pulumi.set(__self__, "group_definition", group_definition)
        if heatmap_definition is not None:
            pulumi.set(__self__, "heatmap_definition", heatmap_definition)
        if hostmap_definition is not None:
            pulumi.set(__self__, "hostmap_definition", hostmap_definition)
        if iframe_definition is not None:
            pulumi.set(__self__, "iframe_definition", iframe_definition)
        if image_definition is not None:
            pulumi.set(__self__, "image_definition", image_definition)
        if layout is not None:
            pulumi.set(__self__, "layout", layout)
        if log_stream_definition is not None:
            pulumi.set(__self__, "log_stream_definition", log_stream_definition)
        if manage_status_definition is not None:
            pulumi.set(__self__, "manage_status_definition", manage_status_definition)
        if note_definition is not None:
            pulumi.set(__self__, "note_definition", note_definition)
        if query_table_definition is not None:
            pulumi.set(__self__, "query_table_definition", query_table_definition)
        if query_value_definition is not None:
            pulumi.set(__self__, "query_value_definition", query_value_definition)
        if scatterplot_definition is not None:
            pulumi.set(__self__, "scatterplot_definition", scatterplot_definition)
        if service_level_objective_definition is not None:
            pulumi.set(__self__, "service_level_objective_definition", service_level_objective_definition)
        if servicemap_definition is not None:
            pulumi.set(__self__, "servicemap_definition", servicemap_definition)
        if timeseries_definition is not None:
            pulumi.set(__self__, "timeseries_definition", timeseries_definition)
        if toplist_definition is not None:
            pulumi.set(__self__, "toplist_definition", toplist_definition)
        if trace_service_definition is not None:
            pulumi.set(__self__, "trace_service_definition", trace_service_definition)

    @property
    @pulumi.getter(name="alertGraphDefinition")
    def alert_graph_definition(self) -> Optional['outputs.DashboardWidgetAlertGraphDefinition']:
        return pulumi.get(self, "alert_graph_definition")

    @property
    @pulumi.getter(name="alertValueDefinition")
    def alert_value_definition(self) -> Optional['outputs.DashboardWidgetAlertValueDefinition']:
        return pulumi.get(self, "alert_value_definition")

    @property
    @pulumi.getter(name="changeDefinition")
    def change_definition(self) -> Optional['outputs.DashboardWidgetChangeDefinition']:
        return pulumi.get(self, "change_definition")

    @property
    @pulumi.getter(name="checkStatusDefinition")
    def check_status_definition(self) -> Optional['outputs.DashboardWidgetCheckStatusDefinition']:
        return pulumi.get(self, "check_status_definition")

    @property
    @pulumi.getter(name="distributionDefinition")
    def distribution_definition(self) -> Optional['outputs.DashboardWidgetDistributionDefinition']:
        return pulumi.get(self, "distribution_definition")

    @property
    @pulumi.getter(name="eventStreamDefinition")
    def event_stream_definition(self) -> Optional['outputs.DashboardWidgetEventStreamDefinition']:
        return pulumi.get(self, "event_stream_definition")

    @property
    @pulumi.getter(name="eventTimelineDefinition")
    def event_timeline_definition(self) -> Optional['outputs.DashboardWidgetEventTimelineDefinition']:
        return pulumi.get(self, "event_timeline_definition")

    @property
    @pulumi.getter(name="freeTextDefinition")
    def free_text_definition(self) -> Optional['outputs.DashboardWidgetFreeTextDefinition']:
        return pulumi.get(self, "free_text_definition")

    @property
    @pulumi.getter(name="groupDefinition")
    def group_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinition']:
        return pulumi.get(self, "group_definition")

    @property
    @pulumi.getter(name="heatmapDefinition")
    def heatmap_definition(self) -> Optional['outputs.DashboardWidgetHeatmapDefinition']:
        return pulumi.get(self, "heatmap_definition")

    @property
    @pulumi.getter(name="hostmapDefinition")
    def hostmap_definition(self) -> Optional['outputs.DashboardWidgetHostmapDefinition']:
        return pulumi.get(self, "hostmap_definition")

    @property
    @pulumi.getter(name="iframeDefinition")
    def iframe_definition(self) -> Optional['outputs.DashboardWidgetIframeDefinition']:
        return pulumi.get(self, "iframe_definition")

    @property
    @pulumi.getter(name="imageDefinition")
    def image_definition(self) -> Optional['outputs.DashboardWidgetImageDefinition']:
        return pulumi.get(self, "image_definition")

    @property
    @pulumi.getter
    def layout(self) -> Optional['outputs.DashboardWidgetLayout']:
        """
        . The structure of this block is described below
        - A widget should have exactly one of the following nested blocks describing the widget definition:
        - `alert_graph_definition`: The definition for a Alert Graph widget. Exactly one nested block is allowed with the following structure:
        - `alert_id`: (Required) The ID of the monitor used by the widget.
        - `viz_type`: (Required) Type of visualization to use when displaying the widget. Either "timeseries" or "toplist".
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right"
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `alert_value_definition`: The definition for an Alert Value widget. Exactly one nested block is allowed with the following structure:
        - `alert_id`: (Required) The ID of the monitor used by the widget.
        - `precision`: (Optional) The precision to use when displaying the value. Use "*" for maximum precision.
        - `unit`: (Optional) The unit for the value displayed in the widget.
        - `text_align`: (Optional) The alignment of the text in the widget.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right"
        - `change_definition`: The definition for a Change widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `change_type`: (Optional) Whether to show absolute or relative change. One of "absolute", "relative".
        """
        return pulumi.get(self, "layout")

    @property
    @pulumi.getter(name="logStreamDefinition")
    def log_stream_definition(self) -> Optional['outputs.DashboardWidgetLogStreamDefinition']:
        return pulumi.get(self, "log_stream_definition")

    @property
    @pulumi.getter(name="manageStatusDefinition")
    def manage_status_definition(self) -> Optional['outputs.DashboardWidgetManageStatusDefinition']:
        return pulumi.get(self, "manage_status_definition")

    @property
    @pulumi.getter(name="noteDefinition")
    def note_definition(self) -> Optional['outputs.DashboardWidgetNoteDefinition']:
        return pulumi.get(self, "note_definition")

    @property
    @pulumi.getter(name="queryTableDefinition")
    def query_table_definition(self) -> Optional['outputs.DashboardWidgetQueryTableDefinition']:
        return pulumi.get(self, "query_table_definition")

    @property
    @pulumi.getter(name="queryValueDefinition")
    def query_value_definition(self) -> Optional['outputs.DashboardWidgetQueryValueDefinition']:
        return pulumi.get(self, "query_value_definition")

    @property
    @pulumi.getter(name="scatterplotDefinition")
    def scatterplot_definition(self) -> Optional['outputs.DashboardWidgetScatterplotDefinition']:
        return pulumi.get(self, "scatterplot_definition")

    @property
    @pulumi.getter(name="serviceLevelObjectiveDefinition")
    def service_level_objective_definition(self) -> Optional['outputs.DashboardWidgetServiceLevelObjectiveDefinition']:
        return pulumi.get(self, "service_level_objective_definition")

    @property
    @pulumi.getter(name="servicemapDefinition")
    def servicemap_definition(self) -> Optional['outputs.DashboardWidgetServicemapDefinition']:
        return pulumi.get(self, "servicemap_definition")

    @property
    @pulumi.getter(name="timeseriesDefinition")
    def timeseries_definition(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinition']:
        return pulumi.get(self, "timeseries_definition")

    @property
    @pulumi.getter(name="toplistDefinition")
    def toplist_definition(self) -> Optional['outputs.DashboardWidgetToplistDefinition']:
        return pulumi.get(self, "toplist_definition")

    @property
    @pulumi.getter(name="traceServiceDefinition")
    def trace_service_definition(self) -> Optional['outputs.DashboardWidgetTraceServiceDefinition']:
        return pulumi.get(self, "trace_service_definition")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetAlertGraphDefinition(dict):
    def __init__(__self__, *,
                 alert_id: str,
                 viz_type: str,
                 time: Optional['outputs.DashboardWidgetAlertGraphDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str title: Title of the dashboard.
        """
        pulumi.set(__self__, "alert_id", alert_id)
        pulumi.set(__self__, "viz_type", viz_type)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> str:
        return pulumi.get(self, "alert_id")

    @property
    @pulumi.getter(name="vizType")
    def viz_type(self) -> str:
        return pulumi.get(self, "viz_type")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetAlertGraphDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetAlertGraphDefinitionTime(dict):
    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetAlertValueDefinition(dict):
    def __init__(__self__, *,
                 alert_id: str,
                 precision: Optional[float] = None,
                 text_align: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 unit: Optional[str] = None):
        """
        :param float precision: The precision to use when displaying the tile.
        :param str text_align: The alignment of the text in the widget.
               - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
               - `q`: (Optional) The metric query to use in the widget
               - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
               - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
               - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        :param str title: Title of the dashboard.
        """
        pulumi.set(__self__, "alert_id", alert_id)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> str:
        return pulumi.get(self, "alert_id")

    @property
    @pulumi.getter
    def precision(self) -> Optional[float]:
        """
        The precision to use when displaying the tile.
        """
        return pulumi.get(self, "precision")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        """
        The alignment of the text in the widget.
        - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
        - `q`: (Optional) The metric query to use in the widget
        - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
        - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
        - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "text_align")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        return pulumi.get(self, "unit")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetChangeDefinition(dict):
    def __init__(__self__, *,
                 requests: Optional[List['outputs.DashboardWidgetChangeDefinitionRequest']] = None,
                 time: Optional['outputs.DashboardWidgetChangeDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str title: Title of the dashboard.
        """
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def requests(self) -> Optional[List['outputs.DashboardWidgetChangeDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetChangeDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequest(dict):
    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestApmQuery'] = None,
                 change_type: Optional[str] = None,
                 compare_to: Optional[str] = None,
                 increase_good: Optional[bool] = None,
                 log_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestLogQuery'] = None,
                 order_by: Optional[str] = None,
                 order_dir: Optional[str] = None,
                 process_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 show_present: Optional[bool] = None):
        """
        :param str compare_to: Choose from when to compare current data to. One of "hour_before", "day_before", "week_before" or "month_before".
        :param bool increase_good: Boolean indicating whether an increase in the value is good (thus displayed in green) or not (thus displayed in red).
        :param str order_by: One of "change", "name", "present" (present value) or "past" (past value).
        :param str order_dir: Either "asc" (ascending) or "desc" (descending).
        :param bool show_present: If set to "true", displays current value.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `check_status_definition`: The definition for a Check Status widget. Exactly one nested block is allowed with the following structure:
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if change_type is not None:
            pulumi.set(__self__, "change_type", change_type)
        if compare_to is not None:
            pulumi.set(__self__, "compare_to", compare_to)
        if increase_good is not None:
            pulumi.set(__self__, "increase_good", increase_good)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if order_by is not None:
            pulumi.set(__self__, "order_by", order_by)
        if order_dir is not None:
            pulumi.set(__self__, "order_dir", order_dir)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if show_present is not None:
            pulumi.set(__self__, "show_present", show_present)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="changeType")
    def change_type(self) -> Optional[str]:
        return pulumi.get(self, "change_type")

    @property
    @pulumi.getter(name="compareTo")
    def compare_to(self) -> Optional[str]:
        """
        Choose from when to compare current data to. One of "hour_before", "day_before", "week_before" or "month_before".
        """
        return pulumi.get(self, "compare_to")

    @property
    @pulumi.getter(name="increaseGood")
    def increase_good(self) -> Optional[bool]:
        """
        Boolean indicating whether an increase in the value is good (thus displayed in green) or not (thus displayed in red).
        """
        return pulumi.get(self, "increase_good")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="orderBy")
    def order_by(self) -> Optional[str]:
        """
        One of "change", "name", "present" (present value) or "past" (past value).
        """
        return pulumi.get(self, "order_by")

    @property
    @pulumi.getter(name="orderDir")
    def order_dir(self) -> Optional[str]:
        """
        Either "asc" (ascending) or "desc" (descending).
        """
        return pulumi.get(self, "order_dir")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="showPresent")
    def show_present(self) -> Optional[bool]:
        """
        If set to "true", displays current value.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `check_status_definition`: The definition for a Check Status widget. Exactly one nested block is allowed with the following structure:
        """
        return pulumi.get(self, "show_present")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestApmQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetChangeDefinitionRequestApmQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetChangeDefinitionRequestApmQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetChangeDefinitionRequestApmQuerySearch'] = None):
        """
        :param 'DashboardWidgetChangeDefinitionRequestApmQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetChangeDefinitionRequestApmQueryGroupByArgs'] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param 'DashboardWidgetChangeDefinitionRequestApmQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetChangeDefinitionRequestApmQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetChangeDefinitionRequestApmQueryGroupBy']]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestApmQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestApmQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetChangeDefinitionRequestApmQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetChangeDefinitionRequestApmQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestApmQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestLogQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetChangeDefinitionRequestLogQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetChangeDefinitionRequestLogQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetChangeDefinitionRequestLogQuerySearch'] = None):
        """
        :param 'DashboardWidgetChangeDefinitionRequestLogQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetChangeDefinitionRequestLogQueryGroupByArgs'] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param 'DashboardWidgetChangeDefinitionRequestLogQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetChangeDefinitionRequestLogQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetChangeDefinitionRequestLogQueryGroupBy']]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestLogQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestLogQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetChangeDefinitionRequestLogQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetChangeDefinitionRequestLogQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestLogQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestProcessQuery(dict):
    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[List[str]] = None,
                 limit: Optional[float] = None,
                 search_by: Optional[str] = None):
        """
        :param float limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[List[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetChangeDefinitionTime(dict):
    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetCheckStatusDefinition(dict):
    def __init__(__self__, *,
                 check: str,
                 grouping: str,
                 group: Optional[str] = None,
                 group_bies: Optional[List[str]] = None,
                 tags: Optional[List[str]] = None,
                 time: Optional['outputs.DashboardWidgetCheckStatusDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str check: The check to use in the widget.
        :param str grouping: Either "check" or "cluster", depending on whether the widget should use a single check or a cluster of checks.
        :param str group: The check group to use in the widget.
        :param List[str] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param List[str] tags: List of tags to use in the widget.
               - `title`: (Optional) The title of the widget.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `distribution_definition`: The definition for a Distribution widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        :param str title: Title of the dashboard.
        """
        pulumi.set(__self__, "check", check)
        pulumi.set(__self__, "grouping", grouping)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def check(self) -> str:
        """
        The check to use in the widget.
        """
        return pulumi.get(self, "check")

    @property
    @pulumi.getter
    def grouping(self) -> str:
        """
        Either "check" or "cluster", depending on whether the widget should use a single check or a cluster of checks.
        """
        return pulumi.get(self, "grouping")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        The check group to use in the widget.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List[str]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def tags(self) -> Optional[List[str]]:
        """
        List of tags to use in the widget.
        - `title`: (Optional) The title of the widget.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `distribution_definition`: The definition for a Distribution widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetCheckStatusDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetCheckStatusDefinitionTime(dict):
    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetDistributionDefinition(dict):
    def __init__(__self__, *,
                 legend_size: Optional[str] = None,
                 requests: Optional[List['outputs.DashboardWidgetDistributionDefinitionRequest']] = None,
                 show_legend: Optional[bool] = None,
                 time: Optional['outputs.DashboardWidgetDistributionDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str title: Title of the dashboard.
        """
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[str]:
        return pulumi.get(self, "legend_size")

    @property
    @pulumi.getter
    def requests(self) -> Optional[List['outputs.DashboardWidgetDistributionDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[bool]:
        return pulumi.get(self, "show_legend")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequest(dict):
    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 style: Optional['outputs.DashboardWidgetDistributionDefinitionRequestStyle'] = None):
        """
        :param 'DashboardWidgetDistributionDefinitionRequestStyleArgs' style: Style of the widget graph. One nested block is allowed with the following structure:
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestStyle']:
        """
        Style of the widget graph. One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "style")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestApmQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetDistributionDefinitionRequestApmQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmQuerySearch'] = None):
        """
        :param 'DashboardWidgetDistributionDefinitionRequestApmQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetDistributionDefinitionRequestApmQueryGroupByArgs'] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param 'DashboardWidgetDistributionDefinitionRequestApmQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetDistributionDefinitionRequestApmQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy']]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestLogQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetDistributionDefinitionRequestLogQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetDistributionDefinitionRequestLogQuerySearch'] = None):
        """
        :param 'DashboardWidgetDistributionDefinitionRequestLogQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetDistributionDefinitionRequestLogQueryGroupByArgs'] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param 'DashboardWidgetDistributionDefinitionRequestLogQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetDistributionDefinitionRequestLogQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy']]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestLogQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestProcessQuery(dict):
    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[List[str]] = None,
                 limit: Optional[float] = None,
                 search_by: Optional[str] = None):
        """
        :param float limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[List[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 palette: Optional[str] = None):
        """
        :param str palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
               - `q`: (Required) The event query to use in the widget.
               - `tags_execution`: (Optional) The execution method for multi-value filters.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
        - `q`: (Required) The event query to use in the widget.
        - `tags_execution`: (Optional) The execution method for multi-value filters.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "palette")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetDistributionDefinitionTime(dict):
    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetEventStreamDefinition(dict):
    def __init__(__self__, *,
                 query: str,
                 event_size: Optional[str] = None,
                 tags_execution: Optional[str] = None,
                 time: Optional['outputs.DashboardWidgetEventStreamDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str event_size: The size of the events in the widget. Either "s" (small, title only) or "l" (large, full event).
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `tags_execution`: (Optional) The execution method for multi-value filters. Can be either "and" or "or".
               - `event_timeline_definition`: The definition for a Event Timeline widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `tags_execution`: (Optional) The execution method for multi-value filters. Can be either "and" or "or".
               - `free_text_definition`: The definition for a Free Text. Exactly one nested block is allowed with the following structure:
        :param str title: Title of the dashboard.
        """
        pulumi.set(__self__, "query", query)
        if event_size is not None:
            pulumi.set(__self__, "event_size", event_size)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="eventSize")
    def event_size(self) -> Optional[str]:
        """
        The size of the events in the widget. Either "s" (small, title only) or "l" (large, full event).
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `tags_execution`: (Optional) The execution method for multi-value filters. Can be either "and" or "or".
        - `event_timeline_definition`: The definition for a Event Timeline widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `tags_execution`: (Optional) The execution method for multi-value filters. Can be either "and" or "or".
        - `free_text_definition`: The definition for a Free Text. Exactly one nested block is allowed with the following structure:
        """
        return pulumi.get(self, "event_size")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        return pulumi.get(self, "tags_execution")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetEventStreamDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetEventStreamDefinitionTime(dict):
    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetEventTimelineDefinition(dict):
    def __init__(__self__, *,
                 query: str,
                 tags_execution: Optional[str] = None,
                 time: Optional['outputs.DashboardWidgetEventTimelineDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str title: Title of the dashboard.
        """
        pulumi.set(__self__, "query", query)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        return pulumi.get(self, "tags_execution")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetEventTimelineDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetEventTimelineDefinitionTime(dict):
    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetFreeTextDefinition(dict):
    def __init__(__self__, *,
                 text: str,
                 color: Optional[str] = None,
                 font_size: Optional[str] = None,
                 text_align: Optional[str] = None):
        """
        :param str text: The text to display in the widget.
        :param str color: The color of the text in the widget.
        :param str font_size: The size of the text in the widget.
        :param str text_align: The alignment of the text in the widget.
               - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
               - `q`: (Optional) The metric query to use in the widget
               - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
               - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
               - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        pulumi.set(__self__, "text", text)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if font_size is not None:
            pulumi.set(__self__, "font_size", font_size)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)

    @property
    @pulumi.getter
    def text(self) -> str:
        """
        The text to display in the widget.
        """
        return pulumi.get(self, "text")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        """
        The color of the text in the widget.
        """
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[str]:
        """
        The size of the text in the widget.
        """
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        """
        The alignment of the text in the widget.
        - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
        - `q`: (Optional) The metric query to use in the widget
        - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
        - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
        - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "text_align")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinition(dict):
    def __init__(__self__, *,
                 layout_type: str,
                 widgets: List['outputs.DashboardWidgetGroupDefinitionWidget'],
                 title: Optional[str] = None):
        """
        :param str layout_type: Layout type of the dashboard. Available values are: `ordered` (previous timeboard) or `free` (previous screenboard layout).
               <br>**Note: This value cannot be changed. Converting a dashboard from `free` <> `ordered` requires destroying and re-creating the dashboard.** Instead of using `ForceNew`, this is a manual action as many underlying widget configs need to be updated to work for the updated layout, otherwise the new dashboard won't be created properly.
        :param List['DashboardWidgetGroupDefinitionWidgetArgs'] widgets: Nested block describing a widget. The structure of this block is described below. Multiple `widget` blocks are allowed within a `Dashboard` resource.
        :param str title: Title of the dashboard.
        """
        pulumi.set(__self__, "layout_type", layout_type)
        pulumi.set(__self__, "widgets", widgets)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="layoutType")
    def layout_type(self) -> str:
        """
        Layout type of the dashboard. Available values are: `ordered` (previous timeboard) or `free` (previous screenboard layout).
        <br>**Note: This value cannot be changed. Converting a dashboard from `free` <> `ordered` requires destroying and re-creating the dashboard.** Instead of using `ForceNew`, this is a manual action as many underlying widget configs need to be updated to work for the updated layout, otherwise the new dashboard won't be created properly.
        """
        return pulumi.get(self, "layout_type")

    @property
    @pulumi.getter
    def widgets(self) -> List['outputs.DashboardWidgetGroupDefinitionWidget']:
        """
        Nested block describing a widget. The structure of this block is described below. Multiple `widget` blocks are allowed within a `Dashboard` resource.
        """
        return pulumi.get(self, "widgets")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidget(dict):
    def __init__(__self__, *,
                 alert_graph_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition'] = None,
                 alert_value_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetAlertValueDefinition'] = None,
                 change_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinition'] = None,
                 check_status_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition'] = None,
                 distribution_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinition'] = None,
                 event_stream_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetEventStreamDefinition'] = None,
                 event_timeline_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition'] = None,
                 free_text_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetFreeTextDefinition'] = None,
                 heatmap_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinition'] = None,
                 hostmap_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinition'] = None,
                 iframe_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetIframeDefinition'] = None,
                 image_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetImageDefinition'] = None,
                 layout: Optional['outputs.DashboardWidgetGroupDefinitionWidgetLayout'] = None,
                 log_stream_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetLogStreamDefinition'] = None,
                 manage_status_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetManageStatusDefinition'] = None,
                 note_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetNoteDefinition'] = None,
                 query_table_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinition'] = None,
                 query_value_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinition'] = None,
                 scatterplot_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinition'] = None,
                 service_level_objective_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition'] = None,
                 servicemap_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetServicemapDefinition'] = None,
                 timeseries_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition'] = None,
                 toplist_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinition'] = None,
                 trace_service_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetLayoutArgs' layout: . The structure of this block is described below
               - A widget should have exactly one of the following nested blocks describing the widget definition:
               - `alert_graph_definition`: The definition for a Alert Graph widget. Exactly one nested block is allowed with the following structure:
               - `alert_id`: (Required) The ID of the monitor used by the widget.
               - `viz_type`: (Required) Type of visualization to use when displaying the widget. Either "timeseries" or "toplist".
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right"
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `alert_value_definition`: The definition for an Alert Value widget. Exactly one nested block is allowed with the following structure:
               - `alert_id`: (Required) The ID of the monitor used by the widget.
               - `precision`: (Optional) The precision to use when displaying the value. Use "*" for maximum precision.
               - `unit`: (Optional) The unit for the value displayed in the widget.
               - `text_align`: (Optional) The alignment of the text in the widget.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right"
               - `change_definition`: The definition for a Change widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `change_type`: (Optional) Whether to show absolute or relative change. One of "absolute", "relative".
        """
        if alert_graph_definition is not None:
            pulumi.set(__self__, "alert_graph_definition", alert_graph_definition)
        if alert_value_definition is not None:
            pulumi.set(__self__, "alert_value_definition", alert_value_definition)
        if change_definition is not None:
            pulumi.set(__self__, "change_definition", change_definition)
        if check_status_definition is not None:
            pulumi.set(__self__, "check_status_definition", check_status_definition)
        if distribution_definition is not None:
            pulumi.set(__self__, "distribution_definition", distribution_definition)
        if event_stream_definition is not None:
            pulumi.set(__self__, "event_stream_definition", event_stream_definition)
        if event_timeline_definition is not None:
            pulumi.set(__self__, "event_timeline_definition", event_timeline_definition)
        if free_text_definition is not None:
            pulumi.set(__self__, "free_text_definition", free_text_definition)
        if heatmap_definition is not None:
            pulumi.set(__self__, "heatmap_definition", heatmap_definition)
        if hostmap_definition is not None:
            pulumi.set(__self__, "hostmap_definition", hostmap_definition)
        if iframe_definition is not None:
            pulumi.set(__self__, "iframe_definition", iframe_definition)
        if image_definition is not None:
            pulumi.set(__self__, "image_definition", image_definition)
        if layout is not None:
            pulumi.set(__self__, "layout", layout)
        if log_stream_definition is not None:
            pulumi.set(__self__, "log_stream_definition", log_stream_definition)
        if manage_status_definition is not None:
            pulumi.set(__self__, "manage_status_definition", manage_status_definition)
        if note_definition is not None:
            pulumi.set(__self__, "note_definition", note_definition)
        if query_table_definition is not None:
            pulumi.set(__self__, "query_table_definition", query_table_definition)
        if query_value_definition is not None:
            pulumi.set(__self__, "query_value_definition", query_value_definition)
        if scatterplot_definition is not None:
            pulumi.set(__self__, "scatterplot_definition", scatterplot_definition)
        if service_level_objective_definition is not None:
            pulumi.set(__self__, "service_level_objective_definition", service_level_objective_definition)
        if servicemap_definition is not None:
            pulumi.set(__self__, "servicemap_definition", servicemap_definition)
        if timeseries_definition is not None:
            pulumi.set(__self__, "timeseries_definition", timeseries_definition)
        if toplist_definition is not None:
            pulumi.set(__self__, "toplist_definition", toplist_definition)
        if trace_service_definition is not None:
            pulumi.set(__self__, "trace_service_definition", trace_service_definition)

    @property
    @pulumi.getter(name="alertGraphDefinition")
    def alert_graph_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition']:
        return pulumi.get(self, "alert_graph_definition")

    @property
    @pulumi.getter(name="alertValueDefinition")
    def alert_value_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetAlertValueDefinition']:
        return pulumi.get(self, "alert_value_definition")

    @property
    @pulumi.getter(name="changeDefinition")
    def change_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinition']:
        return pulumi.get(self, "change_definition")

    @property
    @pulumi.getter(name="checkStatusDefinition")
    def check_status_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition']:
        return pulumi.get(self, "check_status_definition")

    @property
    @pulumi.getter(name="distributionDefinition")
    def distribution_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinition']:
        return pulumi.get(self, "distribution_definition")

    @property
    @pulumi.getter(name="eventStreamDefinition")
    def event_stream_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetEventStreamDefinition']:
        return pulumi.get(self, "event_stream_definition")

    @property
    @pulumi.getter(name="eventTimelineDefinition")
    def event_timeline_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition']:
        return pulumi.get(self, "event_timeline_definition")

    @property
    @pulumi.getter(name="freeTextDefinition")
    def free_text_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetFreeTextDefinition']:
        return pulumi.get(self, "free_text_definition")

    @property
    @pulumi.getter(name="heatmapDefinition")
    def heatmap_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinition']:
        return pulumi.get(self, "heatmap_definition")

    @property
    @pulumi.getter(name="hostmapDefinition")
    def hostmap_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinition']:
        return pulumi.get(self, "hostmap_definition")

    @property
    @pulumi.getter(name="iframeDefinition")
    def iframe_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetIframeDefinition']:
        return pulumi.get(self, "iframe_definition")

    @property
    @pulumi.getter(name="imageDefinition")
    def image_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetImageDefinition']:
        return pulumi.get(self, "image_definition")

    @property
    @pulumi.getter
    def layout(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetLayout']:
        """
        . The structure of this block is described below
        - A widget should have exactly one of the following nested blocks describing the widget definition:
        - `alert_graph_definition`: The definition for a Alert Graph widget. Exactly one nested block is allowed with the following structure:
        - `alert_id`: (Required) The ID of the monitor used by the widget.
        - `viz_type`: (Required) Type of visualization to use when displaying the widget. Either "timeseries" or "toplist".
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right"
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `alert_value_definition`: The definition for an Alert Value widget. Exactly one nested block is allowed with the following structure:
        - `alert_id`: (Required) The ID of the monitor used by the widget.
        - `precision`: (Optional) The precision to use when displaying the value. Use "*" for maximum precision.
        - `unit`: (Optional) The unit for the value displayed in the widget.
        - `text_align`: (Optional) The alignment of the text in the widget.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right"
        - `change_definition`: The definition for a Change widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `change_type`: (Optional) Whether to show absolute or relative change. One of "absolute", "relative".
        """
        return pulumi.get(self, "layout")

    @property
    @pulumi.getter(name="logStreamDefinition")
    def log_stream_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetLogStreamDefinition']:
        return pulumi.get(self, "log_stream_definition")

    @property
    @pulumi.getter(name="manageStatusDefinition")
    def manage_status_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetManageStatusDefinition']:
        return pulumi.get(self, "manage_status_definition")

    @property
    @pulumi.getter(name="noteDefinition")
    def note_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetNoteDefinition']:
        return pulumi.get(self, "note_definition")

    @property
    @pulumi.getter(name="queryTableDefinition")
    def query_table_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinition']:
        return pulumi.get(self, "query_table_definition")

    @property
    @pulumi.getter(name="queryValueDefinition")
    def query_value_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinition']:
        return pulumi.get(self, "query_value_definition")

    @property
    @pulumi.getter(name="scatterplotDefinition")
    def scatterplot_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinition']:
        return pulumi.get(self, "scatterplot_definition")

    @property
    @pulumi.getter(name="serviceLevelObjectiveDefinition")
    def service_level_objective_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition']:
        return pulumi.get(self, "service_level_objective_definition")

    @property
    @pulumi.getter(name="servicemapDefinition")
    def servicemap_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetServicemapDefinition']:
        return pulumi.get(self, "servicemap_definition")

    @property
    @pulumi.getter(name="timeseriesDefinition")
    def timeseries_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition']:
        return pulumi.get(self, "timeseries_definition")

    @property
    @pulumi.getter(name="toplistDefinition")
    def toplist_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinition']:
        return pulumi.get(self, "toplist_definition")

    @property
    @pulumi.getter(name="traceServiceDefinition")
    def trace_service_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition']:
        return pulumi.get(self, "trace_service_definition")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition(dict):
    def __init__(__self__, *,
                 alert_id: str,
                 viz_type: str,
                 time: Optional['outputs.DashboardWidgetGroupDefinitionWidgetAlertGraphDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str title: Title of the dashboard.
        """
        pulumi.set(__self__, "alert_id", alert_id)
        pulumi.set(__self__, "viz_type", viz_type)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> str:
        return pulumi.get(self, "alert_id")

    @property
    @pulumi.getter(name="vizType")
    def viz_type(self) -> str:
        return pulumi.get(self, "viz_type")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetAlertGraphDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetAlertGraphDefinitionTime(dict):
    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetAlertValueDefinition(dict):
    def __init__(__self__, *,
                 alert_id: str,
                 precision: Optional[float] = None,
                 text_align: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 unit: Optional[str] = None):
        """
        :param float precision: The precision to use when displaying the tile.
        :param str text_align: The alignment of the text in the widget.
               - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
               - `q`: (Optional) The metric query to use in the widget
               - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
               - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
               - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        :param str title: Title of the dashboard.
        """
        pulumi.set(__self__, "alert_id", alert_id)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> str:
        return pulumi.get(self, "alert_id")

    @property
    @pulumi.getter
    def precision(self) -> Optional[float]:
        """
        The precision to use when displaying the tile.
        """
        return pulumi.get(self, "precision")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        """
        The alignment of the text in the widget.
        - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
        - `q`: (Optional) The metric query to use in the widget
        - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
        - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
        - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "text_align")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        return pulumi.get(self, "unit")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinition(dict):
    def __init__(__self__, *,
                 requests: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest']] = None,
                 time: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str title: Title of the dashboard.
        """
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def requests(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest(dict):
    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery'] = None,
                 change_type: Optional[str] = None,
                 compare_to: Optional[str] = None,
                 increase_good: Optional[bool] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery'] = None,
                 order_by: Optional[str] = None,
                 order_dir: Optional[str] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 show_present: Optional[bool] = None):
        """
        :param str compare_to: Choose from when to compare current data to. One of "hour_before", "day_before", "week_before" or "month_before".
        :param bool increase_good: Boolean indicating whether an increase in the value is good (thus displayed in green) or not (thus displayed in red).
        :param str order_by: One of "change", "name", "present" (present value) or "past" (past value).
        :param str order_dir: Either "asc" (ascending) or "desc" (descending).
        :param bool show_present: If set to "true", displays current value.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `check_status_definition`: The definition for a Check Status widget. Exactly one nested block is allowed with the following structure:
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if change_type is not None:
            pulumi.set(__self__, "change_type", change_type)
        if compare_to is not None:
            pulumi.set(__self__, "compare_to", compare_to)
        if increase_good is not None:
            pulumi.set(__self__, "increase_good", increase_good)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if order_by is not None:
            pulumi.set(__self__, "order_by", order_by)
        if order_dir is not None:
            pulumi.set(__self__, "order_dir", order_dir)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if show_present is not None:
            pulumi.set(__self__, "show_present", show_present)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="changeType")
    def change_type(self) -> Optional[str]:
        return pulumi.get(self, "change_type")

    @property
    @pulumi.getter(name="compareTo")
    def compare_to(self) -> Optional[str]:
        """
        Choose from when to compare current data to. One of "hour_before", "day_before", "week_before" or "month_before".
        """
        return pulumi.get(self, "compare_to")

    @property
    @pulumi.getter(name="increaseGood")
    def increase_good(self) -> Optional[bool]:
        """
        Boolean indicating whether an increase in the value is good (thus displayed in green) or not (thus displayed in red).
        """
        return pulumi.get(self, "increase_good")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="orderBy")
    def order_by(self) -> Optional[str]:
        """
        One of "change", "name", "present" (present value) or "past" (past value).
        """
        return pulumi.get(self, "order_by")

    @property
    @pulumi.getter(name="orderDir")
    def order_dir(self) -> Optional[str]:
        """
        Either "asc" (ascending) or "desc" (descending).
        """
        return pulumi.get(self, "order_dir")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="showPresent")
    def show_present(self) -> Optional[bool]:
        """
        If set to "true", displays current value.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `check_status_definition`: The definition for a Check Status widget. Exactly one nested block is allowed with the following structure:
        """
        return pulumi.get(self, "show_present")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuerySearch'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupByArgs'] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy']]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuerySearch'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupByArgs'] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy']]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery(dict):
    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[List[str]] = None,
                 limit: Optional[float] = None,
                 search_by: Optional[str] = None):
        """
        :param float limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[List[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionTime(dict):
    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition(dict):
    def __init__(__self__, *,
                 check: str,
                 grouping: str,
                 group: Optional[str] = None,
                 group_bies: Optional[List[str]] = None,
                 tags: Optional[List[str]] = None,
                 time: Optional['outputs.DashboardWidgetGroupDefinitionWidgetCheckStatusDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str check: The check to use in the widget.
        :param str grouping: Either "check" or "cluster", depending on whether the widget should use a single check or a cluster of checks.
        :param str group: The check group to use in the widget.
        :param List[str] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param List[str] tags: List of tags to use in the widget.
               - `title`: (Optional) The title of the widget.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `distribution_definition`: The definition for a Distribution widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        :param str title: Title of the dashboard.
        """
        pulumi.set(__self__, "check", check)
        pulumi.set(__self__, "grouping", grouping)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def check(self) -> str:
        """
        The check to use in the widget.
        """
        return pulumi.get(self, "check")

    @property
    @pulumi.getter
    def grouping(self) -> str:
        """
        Either "check" or "cluster", depending on whether the widget should use a single check or a cluster of checks.
        """
        return pulumi.get(self, "grouping")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        The check group to use in the widget.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List[str]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def tags(self) -> Optional[List[str]]:
        """
        List of tags to use in the widget.
        - `title`: (Optional) The title of the widget.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `distribution_definition`: The definition for a Distribution widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetCheckStatusDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetCheckStatusDefinitionTime(dict):
    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinition(dict):
    def __init__(__self__, *,
                 legend_size: Optional[str] = None,
                 requests: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest']] = None,
                 show_legend: Optional[bool] = None,
                 time: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str title: Title of the dashboard.
        """
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[str]:
        return pulumi.get(self, "legend_size")

    @property
    @pulumi.getter
    def requests(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[bool]:
        return pulumi.get(self, "show_legend")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest(dict):
    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyle'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyleArgs' style: Style of the widget graph. One nested block is allowed with the following structure:
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyle']:
        """
        Style of the widget graph. One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "style")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuerySearch'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupByArgs'] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param 'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy']]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuerySearch'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupByArgs'] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param 'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy']]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery(dict):
    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[List[str]] = None,
                 limit: Optional[float] = None,
                 search_by: Optional[str] = None):
        """
        :param float limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[List[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 palette: Optional[str] = None):
        """
        :param str palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
               - `q`: (Required) The event query to use in the widget.
               - `tags_execution`: (Optional) The execution method for multi-value filters.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
        - `q`: (Required) The event query to use in the widget.
        - `tags_execution`: (Optional) The execution method for multi-value filters.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "palette")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionTime(dict):
    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetEventStreamDefinition(dict):
    def __init__(__self__, *,
                 query: str,
                 event_size: Optional[str] = None,
                 tags_execution: Optional[str] = None,
                 time: Optional['outputs.DashboardWidgetGroupDefinitionWidgetEventStreamDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str event_size: The size of the events in the widget. Either "s" (small, title only) or "l" (large, full event).
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `tags_execution`: (Optional) The execution method for multi-value filters. Can be either "and" or "or".
               - `event_timeline_definition`: The definition for a Event Timeline widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `tags_execution`: (Optional) The execution method for multi-value filters. Can be either "and" or "or".
               - `free_text_definition`: The definition for a Free Text. Exactly one nested block is allowed with the following structure:
        :param str title: Title of the dashboard.
        """
        pulumi.set(__self__, "query", query)
        if event_size is not None:
            pulumi.set(__self__, "event_size", event_size)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="eventSize")
    def event_size(self) -> Optional[str]:
        """
        The size of the events in the widget. Either "s" (small, title only) or "l" (large, full event).
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `tags_execution`: (Optional) The execution method for multi-value filters. Can be either "and" or "or".
        - `event_timeline_definition`: The definition for a Event Timeline widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `tags_execution`: (Optional) The execution method for multi-value filters. Can be either "and" or "or".
        - `free_text_definition`: The definition for a Free Text. Exactly one nested block is allowed with the following structure:
        """
        return pulumi.get(self, "event_size")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        return pulumi.get(self, "tags_execution")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetEventStreamDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetEventStreamDefinitionTime(dict):
    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition(dict):
    def __init__(__self__, *,
                 query: str,
                 tags_execution: Optional[str] = None,
                 time: Optional['outputs.DashboardWidgetGroupDefinitionWidgetEventTimelineDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str title: Title of the dashboard.
        """
        pulumi.set(__self__, "query", query)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        return pulumi.get(self, "tags_execution")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetEventTimelineDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetEventTimelineDefinitionTime(dict):
    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetFreeTextDefinition(dict):
    def __init__(__self__, *,
                 text: str,
                 color: Optional[str] = None,
                 font_size: Optional[str] = None,
                 text_align: Optional[str] = None):
        """
        :param str text: The text to display in the widget.
        :param str color: The color of the text in the widget.
        :param str font_size: The size of the text in the widget.
        :param str text_align: The alignment of the text in the widget.
               - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
               - `q`: (Optional) The metric query to use in the widget
               - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
               - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
               - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        pulumi.set(__self__, "text", text)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if font_size is not None:
            pulumi.set(__self__, "font_size", font_size)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)

    @property
    @pulumi.getter
    def text(self) -> str:
        """
        The text to display in the widget.
        """
        return pulumi.get(self, "text")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        """
        The color of the text in the widget.
        """
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[str]:
        """
        The size of the text in the widget.
        """
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        """
        The alignment of the text in the widget.
        - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
        - `q`: (Optional) The metric query to use in the widget
        - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
        - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
        - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "text_align")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinition(dict):
    def __init__(__self__, *,
                 events: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent']] = None,
                 legend_size: Optional[str] = None,
                 requests: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest']] = None,
                 show_legend: Optional[bool] = None,
                 time: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 yaxis: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis'] = None):
        """
        :param str title: Title of the dashboard.
        """
        if events is not None:
            pulumi.set(__self__, "events", events)
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter
    def events(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent']]:
        return pulumi.get(self, "events")

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[str]:
        return pulumi.get(self, "legend_size")

    @property
    @pulumi.getter
    def requests(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[bool]:
        return pulumi.get(self, "show_legend")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis']:
        return pulumi.get(self, "yaxis")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent(dict):
    def __init__(__self__, *,
                 q: str,
                 tags_execution: Optional[str] = None):
        pulumi.set(__self__, "q", q)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)

    @property
    @pulumi.getter
    def q(self) -> str:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        return pulumi.get(self, "tags_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest(dict):
    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyle'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyleArgs' style: Style of the widget graph. One nested block is allowed with the following structure:
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyle']:
        """
        Style of the widget graph. One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "style")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuerySearch'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupByArgs'] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param 'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy']]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuerySearch'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupByArgs'] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param 'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy']]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery(dict):
    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[List[str]] = None,
                 limit: Optional[float] = None,
                 search_by: Optional[str] = None):
        """
        :param float limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[List[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 palette: Optional[str] = None):
        """
        :param str palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
               - `q`: (Required) The event query to use in the widget.
               - `tags_execution`: (Optional) The execution method for multi-value filters.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
        - `q`: (Required) The event query to use in the widget.
        - `tags_execution`: (Optional) The execution method for multi-value filters.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "palette")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionTime(dict):
    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis(dict):
    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label of the axis to display on the graph.
        :param str max: Specify the minimum value to show on y-axis.
        :param str min: Specify the minimum value to show on y-axis.
        :param str scale: Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        return pulumi.get(self, "scale")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinition(dict):
    def __init__(__self__, *,
                 groups: Optional[List[str]] = None,
                 no_group_hosts: Optional[bool] = None,
                 no_metric_hosts: Optional[bool] = None,
                 node_type: Optional[str] = None,
                 request: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequest'] = None,
                 scopes: Optional[List[str]] = None,
                 style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param List[str] groups: The check group to use in the widget.
        :param bool no_group_hosts: Boolean indicating whether to show ungrouped nodes.
        :param bool no_metric_hosts: Boolean indicating whether to show nodes with no metrics.
        :param str node_type: The type of node used. Either "host" or "container".
        :param List[str] scopes: The list of tags to filter nodes by.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyleArgs' style: Style of the widget graph. One nested block is allowed with the following structure:
        :param str title: Title of the dashboard.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if no_group_hosts is not None:
            pulumi.set(__self__, "no_group_hosts", no_group_hosts)
        if no_metric_hosts is not None:
            pulumi.set(__self__, "no_metric_hosts", no_metric_hosts)
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def groups(self) -> Optional[List[str]]:
        """
        The check group to use in the widget.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter(name="noGroupHosts")
    def no_group_hosts(self) -> Optional[bool]:
        """
        Boolean indicating whether to show ungrouped nodes.
        """
        return pulumi.get(self, "no_group_hosts")

    @property
    @pulumi.getter(name="noMetricHosts")
    def no_metric_hosts(self) -> Optional[bool]:
        """
        Boolean indicating whether to show nodes with no metrics.
        """
        return pulumi.get(self, "no_metric_hosts")

    @property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[str]:
        """
        The type of node used. Either "host" or "container".
        """
        return pulumi.get(self, "node_type")

    @property
    @pulumi.getter
    def request(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequest']:
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[List[str]]:
        """
        The list of tags to filter nodes by.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle']:
        """
        Style of the widget graph. One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "style")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequest(dict):
    def __init__(__self__, *,
                 fills: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill']] = None,
                 sizes: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize']] = None):
        if fills is not None:
            pulumi.set(__self__, "fills", fills)
        if sizes is not None:
            pulumi.set(__self__, "sizes", sizes)

    @property
    @pulumi.getter
    def fills(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill']]:
        return pulumi.get(self, "fills")

    @property
    @pulumi.getter
    def sizes(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize']]:
        return pulumi.get(self, "sizes")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill(dict):
    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery'] = None,
                 q: Optional[str] = None):
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuerySearch'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupByArgs'] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy']]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuerySearch'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupByArgs'] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy']]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery(dict):
    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[List[str]] = None,
                 limit: Optional[float] = None,
                 search_by: Optional[str] = None):
        """
        :param float limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[List[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize(dict):
    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery'] = None,
                 q: Optional[str] = None):
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuerySearch'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupByArgs'] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy']]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuerySearch'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupByArgs'] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy']]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery(dict):
    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[List[str]] = None,
                 limit: Optional[float] = None,
                 search_by: Optional[str] = None):
        """
        :param float limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[List[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle(dict):
    def __init__(__self__, *,
                 fill_max: Optional[str] = None,
                 fill_min: Optional[str] = None,
                 palette: Optional[str] = None,
                 palette_flip: Optional[bool] = None):
        """
        :param str fill_max: Max value to use to color the map.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `iframe_definition`: The definition for a Iframe widget. Exactly one nested block is allowed with the following structure:
        :param str fill_min: Min value to use to color the map.
        :param str palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
               - `q`: (Required) The event query to use in the widget.
               - `tags_execution`: (Optional) The execution method for multi-value filters.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        :param bool palette_flip: Boolean indicating whether to flip the palette tones.
        """
        if fill_max is not None:
            pulumi.set(__self__, "fill_max", fill_max)
        if fill_min is not None:
            pulumi.set(__self__, "fill_min", fill_min)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_flip is not None:
            pulumi.set(__self__, "palette_flip", palette_flip)

    @property
    @pulumi.getter(name="fillMax")
    def fill_max(self) -> Optional[str]:
        """
        Max value to use to color the map.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `iframe_definition`: The definition for a Iframe widget. Exactly one nested block is allowed with the following structure:
        """
        return pulumi.get(self, "fill_max")

    @property
    @pulumi.getter(name="fillMin")
    def fill_min(self) -> Optional[str]:
        """
        Min value to use to color the map.
        """
        return pulumi.get(self, "fill_min")

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
        - `q`: (Required) The event query to use in the widget.
        - `tags_execution`: (Optional) The execution method for multi-value filters.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteFlip")
    def palette_flip(self) -> Optional[bool]:
        """
        Boolean indicating whether to flip the palette tones.
        """
        return pulumi.get(self, "palette_flip")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetIframeDefinition(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: Read only field - The URL of the dashboard.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Read only field - The URL of the dashboard.
        """
        return pulumi.get(self, "url")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetImageDefinition(dict):
    def __init__(__self__, *,
                 url: str,
                 margin: Optional[str] = None,
                 sizing: Optional[str] = None):
        """
        :param str url: Read only field - The URL of the dashboard.
        :param str margin: The margins to use around the image. Either "small" or "large".
               - `log_stream_definition`: The definition for a Log Stream widget. Exactly one nested block is allowed with the following structure:
        :param str sizing: The preferred method to adapt the dimensions of the image to those of the widget. One of "center" (center the image in the tile), "zoom" (zoom the image to cover the whole tile) or "fit" (fit the image dimensions to those of the tile).
        """
        pulumi.set(__self__, "url", url)
        if margin is not None:
            pulumi.set(__self__, "margin", margin)
        if sizing is not None:
            pulumi.set(__self__, "sizing", sizing)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Read only field - The URL of the dashboard.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def margin(self) -> Optional[str]:
        """
        The margins to use around the image. Either "small" or "large".
        - `log_stream_definition`: The definition for a Log Stream widget. Exactly one nested block is allowed with the following structure:
        """
        return pulumi.get(self, "margin")

    @property
    @pulumi.getter
    def sizing(self) -> Optional[str]:
        """
        The preferred method to adapt the dimensions of the image to those of the widget. One of "center" (center the image in the tile), "zoom" (zoom the image to cover the whole tile) or "fit" (fit the image dimensions to those of the tile).
        """
        return pulumi.get(self, "sizing")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetLayout(dict):
    def __init__(__self__, *,
                 height: float,
                 width: float,
                 x: float,
                 y: float):
        """
        :param float height: The height of the widget.
        :param float width: The width of the widget.
        :param float x: The position of the widget on the x (horizontal) axis. Should be greater or equal to 0.
        :param float y: The position of the widget on the y (vertical) axis. Should be greater or equal to 0.
        """
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "width", width)
        pulumi.set(__self__, "x", x)
        pulumi.set(__self__, "y", y)

    @property
    @pulumi.getter
    def height(self) -> float:
        """
        The height of the widget.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def width(self) -> float:
        """
        The width of the widget.
        """
        return pulumi.get(self, "width")

    @property
    @pulumi.getter
    def x(self) -> float:
        """
        The position of the widget on the x (horizontal) axis. Should be greater or equal to 0.
        """
        return pulumi.get(self, "x")

    @property
    @pulumi.getter
    def y(self) -> float:
        """
        The position of the widget on the y (vertical) axis. Should be greater or equal to 0.
        """
        return pulumi.get(self, "y")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetLogStreamDefinition(dict):
    def __init__(__self__, *,
                 columns: Optional[List[str]] = None,
                 indexes: Optional[List[str]] = None,
                 logset: Optional[str] = None,
                 message_display: Optional[str] = None,
                 query: Optional[str] = None,
                 show_date_column: Optional[bool] = None,
                 show_message_column: Optional[bool] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSort'] = None,
                 time: Optional['outputs.DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param List[str] columns: Stringified list of columns to use. Example: `"["column1","column2","column3"]"`.
        :param str logset: ID of the logset to use.
               - `query`: (Optional) The query to use in the widget.
        :param str message_display: The amount of lines the message column should display. One of: `inline`, `expanded-md`, and `expanded-lg`.
        :param bool show_date_column: If the date column should be displayed.
        :param bool show_message_column: If the message column should be displayed.
        :param 'DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        :param str title: Title of the dashboard.
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if logset is not None:
            pulumi.set(__self__, "logset", logset)
        if message_display is not None:
            pulumi.set(__self__, "message_display", message_display)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if show_date_column is not None:
            pulumi.set(__self__, "show_date_column", show_date_column)
        if show_message_column is not None:
            pulumi.set(__self__, "show_message_column", show_message_column)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def columns(self) -> Optional[List[str]]:
        """
        Stringified list of columns to use. Example: `"["column1","column2","column3"]"`.
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[List[str]]:
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def logset(self) -> Optional[str]:
        """
        ID of the logset to use.
        - `query`: (Optional) The query to use in the widget.
        """
        return pulumi.get(self, "logset")

    @property
    @pulumi.getter(name="messageDisplay")
    def message_display(self) -> Optional[str]:
        """
        The amount of lines the message column should display. One of: `inline`, `expanded-md`, and `expanded-lg`.
        """
        return pulumi.get(self, "message_display")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="showDateColumn")
    def show_date_column(self) -> Optional[bool]:
        """
        If the date column should be displayed.
        """
        return pulumi.get(self, "show_date_column")

    @property
    @pulumi.getter(name="showMessageColumn")
    def show_message_column(self) -> Optional[bool]:
        """
        If the message column should be displayed.
        """
        return pulumi.get(self, "show_message_column")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSort(dict):
    def __init__(__self__, *,
                 column: str,
                 order: str):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def column(self) -> str:
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionTime(dict):
    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetManageStatusDefinition(dict):
    def __init__(__self__, *,
                 query: str,
                 color_preference: Optional[str] = None,
                 count: Optional[float] = None,
                 display_format: Optional[str] = None,
                 hide_zero_counts: Optional[bool] = None,
                 show_last_triggered: Optional[bool] = None,
                 sort: Optional[str] = None,
                 start: Optional[float] = None,
                 summary_type: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str color_preference: Whether to colorize text or background. One of "text", "background".
        :param str display_format: The display setting to use. One of "counts", "list", or "countsAndList".
        :param bool hide_zero_counts: Boolean indicating whether to hide empty categories.
        :param bool show_last_triggered: Boolean indicating whether to show when monitors/groups last triggered.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `note_definition`: The definition for a Note widget. Exactly one nested block is allowed with the following structure:
        :param str sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        :param str summary_type: The monitor summary type to use. One of "monitors", "groups", or "combined". Defaults to "monitors".
        :param str title: Title of the dashboard.
        """
        pulumi.set(__self__, "query", query)
        if color_preference is not None:
            pulumi.set(__self__, "color_preference", color_preference)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if display_format is not None:
            pulumi.set(__self__, "display_format", display_format)
        if hide_zero_counts is not None:
            pulumi.set(__self__, "hide_zero_counts", hide_zero_counts)
        if show_last_triggered is not None:
            pulumi.set(__self__, "show_last_triggered", show_last_triggered)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if start is not None:
            pulumi.set(__self__, "start", start)
        if summary_type is not None:
            pulumi.set(__self__, "summary_type", summary_type)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="colorPreference")
    def color_preference(self) -> Optional[str]:
        """
        Whether to colorize text or background. One of "text", "background".
        """
        return pulumi.get(self, "color_preference")

    @property
    @pulumi.getter
    def count(self) -> Optional[float]:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="displayFormat")
    def display_format(self) -> Optional[str]:
        """
        The display setting to use. One of "counts", "list", or "countsAndList".
        """
        return pulumi.get(self, "display_format")

    @property
    @pulumi.getter(name="hideZeroCounts")
    def hide_zero_counts(self) -> Optional[bool]:
        """
        Boolean indicating whether to hide empty categories.
        """
        return pulumi.get(self, "hide_zero_counts")

    @property
    @pulumi.getter(name="showLastTriggered")
    def show_last_triggered(self) -> Optional[bool]:
        """
        Boolean indicating whether to show when monitors/groups last triggered.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `note_definition`: The definition for a Note widget. Exactly one nested block is allowed with the following structure:
        """
        return pulumi.get(self, "show_last_triggered")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter
    def start(self) -> Optional[float]:
        return pulumi.get(self, "start")

    @property
    @pulumi.getter(name="summaryType")
    def summary_type(self) -> Optional[str]:
        """
        The monitor summary type to use. One of "monitors", "groups", or "combined". Defaults to "monitors".
        """
        return pulumi.get(self, "summary_type")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetNoteDefinition(dict):
    def __init__(__self__, *,
                 content: str,
                 background_color: Optional[str] = None,
                 font_size: Optional[str] = None,
                 show_tick: Optional[bool] = None,
                 text_align: Optional[str] = None,
                 tick_edge: Optional[str] = None,
                 tick_pos: Optional[str] = None):
        """
        :param str content: Content of the note.
        :param str background_color: Background color of the note.
        :param str font_size: The size of the text in the widget.
        :param bool show_tick: Whether to show a tick or not.
        :param str text_align: The alignment of the text in the widget.
               - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
               - `q`: (Optional) The metric query to use in the widget
               - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
               - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
               - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        :param str tick_edge: When tick = true, string indicating on which side of the widget the tick should be displayed. One of "bottom", "top", "left", "right".
               - `query_value_definition`: The definition for a Query Value widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
               - `q`: (Optional) The metric query to use in the widget.
               - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
               - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
               - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        :param str tick_pos: When tick = true, string with a percent sign indicating the position of the tick. Example: use tick_pos = "50%" for centered alignment.
        """
        pulumi.set(__self__, "content", content)
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if font_size is not None:
            pulumi.set(__self__, "font_size", font_size)
        if show_tick is not None:
            pulumi.set(__self__, "show_tick", show_tick)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if tick_edge is not None:
            pulumi.set(__self__, "tick_edge", tick_edge)
        if tick_pos is not None:
            pulumi.set(__self__, "tick_pos", tick_pos)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        Content of the note.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[str]:
        """
        Background color of the note.
        """
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[str]:
        """
        The size of the text in the widget.
        """
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter(name="showTick")
    def show_tick(self) -> Optional[bool]:
        """
        Whether to show a tick or not.
        """
        return pulumi.get(self, "show_tick")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        """
        The alignment of the text in the widget.
        - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
        - `q`: (Optional) The metric query to use in the widget
        - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
        - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
        - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "text_align")

    @property
    @pulumi.getter(name="tickEdge")
    def tick_edge(self) -> Optional[str]:
        """
        When tick = true, string indicating on which side of the widget the tick should be displayed. One of "bottom", "top", "left", "right".
        - `query_value_definition`: The definition for a Query Value widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
        - `q`: (Optional) The metric query to use in the widget.
        - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
        - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
        - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "tick_edge")

    @property
    @pulumi.getter(name="tickPos")
    def tick_pos(self) -> Optional[str]:
        """
        When tick = true, string with a percent sign indicating the position of the tick. Example: use tick_pos = "50%" for centered alignment.
        """
        return pulumi.get(self, "tick_pos")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinition(dict):
    def __init__(__self__, *,
                 requests: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest']] = None,
                 time: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str title: Title of the dashboard.
        """
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def requests(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest(dict):
    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 alias: Optional[str] = None,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery'] = None,
                 conditional_formats: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormat']] = None,
                 limit: Optional[float] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery'] = None,
                 order: Optional[str] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None):
        """
        :param str aggregator: The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
               - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        :param str alias: The alias for the column name. Default is the metric name.
        :param List['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple request blocks are allowed. The structure of this block is described below.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `trace_service_definition`: The definition for a Trace Service widget. Exactly one nested block is allowed with the following structure:
               - `env`: (Required) APM environment.
               - `service`: (Required) APM service.
               - `span_name`: (Required) APM span name.
               - `show_hits`: (Optional) APM span name.
               - `show_hits`: (Optional) Whether to show the hits metrics or not.
               - `show_errors`: (Optional) Whether to show the error metrics or not.
               - `show_latency`: (Optional) Whether to show the latency metrics or not.
               - `show_breakdown`: (Optional) Whether to show the latency breakdown or not.
               - `show_distribution`: (Optional) Whether to show the latency distribution or not.
               - `show_resource_list`: (Optional) Whether to show the resource list or not.
               - `size_format`: (Optional) Size of the widget. Available values are: `small`, `medium`, or `large`.
               - `display_format`: (Optional) Number of columns to display. Available values are: `one_column`, `two_column`, or `three_column`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        :param float limit: The number of lines to show in the table.
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
        - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        The alias for the column name. Default is the metric name.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple request blocks are allowed. The structure of this block is described below.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `trace_service_definition`: The definition for a Trace Service widget. Exactly one nested block is allowed with the following structure:
        - `env`: (Required) APM environment.
        - `service`: (Required) APM service.
        - `span_name`: (Required) APM span name.
        - `show_hits`: (Optional) APM span name.
        - `show_hits`: (Optional) Whether to show the hits metrics or not.
        - `show_errors`: (Optional) Whether to show the error metrics or not.
        - `show_latency`: (Optional) Whether to show the latency metrics or not.
        - `show_breakdown`: (Optional) Whether to show the latency breakdown or not.
        - `show_distribution`: (Optional) Whether to show the latency distribution or not.
        - `show_resource_list`: (Optional) Whether to show the resource list or not.
        - `size_format`: (Optional) Size of the widget. Available values are: `small`, `medium`, or `large`.
        - `display_format`: (Optional) Number of columns to display. Available values are: `one_column`, `two_column`, or `three_column`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuerySearch'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupByArgs'] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy']]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormat(dict):
    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: Comparator to apply from: One of `>`, `>=`, `<`, or `<=`.
        :param str palette: Color palette to apply; One of `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `green`, `green_on_white`, `grey`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `white_on_red`, `white_on_yellow`, or `yellow_on_white`.
        :param float value: Value for the comparator.
        :param str custom_bg_color: Color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: Color palette to apply to the foreground, same values available as palette.
        :param str image_url: Displays an image as the background.
               .
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        Comparator to apply from: One of `>`, `>=`, `<`, or `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        Color palette to apply; One of `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `green`, `green_on_white`, `grey`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `white_on_red`, `white_on_yellow`, or `yellow_on_white`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        Value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        Color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        Color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        .
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        return pulumi.get(self, "timeframe")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuerySearch'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupByArgs'] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy']]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery(dict):
    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[List[str]] = None,
                 limit: Optional[float] = None,
                 search_by: Optional[str] = None):
        """
        :param float limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[List[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionTime(dict):
    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinition(dict):
    def __init__(__self__, *,
                 autoscale: Optional[bool] = None,
                 custom_unit: Optional[str] = None,
                 precision: Optional[float] = None,
                 requests: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest']] = None,
                 text_align: Optional[str] = None,
                 time: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param bool autoscale: Boolean indicating whether to automatically scale the tile.
        :param str custom_unit: The unit for the value displayed in the widget.
        :param float precision: The precision to use when displaying the tile.
        :param str text_align: The alignment of the text in the widget.
               - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
               - `q`: (Optional) The metric query to use in the widget
               - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
               - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
               - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        :param str title: Title of the dashboard.
        """
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if custom_unit is not None:
            pulumi.set(__self__, "custom_unit", custom_unit)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional[bool]:
        """
        Boolean indicating whether to automatically scale the tile.
        """
        return pulumi.get(self, "autoscale")

    @property
    @pulumi.getter(name="customUnit")
    def custom_unit(self) -> Optional[str]:
        """
        The unit for the value displayed in the widget.
        """
        return pulumi.get(self, "custom_unit")

    @property
    @pulumi.getter
    def precision(self) -> Optional[float]:
        """
        The precision to use when displaying the tile.
        """
        return pulumi.get(self, "precision")

    @property
    @pulumi.getter
    def requests(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        """
        The alignment of the text in the widget.
        - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
        - `q`: (Optional) The metric query to use in the widget
        - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
        - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
        - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "text_align")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest(dict):
    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery'] = None,
                 conditional_formats: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormat']] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None):
        """
        :param str aggregator: The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
               - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        :param List['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple request blocks are allowed. The structure of this block is described below.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `trace_service_definition`: The definition for a Trace Service widget. Exactly one nested block is allowed with the following structure:
               - `env`: (Required) APM environment.
               - `service`: (Required) APM service.
               - `span_name`: (Required) APM span name.
               - `show_hits`: (Optional) APM span name.
               - `show_hits`: (Optional) Whether to show the hits metrics or not.
               - `show_errors`: (Optional) Whether to show the error metrics or not.
               - `show_latency`: (Optional) Whether to show the latency metrics or not.
               - `show_breakdown`: (Optional) Whether to show the latency breakdown or not.
               - `show_distribution`: (Optional) Whether to show the latency distribution or not.
               - `show_resource_list`: (Optional) Whether to show the resource list or not.
               - `size_format`: (Optional) Size of the widget. Available values are: `small`, `medium`, or `large`.
               - `display_format`: (Optional) Number of columns to display. Available values are: `one_column`, `two_column`, or `three_column`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
        - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple request blocks are allowed. The structure of this block is described below.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `trace_service_definition`: The definition for a Trace Service widget. Exactly one nested block is allowed with the following structure:
        - `env`: (Required) APM environment.
        - `service`: (Required) APM service.
        - `span_name`: (Required) APM span name.
        - `show_hits`: (Optional) APM span name.
        - `show_hits`: (Optional) Whether to show the hits metrics or not.
        - `show_errors`: (Optional) Whether to show the error metrics or not.
        - `show_latency`: (Optional) Whether to show the latency metrics or not.
        - `show_breakdown`: (Optional) Whether to show the latency breakdown or not.
        - `show_distribution`: (Optional) Whether to show the latency distribution or not.
        - `show_resource_list`: (Optional) Whether to show the resource list or not.
        - `size_format`: (Optional) Size of the widget. Available values are: `small`, `medium`, or `large`.
        - `display_format`: (Optional) Number of columns to display. Available values are: `one_column`, `two_column`, or `three_column`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuerySearch'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupByArgs'] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy']]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormat(dict):
    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: Comparator to apply from: One of `>`, `>=`, `<`, or `<=`.
        :param str palette: Color palette to apply; One of `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `green`, `green_on_white`, `grey`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `white_on_red`, `white_on_yellow`, or `yellow_on_white`.
        :param float value: Value for the comparator.
        :param str custom_bg_color: Color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: Color palette to apply to the foreground, same values available as palette.
        :param str image_url: Displays an image as the background.
               .
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        Comparator to apply from: One of `>`, `>=`, `<`, or `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        Color palette to apply; One of `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `green`, `green_on_white`, `grey`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `white_on_red`, `white_on_yellow`, or `yellow_on_white`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        Value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        Color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        Color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        .
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        return pulumi.get(self, "timeframe")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuerySearch'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupByArgs'] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy']]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery(dict):
    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[List[str]] = None,
                 limit: Optional[float] = None,
                 search_by: Optional[str] = None):
        """
        :param float limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[List[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTime(dict):
    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinition(dict):
    def __init__(__self__, *,
                 color_by_groups: Optional[List[str]] = None,
                 request: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequest'] = None,
                 time: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 xaxis: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis'] = None,
                 yaxis: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis'] = None):
        """
        :param List[str] color_by_groups: List of groups used for colors.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `servicemap_definition`: The definition for a Service Map widget. Exactly one nested block is allowed with the following structure:
               - `filters`: (Required) Your environment and primary tag (or * if enabled for your account).
               - `service`: (Required) The ID of the service you want to map.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `service_level_objective_definition`: The definition for a Service Level Objective widget. Exactly one nested block is allowed with the following structure:
               - `view_type`: (Required) Type of view to use when displaying the widget. Only "detail" is currently supported.
               - `slo_id`: (Required) The ID of the service level objective used by the widget.
               - `show_error_budget`: (Optional) Whether to show the error budget or not.
               - `view_mode`: (Required) View mode for the widget. One of "overall", "component", or "both".
               - `time_windows`: (Required) List of time windows to display in the widget. Each value in the list must be one of "7d", "30d", "90d", "week_to_date",  "previous_week", "month_to_date", or "previous_month".
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `timeseries_definition`: The definition for a Timeseries  widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
               - `q`: (Optional) The metric query to use in the widget.
               - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
               - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
               - `network_query`: (Optional) The network query to use in the widget. The structure of this block is described below.
               - `rum_query`: (Optional) The rum query to use in the widget. The structure of this block is described below.
               - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        :param str title: Title of the dashboard.
        """
        if color_by_groups is not None:
            pulumi.set(__self__, "color_by_groups", color_by_groups)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if xaxis is not None:
            pulumi.set(__self__, "xaxis", xaxis)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter(name="colorByGroups")
    def color_by_groups(self) -> Optional[List[str]]:
        """
        List of groups used for colors.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `servicemap_definition`: The definition for a Service Map widget. Exactly one nested block is allowed with the following structure:
        - `filters`: (Required) Your environment and primary tag (or * if enabled for your account).
        - `service`: (Required) The ID of the service you want to map.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `service_level_objective_definition`: The definition for a Service Level Objective widget. Exactly one nested block is allowed with the following structure:
        - `view_type`: (Required) Type of view to use when displaying the widget. Only "detail" is currently supported.
        - `slo_id`: (Required) The ID of the service level objective used by the widget.
        - `show_error_budget`: (Optional) Whether to show the error budget or not.
        - `view_mode`: (Required) View mode for the widget. One of "overall", "component", or "both".
        - `time_windows`: (Required) List of time windows to display in the widget. Each value in the list must be one of "7d", "30d", "90d", "week_to_date",  "previous_week", "month_to_date", or "previous_month".
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `timeseries_definition`: The definition for a Timeseries  widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
        - `q`: (Optional) The metric query to use in the widget.
        - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
        - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
        - `network_query`: (Optional) The network query to use in the widget. The structure of this block is described below.
        - `rum_query`: (Optional) The rum query to use in the widget. The structure of this block is described below.
        - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "color_by_groups")

    @property
    @pulumi.getter
    def request(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequest']:
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def xaxis(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis']:
        return pulumi.get(self, "xaxis")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis']:
        return pulumi.get(self, "yaxis")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequest(dict):
    def __init__(__self__, *,
                 xes: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX']] = None,
                 ys: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY']] = None):
        """
        :param List['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXArgs'] xes: The position of the widget on the x (horizontal) axis. Should be greater or equal to 0.
        :param List['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYArgs'] ys: The position of the widget on the y (vertical) axis. Should be greater or equal to 0.
        """
        if xes is not None:
            pulumi.set(__self__, "xes", xes)
        if ys is not None:
            pulumi.set(__self__, "ys", ys)

    @property
    @pulumi.getter
    def xes(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX']]:
        """
        The position of the widget on the x (horizontal) axis. Should be greater or equal to 0.
        """
        return pulumi.get(self, "xes")

    @property
    @pulumi.getter
    def ys(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY']]:
        """
        The position of the widget on the y (vertical) axis. Should be greater or equal to 0.
        """
        return pulumi.get(self, "ys")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX(dict):
    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery'] = None,
                 q: Optional[str] = None):
        """
        :param str aggregator: The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
               - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
        - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuerySearch'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupByArgs'] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy']]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuerySearch'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupByArgs'] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy']]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery(dict):
    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[List[str]] = None,
                 limit: Optional[float] = None,
                 search_by: Optional[str] = None):
        """
        :param float limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[List[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY(dict):
    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery'] = None,
                 q: Optional[str] = None):
        """
        :param str aggregator: The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
               - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
        - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuerySearch'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupByArgs'] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy']]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuerySearch'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupByArgs'] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy']]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery(dict):
    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[List[str]] = None,
                 limit: Optional[float] = None,
                 search_by: Optional[str] = None):
        """
        :param float limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[List[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionTime(dict):
    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis(dict):
    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label of the axis to display on the graph.
        :param str max: Specify the minimum value to show on y-axis.
        :param str min: Specify the minimum value to show on y-axis.
        :param str scale: Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        return pulumi.get(self, "scale")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis(dict):
    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label of the axis to display on the graph.
        :param str max: Specify the minimum value to show on y-axis.
        :param str min: Specify the minimum value to show on y-axis.
        :param str scale: Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        return pulumi.get(self, "scale")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition(dict):
    def __init__(__self__, *,
                 slo_id: str,
                 time_windows: List[str],
                 view_mode: str,
                 view_type: str,
                 show_error_budget: Optional[bool] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str title: Title of the dashboard.
        """
        pulumi.set(__self__, "slo_id", slo_id)
        pulumi.set(__self__, "time_windows", time_windows)
        pulumi.set(__self__, "view_mode", view_mode)
        pulumi.set(__self__, "view_type", view_type)
        if show_error_budget is not None:
            pulumi.set(__self__, "show_error_budget", show_error_budget)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> List[str]:
        return pulumi.get(self, "time_windows")

    @property
    @pulumi.getter(name="viewMode")
    def view_mode(self) -> str:
        return pulumi.get(self, "view_mode")

    @property
    @pulumi.getter(name="viewType")
    def view_type(self) -> str:
        return pulumi.get(self, "view_type")

    @property
    @pulumi.getter(name="showErrorBudget")
    def show_error_budget(self) -> Optional[bool]:
        return pulumi.get(self, "show_error_budget")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetServicemapDefinition(dict):
    def __init__(__self__, *,
                 filters: List[str],
                 service: str,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str title: Title of the dashboard.
        """
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "service", service)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def filters(self) -> List[str]:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def service(self) -> str:
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition(dict):
    def __init__(__self__, *,
                 events: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent']] = None,
                 legend_size: Optional[str] = None,
                 markers: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker']] = None,
                 requests: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest']] = None,
                 show_legend: Optional[bool] = None,
                 time: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 yaxis: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis'] = None):
        """
        :param List['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarkerArgs'] markers: Nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple marker blocks are allowed within a given tile_def block.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
               - `q`: (Required) The event query to use in the widget.
               - `tags_execution`: (Optional) The execution method for multi-value filters.
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
               - `toplist_definition`: The definition for a Toplist  widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
               - `q`: (Optional) The metric query to use in the widget.
               - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
               - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
               - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        :param str title: Title of the dashboard.
        """
        if events is not None:
            pulumi.set(__self__, "events", events)
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if markers is not None:
            pulumi.set(__self__, "markers", markers)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter
    def events(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent']]:
        return pulumi.get(self, "events")

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[str]:
        return pulumi.get(self, "legend_size")

    @property
    @pulumi.getter
    def markers(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker']]:
        """
        Nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple marker blocks are allowed within a given tile_def block.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
        - `q`: (Required) The event query to use in the widget.
        - `tags_execution`: (Optional) The execution method for multi-value filters.
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        - `toplist_definition`: The definition for a Toplist  widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
        - `q`: (Optional) The metric query to use in the widget.
        - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
        - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
        - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "markers")

    @property
    @pulumi.getter
    def requests(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[bool]:
        return pulumi.get(self, "show_legend")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis']:
        return pulumi.get(self, "yaxis")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent(dict):
    def __init__(__self__, *,
                 q: str,
                 tags_execution: Optional[str] = None):
        pulumi.set(__self__, "q", q)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)

    @property
    @pulumi.getter
    def q(self) -> str:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        return pulumi.get(self, "tags_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker(dict):
    def __init__(__self__, *,
                 value: str,
                 display_type: Optional[str] = None,
                 label: Optional[str] = None):
        """
        :param str value: Value for the comparator.
        :param str display_type: Type of display to use for the request. Available values are: `area`, `bars`, or `line`.
        :param str label: The label of the axis to display on the graph.
        """
        pulumi.set(__self__, "value", value)
        if display_type is not None:
            pulumi.set(__self__, "display_type", display_type)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="displayType")
    def display_type(self) -> Optional[str]:
        """
        Type of display to use for the request. Available values are: `area`, `bars`, or `line`.
        """
        return pulumi.get(self, "display_type")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest(dict):
    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery'] = None,
                 display_type: Optional[str] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery'] = None,
                 metadatas: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata']] = None,
                 network_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery'] = None,
                 style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle'] = None):
        """
        :param str display_type: Type of display to use for the request. Available values are: `area`, `bars`, or `line`.
        :param List['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadataArgs'] metadatas: . Used to define expression aliases. Multiple nested blocks are allowed with the following structure:
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyleArgs' style: Style of the widget graph. One nested block is allowed with the following structure:
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if display_type is not None:
            pulumi.set(__self__, "display_type", display_type)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if network_query is not None:
            pulumi.set(__self__, "network_query", network_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="displayType")
    def display_type(self) -> Optional[str]:
        """
        Type of display to use for the request. Available values are: `area`, `bars`, or `line`.
        """
        return pulumi.get(self, "display_type")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata']]:
        """
        . Used to define expression aliases. Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter(name="networkQuery")
    def network_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery']:
        return pulumi.get(self, "network_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery']:
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle']:
        """
        Style of the widget graph. One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "style")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuerySearch'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupByArgs'] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy']]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuerySearch'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupByArgs'] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy']]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata(dict):
    def __init__(__self__, *,
                 expression: str,
                 alias_name: Optional[str] = None):
        pulumi.set(__self__, "expression", expression)
        if alias_name is not None:
            pulumi.set(__self__, "alias_name", alias_name)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="aliasName")
    def alias_name(self) -> Optional[str]:
        return pulumi.get(self, "alias_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuerySearch'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs'] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy']]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery(dict):
    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[List[str]] = None,
                 limit: Optional[float] = None,
                 search_by: Optional[str] = None):
        """
        :param float limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[List[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuerySearch'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupByArgs'] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy']]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 line_type: Optional[str] = None,
                 line_width: Optional[str] = None,
                 palette: Optional[str] = None):
        """
        :param str line_type: Type of lines displayed. Available values are: `dashed`, `dotted`, or `solid`.
        :param str line_width: Width of line displayed. Available values are: `normal`, `thick`, or `thin`.
        :param str palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
               - `q`: (Required) The event query to use in the widget.
               - `tags_execution`: (Optional) The execution method for multi-value filters.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        if line_type is not None:
            pulumi.set(__self__, "line_type", line_type)
        if line_width is not None:
            pulumi.set(__self__, "line_width", line_width)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter(name="lineType")
    def line_type(self) -> Optional[str]:
        """
        Type of lines displayed. Available values are: `dashed`, `dotted`, or `solid`.
        """
        return pulumi.get(self, "line_type")

    @property
    @pulumi.getter(name="lineWidth")
    def line_width(self) -> Optional[str]:
        """
        Width of line displayed. Available values are: `normal`, `thick`, or `thin`.
        """
        return pulumi.get(self, "line_width")

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
        - `q`: (Required) The event query to use in the widget.
        - `tags_execution`: (Optional) The execution method for multi-value filters.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "palette")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionTime(dict):
    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis(dict):
    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label of the axis to display on the graph.
        :param str max: Specify the minimum value to show on y-axis.
        :param str min: Specify the minimum value to show on y-axis.
        :param str scale: Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        return pulumi.get(self, "scale")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinition(dict):
    def __init__(__self__, *,
                 requests: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest']] = None,
                 time: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str title: Title of the dashboard.
        """
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def requests(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest(dict):
    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery'] = None,
                 conditional_formats: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormat']] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyle'] = None):
        """
        :param List['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple request blocks are allowed. The structure of this block is described below.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `trace_service_definition`: The definition for a Trace Service widget. Exactly one nested block is allowed with the following structure:
               - `env`: (Required) APM environment.
               - `service`: (Required) APM service.
               - `span_name`: (Required) APM span name.
               - `show_hits`: (Optional) APM span name.
               - `show_hits`: (Optional) Whether to show the hits metrics or not.
               - `show_errors`: (Optional) Whether to show the error metrics or not.
               - `show_latency`: (Optional) Whether to show the latency metrics or not.
               - `show_breakdown`: (Optional) Whether to show the latency breakdown or not.
               - `show_distribution`: (Optional) Whether to show the latency distribution or not.
               - `show_resource_list`: (Optional) Whether to show the resource list or not.
               - `size_format`: (Optional) Size of the widget. Available values are: `small`, `medium`, or `large`.
               - `display_format`: (Optional) Number of columns to display. Available values are: `one_column`, `two_column`, or `three_column`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyleArgs' style: Style of the widget graph. One nested block is allowed with the following structure:
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple request blocks are allowed. The structure of this block is described below.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `trace_service_definition`: The definition for a Trace Service widget. Exactly one nested block is allowed with the following structure:
        - `env`: (Required) APM environment.
        - `service`: (Required) APM service.
        - `span_name`: (Required) APM span name.
        - `show_hits`: (Optional) APM span name.
        - `show_hits`: (Optional) Whether to show the hits metrics or not.
        - `show_errors`: (Optional) Whether to show the error metrics or not.
        - `show_latency`: (Optional) Whether to show the latency metrics or not.
        - `show_breakdown`: (Optional) Whether to show the latency breakdown or not.
        - `show_distribution`: (Optional) Whether to show the latency distribution or not.
        - `show_resource_list`: (Optional) Whether to show the resource list or not.
        - `size_format`: (Optional) Size of the widget. Available values are: `small`, `medium`, or `large`.
        - `display_format`: (Optional) Number of columns to display. Available values are: `one_column`, `two_column`, or `three_column`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyle']:
        """
        Style of the widget graph. One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "style")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuerySearch'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupByArgs'] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy']]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormat(dict):
    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: Comparator to apply from: One of `>`, `>=`, `<`, or `<=`.
        :param str palette: Color palette to apply; One of `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `green`, `green_on_white`, `grey`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `white_on_red`, `white_on_yellow`, or `yellow_on_white`.
        :param float value: Value for the comparator.
        :param str custom_bg_color: Color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: Color palette to apply to the foreground, same values available as palette.
        :param str image_url: Displays an image as the background.
               .
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        Comparator to apply from: One of `>`, `>=`, `<`, or `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        Color palette to apply; One of `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `green`, `green_on_white`, `grey`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `white_on_red`, `white_on_yellow`, or `yellow_on_white`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        Value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        Color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        Color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        .
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        return pulumi.get(self, "timeframe")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuerySearch'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupByArgs'] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy']]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery(dict):
    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[List[str]] = None,
                 limit: Optional[float] = None,
                 search_by: Optional[str] = None):
        """
        :param float limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[List[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 palette: Optional[str] = None):
        """
        :param str palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
               - `q`: (Required) The event query to use in the widget.
               - `tags_execution`: (Optional) The execution method for multi-value filters.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
        - `q`: (Required) The event query to use in the widget.
        - `tags_execution`: (Optional) The execution method for multi-value filters.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "palette")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionTime(dict):
    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition(dict):
    def __init__(__self__, *,
                 env: str,
                 service: str,
                 span_name: str,
                 display_format: Optional[str] = None,
                 show_breakdown: Optional[bool] = None,
                 show_distribution: Optional[bool] = None,
                 show_errors: Optional[bool] = None,
                 show_hits: Optional[bool] = None,
                 show_latency: Optional[bool] = None,
                 show_resource_list: Optional[bool] = None,
                 size_format: Optional[str] = None,
                 time: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTraceServiceDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str display_format: The display setting to use. One of "counts", "list", or "countsAndList".
        :param str title: Title of the dashboard.
        """
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "span_name", span_name)
        if display_format is not None:
            pulumi.set(__self__, "display_format", display_format)
        if show_breakdown is not None:
            pulumi.set(__self__, "show_breakdown", show_breakdown)
        if show_distribution is not None:
            pulumi.set(__self__, "show_distribution", show_distribution)
        if show_errors is not None:
            pulumi.set(__self__, "show_errors", show_errors)
        if show_hits is not None:
            pulumi.set(__self__, "show_hits", show_hits)
        if show_latency is not None:
            pulumi.set(__self__, "show_latency", show_latency)
        if show_resource_list is not None:
            pulumi.set(__self__, "show_resource_list", show_resource_list)
        if size_format is not None:
            pulumi.set(__self__, "size_format", size_format)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def env(self) -> str:
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def service(self) -> str:
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="spanName")
    def span_name(self) -> str:
        return pulumi.get(self, "span_name")

    @property
    @pulumi.getter(name="displayFormat")
    def display_format(self) -> Optional[str]:
        """
        The display setting to use. One of "counts", "list", or "countsAndList".
        """
        return pulumi.get(self, "display_format")

    @property
    @pulumi.getter(name="showBreakdown")
    def show_breakdown(self) -> Optional[bool]:
        return pulumi.get(self, "show_breakdown")

    @property
    @pulumi.getter(name="showDistribution")
    def show_distribution(self) -> Optional[bool]:
        return pulumi.get(self, "show_distribution")

    @property
    @pulumi.getter(name="showErrors")
    def show_errors(self) -> Optional[bool]:
        return pulumi.get(self, "show_errors")

    @property
    @pulumi.getter(name="showHits")
    def show_hits(self) -> Optional[bool]:
        return pulumi.get(self, "show_hits")

    @property
    @pulumi.getter(name="showLatency")
    def show_latency(self) -> Optional[bool]:
        return pulumi.get(self, "show_latency")

    @property
    @pulumi.getter(name="showResourceList")
    def show_resource_list(self) -> Optional[bool]:
        return pulumi.get(self, "show_resource_list")

    @property
    @pulumi.getter(name="sizeFormat")
    def size_format(self) -> Optional[str]:
        return pulumi.get(self, "size_format")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTraceServiceDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTraceServiceDefinitionTime(dict):
    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHeatmapDefinition(dict):
    def __init__(__self__, *,
                 events: Optional[List['outputs.DashboardWidgetHeatmapDefinitionEvent']] = None,
                 legend_size: Optional[str] = None,
                 requests: Optional[List['outputs.DashboardWidgetHeatmapDefinitionRequest']] = None,
                 show_legend: Optional[bool] = None,
                 time: Optional['outputs.DashboardWidgetHeatmapDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 yaxis: Optional['outputs.DashboardWidgetHeatmapDefinitionYaxis'] = None):
        """
        :param str title: Title of the dashboard.
        """
        if events is not None:
            pulumi.set(__self__, "events", events)
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter
    def events(self) -> Optional[List['outputs.DashboardWidgetHeatmapDefinitionEvent']]:
        return pulumi.get(self, "events")

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[str]:
        return pulumi.get(self, "legend_size")

    @property
    @pulumi.getter
    def requests(self) -> Optional[List['outputs.DashboardWidgetHeatmapDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[bool]:
        return pulumi.get(self, "show_legend")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionYaxis']:
        return pulumi.get(self, "yaxis")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionEvent(dict):
    def __init__(__self__, *,
                 q: str,
                 tags_execution: Optional[str] = None):
        pulumi.set(__self__, "q", q)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)

    @property
    @pulumi.getter
    def q(self) -> str:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        return pulumi.get(self, "tags_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequest(dict):
    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 style: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestStyle'] = None):
        """
        :param 'DashboardWidgetHeatmapDefinitionRequestStyleArgs' style: Style of the widget graph. One nested block is allowed with the following structure:
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestStyle']:
        """
        Style of the widget graph. One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "style")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestApmQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestApmQuerySearch'] = None):
        """
        :param 'DashboardWidgetHeatmapDefinitionRequestApmQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetHeatmapDefinitionRequestApmQueryGroupByArgs'] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param 'DashboardWidgetHeatmapDefinitionRequestApmQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy']]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestApmQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestLogQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestLogQuerySearch'] = None):
        """
        :param 'DashboardWidgetHeatmapDefinitionRequestLogQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetHeatmapDefinitionRequestLogQueryGroupByArgs'] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param 'DashboardWidgetHeatmapDefinitionRequestLogQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy']]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestLogQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestProcessQuery(dict):
    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[List[str]] = None,
                 limit: Optional[float] = None,
                 search_by: Optional[str] = None):
        """
        :param float limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[List[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 palette: Optional[str] = None):
        """
        :param str palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
               - `q`: (Required) The event query to use in the widget.
               - `tags_execution`: (Optional) The execution method for multi-value filters.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
        - `q`: (Required) The event query to use in the widget.
        - `tags_execution`: (Optional) The execution method for multi-value filters.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "palette")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionTime(dict):
    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionYaxis(dict):
    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label of the axis to display on the graph.
        :param str max: Specify the minimum value to show on y-axis.
        :param str min: Specify the minimum value to show on y-axis.
        :param str scale: Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        return pulumi.get(self, "scale")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHostmapDefinition(dict):
    def __init__(__self__, *,
                 groups: Optional[List[str]] = None,
                 no_group_hosts: Optional[bool] = None,
                 no_metric_hosts: Optional[bool] = None,
                 node_type: Optional[str] = None,
                 request: Optional['outputs.DashboardWidgetHostmapDefinitionRequest'] = None,
                 scopes: Optional[List[str]] = None,
                 style: Optional['outputs.DashboardWidgetHostmapDefinitionStyle'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param List[str] groups: The check group to use in the widget.
        :param bool no_group_hosts: Boolean indicating whether to show ungrouped nodes.
        :param bool no_metric_hosts: Boolean indicating whether to show nodes with no metrics.
        :param str node_type: The type of node used. Either "host" or "container".
        :param List[str] scopes: The list of tags to filter nodes by.
        :param 'DashboardWidgetHostmapDefinitionStyleArgs' style: Style of the widget graph. One nested block is allowed with the following structure:
        :param str title: Title of the dashboard.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if no_group_hosts is not None:
            pulumi.set(__self__, "no_group_hosts", no_group_hosts)
        if no_metric_hosts is not None:
            pulumi.set(__self__, "no_metric_hosts", no_metric_hosts)
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def groups(self) -> Optional[List[str]]:
        """
        The check group to use in the widget.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter(name="noGroupHosts")
    def no_group_hosts(self) -> Optional[bool]:
        """
        Boolean indicating whether to show ungrouped nodes.
        """
        return pulumi.get(self, "no_group_hosts")

    @property
    @pulumi.getter(name="noMetricHosts")
    def no_metric_hosts(self) -> Optional[bool]:
        """
        Boolean indicating whether to show nodes with no metrics.
        """
        return pulumi.get(self, "no_metric_hosts")

    @property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[str]:
        """
        The type of node used. Either "host" or "container".
        """
        return pulumi.get(self, "node_type")

    @property
    @pulumi.getter
    def request(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequest']:
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[List[str]]:
        """
        The list of tags to filter nodes by.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionStyle']:
        """
        Style of the widget graph. One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "style")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequest(dict):
    def __init__(__self__, *,
                 fills: Optional[List['outputs.DashboardWidgetHostmapDefinitionRequestFill']] = None,
                 sizes: Optional[List['outputs.DashboardWidgetHostmapDefinitionRequestSize']] = None):
        if fills is not None:
            pulumi.set(__self__, "fills", fills)
        if sizes is not None:
            pulumi.set(__self__, "sizes", sizes)

    @property
    @pulumi.getter
    def fills(self) -> Optional[List['outputs.DashboardWidgetHostmapDefinitionRequestFill']]:
        return pulumi.get(self, "fills")

    @property
    @pulumi.getter
    def sizes(self) -> Optional[List['outputs.DashboardWidgetHostmapDefinitionRequestSize']]:
        return pulumi.get(self, "sizes")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFill(dict):
    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillProcessQuery'] = None,
                 q: Optional[str] = None):
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillApmQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQuerySearch'] = None):
        """
        :param 'DashboardWidgetHostmapDefinitionRequestFillApmQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupByArgs'] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param 'DashboardWidgetHostmapDefinitionRequestFillApmQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy']]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillLogQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQuerySearch'] = None):
        """
        :param 'DashboardWidgetHostmapDefinitionRequestFillLogQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupByArgs'] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param 'DashboardWidgetHostmapDefinitionRequestFillLogQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy']]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillProcessQuery(dict):
    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[List[str]] = None,
                 limit: Optional[float] = None,
                 search_by: Optional[str] = None):
        """
        :param float limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[List[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSize(dict):
    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeProcessQuery'] = None,
                 q: Optional[str] = None):
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeApmQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQuerySearch'] = None):
        """
        :param 'DashboardWidgetHostmapDefinitionRequestSizeApmQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupByArgs'] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param 'DashboardWidgetHostmapDefinitionRequestSizeApmQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy']]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeLogQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQuerySearch'] = None):
        """
        :param 'DashboardWidgetHostmapDefinitionRequestSizeLogQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupByArgs'] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param 'DashboardWidgetHostmapDefinitionRequestSizeLogQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy']]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeProcessQuery(dict):
    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[List[str]] = None,
                 limit: Optional[float] = None,
                 search_by: Optional[str] = None):
        """
        :param float limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[List[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetHostmapDefinitionStyle(dict):
    def __init__(__self__, *,
                 fill_max: Optional[str] = None,
                 fill_min: Optional[str] = None,
                 palette: Optional[str] = None,
                 palette_flip: Optional[bool] = None):
        """
        :param str fill_max: Max value to use to color the map.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `iframe_definition`: The definition for a Iframe widget. Exactly one nested block is allowed with the following structure:
        :param str fill_min: Min value to use to color the map.
        :param str palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
               - `q`: (Required) The event query to use in the widget.
               - `tags_execution`: (Optional) The execution method for multi-value filters.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        :param bool palette_flip: Boolean indicating whether to flip the palette tones.
        """
        if fill_max is not None:
            pulumi.set(__self__, "fill_max", fill_max)
        if fill_min is not None:
            pulumi.set(__self__, "fill_min", fill_min)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_flip is not None:
            pulumi.set(__self__, "palette_flip", palette_flip)

    @property
    @pulumi.getter(name="fillMax")
    def fill_max(self) -> Optional[str]:
        """
        Max value to use to color the map.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `iframe_definition`: The definition for a Iframe widget. Exactly one nested block is allowed with the following structure:
        """
        return pulumi.get(self, "fill_max")

    @property
    @pulumi.getter(name="fillMin")
    def fill_min(self) -> Optional[str]:
        """
        Min value to use to color the map.
        """
        return pulumi.get(self, "fill_min")

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
        - `q`: (Required) The event query to use in the widget.
        - `tags_execution`: (Optional) The execution method for multi-value filters.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteFlip")
    def palette_flip(self) -> Optional[bool]:
        """
        Boolean indicating whether to flip the palette tones.
        """
        return pulumi.get(self, "palette_flip")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetIframeDefinition(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: Read only field - The URL of the dashboard.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Read only field - The URL of the dashboard.
        """
        return pulumi.get(self, "url")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetImageDefinition(dict):
    def __init__(__self__, *,
                 url: str,
                 margin: Optional[str] = None,
                 sizing: Optional[str] = None):
        """
        :param str url: Read only field - The URL of the dashboard.
        :param str margin: The margins to use around the image. Either "small" or "large".
               - `log_stream_definition`: The definition for a Log Stream widget. Exactly one nested block is allowed with the following structure:
        :param str sizing: The preferred method to adapt the dimensions of the image to those of the widget. One of "center" (center the image in the tile), "zoom" (zoom the image to cover the whole tile) or "fit" (fit the image dimensions to those of the tile).
        """
        pulumi.set(__self__, "url", url)
        if margin is not None:
            pulumi.set(__self__, "margin", margin)
        if sizing is not None:
            pulumi.set(__self__, "sizing", sizing)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Read only field - The URL of the dashboard.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def margin(self) -> Optional[str]:
        """
        The margins to use around the image. Either "small" or "large".
        - `log_stream_definition`: The definition for a Log Stream widget. Exactly one nested block is allowed with the following structure:
        """
        return pulumi.get(self, "margin")

    @property
    @pulumi.getter
    def sizing(self) -> Optional[str]:
        """
        The preferred method to adapt the dimensions of the image to those of the widget. One of "center" (center the image in the tile), "zoom" (zoom the image to cover the whole tile) or "fit" (fit the image dimensions to those of the tile).
        """
        return pulumi.get(self, "sizing")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetLayout(dict):
    def __init__(__self__, *,
                 height: float,
                 width: float,
                 x: float,
                 y: float):
        """
        :param float height: The height of the widget.
        :param float width: The width of the widget.
        :param float x: The position of the widget on the x (horizontal) axis. Should be greater or equal to 0.
        :param float y: The position of the widget on the y (vertical) axis. Should be greater or equal to 0.
        """
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "width", width)
        pulumi.set(__self__, "x", x)
        pulumi.set(__self__, "y", y)

    @property
    @pulumi.getter
    def height(self) -> float:
        """
        The height of the widget.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def width(self) -> float:
        """
        The width of the widget.
        """
        return pulumi.get(self, "width")

    @property
    @pulumi.getter
    def x(self) -> float:
        """
        The position of the widget on the x (horizontal) axis. Should be greater or equal to 0.
        """
        return pulumi.get(self, "x")

    @property
    @pulumi.getter
    def y(self) -> float:
        """
        The position of the widget on the y (vertical) axis. Should be greater or equal to 0.
        """
        return pulumi.get(self, "y")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetLogStreamDefinition(dict):
    def __init__(__self__, *,
                 columns: Optional[List[str]] = None,
                 indexes: Optional[List[str]] = None,
                 logset: Optional[str] = None,
                 message_display: Optional[str] = None,
                 query: Optional[str] = None,
                 show_date_column: Optional[bool] = None,
                 show_message_column: Optional[bool] = None,
                 sort: Optional['outputs.DashboardWidgetLogStreamDefinitionSort'] = None,
                 time: Optional['outputs.DashboardWidgetLogStreamDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param List[str] columns: Stringified list of columns to use. Example: `"["column1","column2","column3"]"`.
        :param str logset: ID of the logset to use.
               - `query`: (Optional) The query to use in the widget.
        :param str message_display: The amount of lines the message column should display. One of: `inline`, `expanded-md`, and `expanded-lg`.
        :param bool show_date_column: If the date column should be displayed.
        :param bool show_message_column: If the message column should be displayed.
        :param 'DashboardWidgetLogStreamDefinitionSortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        :param str title: Title of the dashboard.
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if logset is not None:
            pulumi.set(__self__, "logset", logset)
        if message_display is not None:
            pulumi.set(__self__, "message_display", message_display)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if show_date_column is not None:
            pulumi.set(__self__, "show_date_column", show_date_column)
        if show_message_column is not None:
            pulumi.set(__self__, "show_message_column", show_message_column)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def columns(self) -> Optional[List[str]]:
        """
        Stringified list of columns to use. Example: `"["column1","column2","column3"]"`.
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[List[str]]:
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def logset(self) -> Optional[str]:
        """
        ID of the logset to use.
        - `query`: (Optional) The query to use in the widget.
        """
        return pulumi.get(self, "logset")

    @property
    @pulumi.getter(name="messageDisplay")
    def message_display(self) -> Optional[str]:
        """
        The amount of lines the message column should display. One of: `inline`, `expanded-md`, and `expanded-lg`.
        """
        return pulumi.get(self, "message_display")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="showDateColumn")
    def show_date_column(self) -> Optional[bool]:
        """
        If the date column should be displayed.
        """
        return pulumi.get(self, "show_date_column")

    @property
    @pulumi.getter(name="showMessageColumn")
    def show_message_column(self) -> Optional[bool]:
        """
        If the message column should be displayed.
        """
        return pulumi.get(self, "show_message_column")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetLogStreamDefinitionSort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetLogStreamDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetLogStreamDefinitionSort(dict):
    def __init__(__self__, *,
                 column: str,
                 order: str):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def column(self) -> str:
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetLogStreamDefinitionTime(dict):
    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetManageStatusDefinition(dict):
    def __init__(__self__, *,
                 query: str,
                 color_preference: Optional[str] = None,
                 count: Optional[float] = None,
                 display_format: Optional[str] = None,
                 hide_zero_counts: Optional[bool] = None,
                 show_last_triggered: Optional[bool] = None,
                 sort: Optional[str] = None,
                 start: Optional[float] = None,
                 summary_type: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str color_preference: Whether to colorize text or background. One of "text", "background".
        :param str display_format: The display setting to use. One of "counts", "list", or "countsAndList".
        :param bool hide_zero_counts: Boolean indicating whether to hide empty categories.
        :param bool show_last_triggered: Boolean indicating whether to show when monitors/groups last triggered.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `note_definition`: The definition for a Note widget. Exactly one nested block is allowed with the following structure:
        :param str sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        :param str summary_type: The monitor summary type to use. One of "monitors", "groups", or "combined". Defaults to "monitors".
        :param str title: Title of the dashboard.
        """
        pulumi.set(__self__, "query", query)
        if color_preference is not None:
            pulumi.set(__self__, "color_preference", color_preference)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if display_format is not None:
            pulumi.set(__self__, "display_format", display_format)
        if hide_zero_counts is not None:
            pulumi.set(__self__, "hide_zero_counts", hide_zero_counts)
        if show_last_triggered is not None:
            pulumi.set(__self__, "show_last_triggered", show_last_triggered)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if start is not None:
            pulumi.set(__self__, "start", start)
        if summary_type is not None:
            pulumi.set(__self__, "summary_type", summary_type)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="colorPreference")
    def color_preference(self) -> Optional[str]:
        """
        Whether to colorize text or background. One of "text", "background".
        """
        return pulumi.get(self, "color_preference")

    @property
    @pulumi.getter
    def count(self) -> Optional[float]:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="displayFormat")
    def display_format(self) -> Optional[str]:
        """
        The display setting to use. One of "counts", "list", or "countsAndList".
        """
        return pulumi.get(self, "display_format")

    @property
    @pulumi.getter(name="hideZeroCounts")
    def hide_zero_counts(self) -> Optional[bool]:
        """
        Boolean indicating whether to hide empty categories.
        """
        return pulumi.get(self, "hide_zero_counts")

    @property
    @pulumi.getter(name="showLastTriggered")
    def show_last_triggered(self) -> Optional[bool]:
        """
        Boolean indicating whether to show when monitors/groups last triggered.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `note_definition`: The definition for a Note widget. Exactly one nested block is allowed with the following structure:
        """
        return pulumi.get(self, "show_last_triggered")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter
    def start(self) -> Optional[float]:
        return pulumi.get(self, "start")

    @property
    @pulumi.getter(name="summaryType")
    def summary_type(self) -> Optional[str]:
        """
        The monitor summary type to use. One of "monitors", "groups", or "combined". Defaults to "monitors".
        """
        return pulumi.get(self, "summary_type")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetNoteDefinition(dict):
    def __init__(__self__, *,
                 content: str,
                 background_color: Optional[str] = None,
                 font_size: Optional[str] = None,
                 show_tick: Optional[bool] = None,
                 text_align: Optional[str] = None,
                 tick_edge: Optional[str] = None,
                 tick_pos: Optional[str] = None):
        """
        :param str content: Content of the note.
        :param str background_color: Background color of the note.
        :param str font_size: The size of the text in the widget.
        :param bool show_tick: Whether to show a tick or not.
        :param str text_align: The alignment of the text in the widget.
               - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
               - `q`: (Optional) The metric query to use in the widget
               - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
               - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
               - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        :param str tick_edge: When tick = true, string indicating on which side of the widget the tick should be displayed. One of "bottom", "top", "left", "right".
               - `query_value_definition`: The definition for a Query Value widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
               - `q`: (Optional) The metric query to use in the widget.
               - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
               - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
               - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        :param str tick_pos: When tick = true, string with a percent sign indicating the position of the tick. Example: use tick_pos = "50%" for centered alignment.
        """
        pulumi.set(__self__, "content", content)
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if font_size is not None:
            pulumi.set(__self__, "font_size", font_size)
        if show_tick is not None:
            pulumi.set(__self__, "show_tick", show_tick)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if tick_edge is not None:
            pulumi.set(__self__, "tick_edge", tick_edge)
        if tick_pos is not None:
            pulumi.set(__self__, "tick_pos", tick_pos)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        Content of the note.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[str]:
        """
        Background color of the note.
        """
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[str]:
        """
        The size of the text in the widget.
        """
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter(name="showTick")
    def show_tick(self) -> Optional[bool]:
        """
        Whether to show a tick or not.
        """
        return pulumi.get(self, "show_tick")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        """
        The alignment of the text in the widget.
        - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
        - `q`: (Optional) The metric query to use in the widget
        - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
        - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
        - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "text_align")

    @property
    @pulumi.getter(name="tickEdge")
    def tick_edge(self) -> Optional[str]:
        """
        When tick = true, string indicating on which side of the widget the tick should be displayed. One of "bottom", "top", "left", "right".
        - `query_value_definition`: The definition for a Query Value widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
        - `q`: (Optional) The metric query to use in the widget.
        - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
        - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
        - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "tick_edge")

    @property
    @pulumi.getter(name="tickPos")
    def tick_pos(self) -> Optional[str]:
        """
        When tick = true, string with a percent sign indicating the position of the tick. Example: use tick_pos = "50%" for centered alignment.
        """
        return pulumi.get(self, "tick_pos")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryTableDefinition(dict):
    def __init__(__self__, *,
                 requests: Optional[List['outputs.DashboardWidgetQueryTableDefinitionRequest']] = None,
                 time: Optional['outputs.DashboardWidgetQueryTableDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str title: Title of the dashboard.
        """
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def requests(self) -> Optional[List['outputs.DashboardWidgetQueryTableDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequest(dict):
    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 alias: Optional[str] = None,
                 apm_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmQuery'] = None,
                 conditional_formats: Optional[List['outputs.DashboardWidgetQueryTableDefinitionRequestConditionalFormat']] = None,
                 limit: Optional[float] = None,
                 log_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestLogQuery'] = None,
                 order: Optional[str] = None,
                 process_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None):
        """
        :param str aggregator: The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
               - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        :param str alias: The alias for the column name. Default is the metric name.
        :param List['DashboardWidgetQueryTableDefinitionRequestConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple request blocks are allowed. The structure of this block is described below.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `trace_service_definition`: The definition for a Trace Service widget. Exactly one nested block is allowed with the following structure:
               - `env`: (Required) APM environment.
               - `service`: (Required) APM service.
               - `span_name`: (Required) APM span name.
               - `show_hits`: (Optional) APM span name.
               - `show_hits`: (Optional) Whether to show the hits metrics or not.
               - `show_errors`: (Optional) Whether to show the error metrics or not.
               - `show_latency`: (Optional) Whether to show the latency metrics or not.
               - `show_breakdown`: (Optional) Whether to show the latency breakdown or not.
               - `show_distribution`: (Optional) Whether to show the latency distribution or not.
               - `show_resource_list`: (Optional) Whether to show the resource list or not.
               - `size_format`: (Optional) Size of the widget. Available values are: `small`, `medium`, or `large`.
               - `display_format`: (Optional) Number of columns to display. Available values are: `one_column`, `two_column`, or `three_column`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        :param float limit: The number of lines to show in the table.
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
        - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        The alias for the column name. Default is the metric name.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[List['outputs.DashboardWidgetQueryTableDefinitionRequestConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple request blocks are allowed. The structure of this block is described below.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `trace_service_definition`: The definition for a Trace Service widget. Exactly one nested block is allowed with the following structure:
        - `env`: (Required) APM environment.
        - `service`: (Required) APM service.
        - `span_name`: (Required) APM span name.
        - `show_hits`: (Optional) APM span name.
        - `show_hits`: (Optional) Whether to show the hits metrics or not.
        - `show_errors`: (Optional) Whether to show the error metrics or not.
        - `show_latency`: (Optional) Whether to show the latency metrics or not.
        - `show_breakdown`: (Optional) Whether to show the latency breakdown or not.
        - `show_distribution`: (Optional) Whether to show the latency distribution or not.
        - `show_resource_list`: (Optional) Whether to show the resource list or not.
        - `size_format`: (Optional) Size of the widget. Available values are: `small`, `medium`, or `large`.
        - `display_format`: (Optional) Number of columns to display. Available values are: `one_column`, `two_column`, or `three_column`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestApmQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmQuerySearch'] = None):
        """
        :param 'DashboardWidgetQueryTableDefinitionRequestApmQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetQueryTableDefinitionRequestApmQueryGroupByArgs'] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param 'DashboardWidgetQueryTableDefinitionRequestApmQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy']]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestConditionalFormat(dict):
    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: Comparator to apply from: One of `>`, `>=`, `<`, or `<=`.
        :param str palette: Color palette to apply; One of `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `green`, `green_on_white`, `grey`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `white_on_red`, `white_on_yellow`, or `yellow_on_white`.
        :param float value: Value for the comparator.
        :param str custom_bg_color: Color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: Color palette to apply to the foreground, same values available as palette.
        :param str image_url: Displays an image as the background.
               .
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        Comparator to apply from: One of `>`, `>=`, `<`, or `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        Color palette to apply; One of `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `green`, `green_on_white`, `grey`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `white_on_red`, `white_on_yellow`, or `yellow_on_white`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        Value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        Color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        Color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        .
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        return pulumi.get(self, "timeframe")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestLogQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestLogQuerySearch'] = None):
        """
        :param 'DashboardWidgetQueryTableDefinitionRequestLogQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetQueryTableDefinitionRequestLogQueryGroupByArgs'] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param 'DashboardWidgetQueryTableDefinitionRequestLogQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy']]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestLogQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestProcessQuery(dict):
    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[List[str]] = None,
                 limit: Optional[float] = None,
                 search_by: Optional[str] = None):
        """
        :param float limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[List[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionTime(dict):
    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryValueDefinition(dict):
    def __init__(__self__, *,
                 autoscale: Optional[bool] = None,
                 custom_unit: Optional[str] = None,
                 precision: Optional[float] = None,
                 requests: Optional[List['outputs.DashboardWidgetQueryValueDefinitionRequest']] = None,
                 text_align: Optional[str] = None,
                 time: Optional['outputs.DashboardWidgetQueryValueDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param bool autoscale: Boolean indicating whether to automatically scale the tile.
        :param str custom_unit: The unit for the value displayed in the widget.
        :param float precision: The precision to use when displaying the tile.
        :param str text_align: The alignment of the text in the widget.
               - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
               - `q`: (Optional) The metric query to use in the widget
               - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
               - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
               - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        :param str title: Title of the dashboard.
        """
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if custom_unit is not None:
            pulumi.set(__self__, "custom_unit", custom_unit)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional[bool]:
        """
        Boolean indicating whether to automatically scale the tile.
        """
        return pulumi.get(self, "autoscale")

    @property
    @pulumi.getter(name="customUnit")
    def custom_unit(self) -> Optional[str]:
        """
        The unit for the value displayed in the widget.
        """
        return pulumi.get(self, "custom_unit")

    @property
    @pulumi.getter
    def precision(self) -> Optional[float]:
        """
        The precision to use when displaying the tile.
        """
        return pulumi.get(self, "precision")

    @property
    @pulumi.getter
    def requests(self) -> Optional[List['outputs.DashboardWidgetQueryValueDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        """
        The alignment of the text in the widget.
        - `heatmap_definition`: The definition for a Heatmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `query_table_definition`: The definition for a Query Table widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
        - `q`: (Optional) The metric query to use in the widget
        - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
        - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
        - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "text_align")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequest(dict):
    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 apm_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestApmQuery'] = None,
                 conditional_formats: Optional[List['outputs.DashboardWidgetQueryValueDefinitionRequestConditionalFormat']] = None,
                 log_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None):
        """
        :param str aggregator: The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
               - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        :param List['DashboardWidgetQueryValueDefinitionRequestConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple request blocks are allowed. The structure of this block is described below.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `trace_service_definition`: The definition for a Trace Service widget. Exactly one nested block is allowed with the following structure:
               - `env`: (Required) APM environment.
               - `service`: (Required) APM service.
               - `span_name`: (Required) APM span name.
               - `show_hits`: (Optional) APM span name.
               - `show_hits`: (Optional) Whether to show the hits metrics or not.
               - `show_errors`: (Optional) Whether to show the error metrics or not.
               - `show_latency`: (Optional) Whether to show the latency metrics or not.
               - `show_breakdown`: (Optional) Whether to show the latency breakdown or not.
               - `show_distribution`: (Optional) Whether to show the latency distribution or not.
               - `show_resource_list`: (Optional) Whether to show the resource list or not.
               - `size_format`: (Optional) Size of the widget. Available values are: `small`, `medium`, or `large`.
               - `display_format`: (Optional) Number of columns to display. Available values are: `one_column`, `two_column`, or `three_column`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
        - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[List['outputs.DashboardWidgetQueryValueDefinitionRequestConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple request blocks are allowed. The structure of this block is described below.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `trace_service_definition`: The definition for a Trace Service widget. Exactly one nested block is allowed with the following structure:
        - `env`: (Required) APM environment.
        - `service`: (Required) APM service.
        - `span_name`: (Required) APM span name.
        - `show_hits`: (Optional) APM span name.
        - `show_hits`: (Optional) Whether to show the hits metrics or not.
        - `show_errors`: (Optional) Whether to show the error metrics or not.
        - `show_latency`: (Optional) Whether to show the latency metrics or not.
        - `show_breakdown`: (Optional) Whether to show the latency breakdown or not.
        - `show_distribution`: (Optional) Whether to show the latency distribution or not.
        - `show_resource_list`: (Optional) Whether to show the resource list or not.
        - `size_format`: (Optional) Size of the widget. Available values are: `small`, `medium`, or `large`.
        - `display_format`: (Optional) Number of columns to display. Available values are: `one_column`, `two_column`, or `three_column`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestApmQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestApmQuerySearch'] = None):
        """
        :param 'DashboardWidgetQueryValueDefinitionRequestApmQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetQueryValueDefinitionRequestApmQueryGroupByArgs'] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param 'DashboardWidgetQueryValueDefinitionRequestApmQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy']]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestApmQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestConditionalFormat(dict):
    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: Comparator to apply from: One of `>`, `>=`, `<`, or `<=`.
        :param str palette: Color palette to apply; One of `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `green`, `green_on_white`, `grey`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `white_on_red`, `white_on_yellow`, or `yellow_on_white`.
        :param float value: Value for the comparator.
        :param str custom_bg_color: Color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: Color palette to apply to the foreground, same values available as palette.
        :param str image_url: Displays an image as the background.
               .
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        Comparator to apply from: One of `>`, `>=`, `<`, or `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        Color palette to apply; One of `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `green`, `green_on_white`, `grey`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `white_on_red`, `white_on_yellow`, or `yellow_on_white`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        Value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        Color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        Color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        .
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        return pulumi.get(self, "timeframe")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestLogQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestLogQuerySearch'] = None):
        """
        :param 'DashboardWidgetQueryValueDefinitionRequestLogQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetQueryValueDefinitionRequestLogQueryGroupByArgs'] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param 'DashboardWidgetQueryValueDefinitionRequestLogQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy']]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestLogQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestProcessQuery(dict):
    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[List[str]] = None,
                 limit: Optional[float] = None,
                 search_by: Optional[str] = None):
        """
        :param float limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[List[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionTime(dict):
    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinition(dict):
    def __init__(__self__, *,
                 color_by_groups: Optional[List[str]] = None,
                 request: Optional['outputs.DashboardWidgetScatterplotDefinitionRequest'] = None,
                 time: Optional['outputs.DashboardWidgetScatterplotDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 xaxis: Optional['outputs.DashboardWidgetScatterplotDefinitionXaxis'] = None,
                 yaxis: Optional['outputs.DashboardWidgetScatterplotDefinitionYaxis'] = None):
        """
        :param List[str] color_by_groups: List of groups used for colors.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `servicemap_definition`: The definition for a Service Map widget. Exactly one nested block is allowed with the following structure:
               - `filters`: (Required) Your environment and primary tag (or * if enabled for your account).
               - `service`: (Required) The ID of the service you want to map.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `service_level_objective_definition`: The definition for a Service Level Objective widget. Exactly one nested block is allowed with the following structure:
               - `view_type`: (Required) Type of view to use when displaying the widget. Only "detail" is currently supported.
               - `slo_id`: (Required) The ID of the service level objective used by the widget.
               - `show_error_budget`: (Optional) Whether to show the error budget or not.
               - `view_mode`: (Required) View mode for the widget. One of "overall", "component", or "both".
               - `time_windows`: (Required) List of time windows to display in the widget. Each value in the list must be one of "7d", "30d", "90d", "week_to_date",  "previous_week", "month_to_date", or "previous_month".
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `timeseries_definition`: The definition for a Timeseries  widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
               - `q`: (Optional) The metric query to use in the widget.
               - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
               - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
               - `network_query`: (Optional) The network query to use in the widget. The structure of this block is described below.
               - `rum_query`: (Optional) The rum query to use in the widget. The structure of this block is described below.
               - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        :param str title: Title of the dashboard.
        """
        if color_by_groups is not None:
            pulumi.set(__self__, "color_by_groups", color_by_groups)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if xaxis is not None:
            pulumi.set(__self__, "xaxis", xaxis)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter(name="colorByGroups")
    def color_by_groups(self) -> Optional[List[str]]:
        """
        List of groups used for colors.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `servicemap_definition`: The definition for a Service Map widget. Exactly one nested block is allowed with the following structure:
        - `filters`: (Required) Your environment and primary tag (or * if enabled for your account).
        - `service`: (Required) The ID of the service you want to map.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `service_level_objective_definition`: The definition for a Service Level Objective widget. Exactly one nested block is allowed with the following structure:
        - `view_type`: (Required) Type of view to use when displaying the widget. Only "detail" is currently supported.
        - `slo_id`: (Required) The ID of the service level objective used by the widget.
        - `show_error_budget`: (Optional) Whether to show the error budget or not.
        - `view_mode`: (Required) View mode for the widget. One of "overall", "component", or "both".
        - `time_windows`: (Required) List of time windows to display in the widget. Each value in the list must be one of "7d", "30d", "90d", "week_to_date",  "previous_week", "month_to_date", or "previous_month".
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `timeseries_definition`: The definition for a Timeseries  widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
        - `q`: (Optional) The metric query to use in the widget.
        - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
        - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
        - `network_query`: (Optional) The network query to use in the widget. The structure of this block is described below.
        - `rum_query`: (Optional) The rum query to use in the widget. The structure of this block is described below.
        - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "color_by_groups")

    @property
    @pulumi.getter
    def request(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequest']:
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def xaxis(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionXaxis']:
        return pulumi.get(self, "xaxis")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionYaxis']:
        return pulumi.get(self, "yaxis")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequest(dict):
    def __init__(__self__, *,
                 xes: Optional[List['outputs.DashboardWidgetScatterplotDefinitionRequestX']] = None,
                 ys: Optional[List['outputs.DashboardWidgetScatterplotDefinitionRequestY']] = None):
        """
        :param List['DashboardWidgetScatterplotDefinitionRequestXArgs'] xes: The position of the widget on the x (horizontal) axis. Should be greater or equal to 0.
        :param List['DashboardWidgetScatterplotDefinitionRequestYArgs'] ys: The position of the widget on the y (vertical) axis. Should be greater or equal to 0.
        """
        if xes is not None:
            pulumi.set(__self__, "xes", xes)
        if ys is not None:
            pulumi.set(__self__, "ys", ys)

    @property
    @pulumi.getter
    def xes(self) -> Optional[List['outputs.DashboardWidgetScatterplotDefinitionRequestX']]:
        """
        The position of the widget on the x (horizontal) axis. Should be greater or equal to 0.
        """
        return pulumi.get(self, "xes")

    @property
    @pulumi.getter
    def ys(self) -> Optional[List['outputs.DashboardWidgetScatterplotDefinitionRequestY']]:
        """
        The position of the widget on the y (vertical) axis. Should be greater or equal to 0.
        """
        return pulumi.get(self, "ys")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestX(dict):
    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 apm_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXProcessQuery'] = None,
                 q: Optional[str] = None):
        """
        :param str aggregator: The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
               - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
        - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXApmQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQuerySearch'] = None):
        """
        :param 'DashboardWidgetScatterplotDefinitionRequestXApmQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupByArgs'] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param 'DashboardWidgetScatterplotDefinitionRequestXApmQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy']]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXLogQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQuerySearch'] = None):
        """
        :param 'DashboardWidgetScatterplotDefinitionRequestXLogQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupByArgs'] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param 'DashboardWidgetScatterplotDefinitionRequestXLogQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy']]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXProcessQuery(dict):
    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[List[str]] = None,
                 limit: Optional[float] = None,
                 search_by: Optional[str] = None):
        """
        :param float limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[List[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestY(dict):
    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 apm_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYProcessQuery'] = None,
                 q: Optional[str] = None):
        """
        :param str aggregator: The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
               - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregator to use for time aggregation. One of `avg`, `min`, `max`, `sum`, `last`.
        - `y`: (Optional) The query used for the Y-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `xaxis`: (Optional) Nested block describing the X-Axis Controls. The structure of this block is described below
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYApmQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQuerySearch'] = None):
        """
        :param 'DashboardWidgetScatterplotDefinitionRequestYApmQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupByArgs'] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param 'DashboardWidgetScatterplotDefinitionRequestYApmQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy']]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYLogQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQuerySearch'] = None):
        """
        :param 'DashboardWidgetScatterplotDefinitionRequestYLogQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupByArgs'] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param 'DashboardWidgetScatterplotDefinitionRequestYLogQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy']]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYProcessQuery(dict):
    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[List[str]] = None,
                 limit: Optional[float] = None,
                 search_by: Optional[str] = None):
        """
        :param float limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[List[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionTime(dict):
    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionXaxis(dict):
    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label of the axis to display on the graph.
        :param str max: Specify the minimum value to show on y-axis.
        :param str min: Specify the minimum value to show on y-axis.
        :param str scale: Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        return pulumi.get(self, "scale")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionYaxis(dict):
    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label of the axis to display on the graph.
        :param str max: Specify the minimum value to show on y-axis.
        :param str min: Specify the minimum value to show on y-axis.
        :param str scale: Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        return pulumi.get(self, "scale")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetServiceLevelObjectiveDefinition(dict):
    def __init__(__self__, *,
                 slo_id: str,
                 time_windows: List[str],
                 view_mode: str,
                 view_type: str,
                 show_error_budget: Optional[bool] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str title: Title of the dashboard.
        """
        pulumi.set(__self__, "slo_id", slo_id)
        pulumi.set(__self__, "time_windows", time_windows)
        pulumi.set(__self__, "view_mode", view_mode)
        pulumi.set(__self__, "view_type", view_type)
        if show_error_budget is not None:
            pulumi.set(__self__, "show_error_budget", show_error_budget)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> List[str]:
        return pulumi.get(self, "time_windows")

    @property
    @pulumi.getter(name="viewMode")
    def view_mode(self) -> str:
        return pulumi.get(self, "view_mode")

    @property
    @pulumi.getter(name="viewType")
    def view_type(self) -> str:
        return pulumi.get(self, "view_type")

    @property
    @pulumi.getter(name="showErrorBudget")
    def show_error_budget(self) -> Optional[bool]:
        return pulumi.get(self, "show_error_budget")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetServicemapDefinition(dict):
    def __init__(__self__, *,
                 filters: List[str],
                 service: str,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str title: Title of the dashboard.
        """
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "service", service)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def filters(self) -> List[str]:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def service(self) -> str:
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinition(dict):
    def __init__(__self__, *,
                 events: Optional[List['outputs.DashboardWidgetTimeseriesDefinitionEvent']] = None,
                 legend_size: Optional[str] = None,
                 markers: Optional[List['outputs.DashboardWidgetTimeseriesDefinitionMarker']] = None,
                 requests: Optional[List['outputs.DashboardWidgetTimeseriesDefinitionRequest']] = None,
                 show_legend: Optional[bool] = None,
                 time: Optional['outputs.DashboardWidgetTimeseriesDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 yaxis: Optional['outputs.DashboardWidgetTimeseriesDefinitionYaxis'] = None):
        """
        :param List['DashboardWidgetTimeseriesDefinitionMarkerArgs'] markers: Nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple marker blocks are allowed within a given tile_def block.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
               - `q`: (Required) The event query to use in the widget.
               - `tags_execution`: (Optional) The execution method for multi-value filters.
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
               - `toplist_definition`: The definition for a Toplist  widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
               - `q`: (Optional) The metric query to use in the widget.
               - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
               - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
               - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        :param str title: Title of the dashboard.
        """
        if events is not None:
            pulumi.set(__self__, "events", events)
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if markers is not None:
            pulumi.set(__self__, "markers", markers)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter
    def events(self) -> Optional[List['outputs.DashboardWidgetTimeseriesDefinitionEvent']]:
        return pulumi.get(self, "events")

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[str]:
        return pulumi.get(self, "legend_size")

    @property
    @pulumi.getter
    def markers(self) -> Optional[List['outputs.DashboardWidgetTimeseriesDefinitionMarker']]:
        """
        Nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple marker blocks are allowed within a given tile_def block.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
        - `q`: (Required) The event query to use in the widget.
        - `tags_execution`: (Optional) The execution method for multi-value filters.
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        - `toplist_definition`: The definition for a Toplist  widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure (exactly only one of `q`, `apm_query`, `log_query` or `process_query` is required within the request block):
        - `q`: (Optional) The metric query to use in the widget.
        - `apm_query`: (Optional) The APM query to use in the widget. The structure of this block is described below.
        - `log_query`: (Optional) The log query to use in the widget. The structure of this block is described below.
        - `process_query`: (Optional) The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "markers")

    @property
    @pulumi.getter
    def requests(self) -> Optional[List['outputs.DashboardWidgetTimeseriesDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[bool]:
        return pulumi.get(self, "show_legend")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionYaxis']:
        return pulumi.get(self, "yaxis")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionEvent(dict):
    def __init__(__self__, *,
                 q: str,
                 tags_execution: Optional[str] = None):
        pulumi.set(__self__, "q", q)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)

    @property
    @pulumi.getter
    def q(self) -> str:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        return pulumi.get(self, "tags_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionMarker(dict):
    def __init__(__self__, *,
                 value: str,
                 display_type: Optional[str] = None,
                 label: Optional[str] = None):
        """
        :param str value: Value for the comparator.
        :param str display_type: Type of display to use for the request. Available values are: `area`, `bars`, or `line`.
        :param str label: The label of the axis to display on the graph.
        """
        pulumi.set(__self__, "value", value)
        if display_type is not None:
            pulumi.set(__self__, "display_type", display_type)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="displayType")
    def display_type(self) -> Optional[str]:
        """
        Type of display to use for the request. Available values are: `area`, `bars`, or `line`.
        """
        return pulumi.get(self, "display_type")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequest(dict):
    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQuery'] = None,
                 display_type: Optional[str] = None,
                 log_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQuery'] = None,
                 metadatas: Optional[List['outputs.DashboardWidgetTimeseriesDefinitionRequestMetadata']] = None,
                 network_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQuery'] = None,
                 style: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestStyle'] = None):
        """
        :param str display_type: Type of display to use for the request. Available values are: `area`, `bars`, or `line`.
        :param List['DashboardWidgetTimeseriesDefinitionRequestMetadataArgs'] metadatas: . Used to define expression aliases. Multiple nested blocks are allowed with the following structure:
        :param 'DashboardWidgetTimeseriesDefinitionRequestStyleArgs' style: Style of the widget graph. One nested block is allowed with the following structure:
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if display_type is not None:
            pulumi.set(__self__, "display_type", display_type)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if network_query is not None:
            pulumi.set(__self__, "network_query", network_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="displayType")
    def display_type(self) -> Optional[str]:
        """
        Type of display to use for the request. Available values are: `area`, `bars`, or `line`.
        """
        return pulumi.get(self, "display_type")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[List['outputs.DashboardWidgetTimeseriesDefinitionRequestMetadata']]:
        """
        . Used to define expression aliases. Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter(name="networkQuery")
    def network_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQuery']:
        return pulumi.get(self, "network_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQuery']:
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestStyle']:
        """
        Style of the widget graph. One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "style")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestApmQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQuerySearch'] = None):
        """
        :param 'DashboardWidgetTimeseriesDefinitionRequestApmQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupByArgs'] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param 'DashboardWidgetTimeseriesDefinitionRequestApmQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy']]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestLogQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQuerySearch'] = None):
        """
        :param 'DashboardWidgetTimeseriesDefinitionRequestLogQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupByArgs'] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param 'DashboardWidgetTimeseriesDefinitionRequestLogQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy']]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestMetadata(dict):
    def __init__(__self__, *,
                 expression: str,
                 alias_name: Optional[str] = None):
        pulumi.set(__self__, "expression", expression)
        if alias_name is not None:
            pulumi.set(__self__, "alias_name", alias_name)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="aliasName")
    def alias_name(self) -> Optional[str]:
        return pulumi.get(self, "alias_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQuerySearch'] = None):
        """
        :param 'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs'] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param 'DashboardWidgetTimeseriesDefinitionRequestNetworkQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy']]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestProcessQuery(dict):
    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[List[str]] = None,
                 limit: Optional[float] = None,
                 search_by: Optional[str] = None):
        """
        :param float limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[List[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestRumQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQuerySearch'] = None):
        """
        :param 'DashboardWidgetTimeseriesDefinitionRequestRumQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupByArgs'] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param 'DashboardWidgetTimeseriesDefinitionRequestRumQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy']]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestRumQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestRumQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 line_type: Optional[str] = None,
                 line_width: Optional[str] = None,
                 palette: Optional[str] = None):
        """
        :param str line_type: Type of lines displayed. Available values are: `dashed`, `dotted`, or `solid`.
        :param str line_width: Width of line displayed. Available values are: `normal`, `thick`, or `thin`.
        :param str palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
               - `q`: (Required) The event query to use in the widget.
               - `tags_execution`: (Optional) The execution method for multi-value filters.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        if line_type is not None:
            pulumi.set(__self__, "line_type", line_type)
        if line_width is not None:
            pulumi.set(__self__, "line_width", line_width)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter(name="lineType")
    def line_type(self) -> Optional[str]:
        """
        Type of lines displayed. Available values are: `dashed`, `dotted`, or `solid`.
        """
        return pulumi.get(self, "line_type")

    @property
    @pulumi.getter(name="lineWidth")
    def line_width(self) -> Optional[str]:
        """
        Width of line displayed. Available values are: `normal`, `thick`, or `thin`.
        """
        return pulumi.get(self, "line_width")

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
        - `q`: (Required) The event query to use in the widget.
        - `tags_execution`: (Optional) The execution method for multi-value filters.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "palette")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionTime(dict):
    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionYaxis(dict):
    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label of the axis to display on the graph.
        :param str max: Specify the minimum value to show on y-axis.
        :param str min: Specify the minimum value to show on y-axis.
        :param str scale: Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specifies the scale type. One of "linear", "log", "pow", "sqrt".
        """
        return pulumi.get(self, "scale")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetToplistDefinition(dict):
    def __init__(__self__, *,
                 requests: Optional[List['outputs.DashboardWidgetToplistDefinitionRequest']] = None,
                 time: Optional['outputs.DashboardWidgetToplistDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str title: Title of the dashboard.
        """
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def requests(self) -> Optional[List['outputs.DashboardWidgetToplistDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetToplistDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequest(dict):
    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestApmQuery'] = None,
                 conditional_formats: Optional[List['outputs.DashboardWidgetToplistDefinitionRequestConditionalFormat']] = None,
                 log_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 style: Optional['outputs.DashboardWidgetToplistDefinitionRequestStyle'] = None):
        """
        :param List['DashboardWidgetToplistDefinitionRequestConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple request blocks are allowed. The structure of this block is described below.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `trace_service_definition`: The definition for a Trace Service widget. Exactly one nested block is allowed with the following structure:
               - `env`: (Required) APM environment.
               - `service`: (Required) APM service.
               - `span_name`: (Required) APM span name.
               - `show_hits`: (Optional) APM span name.
               - `show_hits`: (Optional) Whether to show the hits metrics or not.
               - `show_errors`: (Optional) Whether to show the error metrics or not.
               - `show_latency`: (Optional) Whether to show the latency metrics or not.
               - `show_breakdown`: (Optional) Whether to show the latency breakdown or not.
               - `show_distribution`: (Optional) Whether to show the latency distribution or not.
               - `show_resource_list`: (Optional) Whether to show the resource list or not.
               - `size_format`: (Optional) Size of the widget. Available values are: `small`, `medium`, or `large`.
               - `display_format`: (Optional) Number of columns to display. Available values are: `one_column`, `two_column`, or `three_column`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        :param 'DashboardWidgetToplistDefinitionRequestStyleArgs' style: Style of the widget graph. One nested block is allowed with the following structure:
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[List['outputs.DashboardWidgetToplistDefinitionRequestConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple request blocks are allowed. The structure of this block is described below.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `trace_service_definition`: The definition for a Trace Service widget. Exactly one nested block is allowed with the following structure:
        - `env`: (Required) APM environment.
        - `service`: (Required) APM service.
        - `span_name`: (Required) APM span name.
        - `show_hits`: (Optional) APM span name.
        - `show_hits`: (Optional) Whether to show the hits metrics or not.
        - `show_errors`: (Optional) Whether to show the error metrics or not.
        - `show_latency`: (Optional) Whether to show the latency metrics or not.
        - `show_breakdown`: (Optional) Whether to show the latency breakdown or not.
        - `show_distribution`: (Optional) Whether to show the latency distribution or not.
        - `show_resource_list`: (Optional) Whether to show the resource list or not.
        - `size_format`: (Optional) Size of the widget. Available values are: `small`, `medium`, or `large`.
        - `display_format`: (Optional) Number of columns to display. Available values are: `one_column`, `two_column`, or `three_column`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestStyle']:
        """
        Style of the widget graph. One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "style")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestApmQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetToplistDefinitionRequestApmQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetToplistDefinitionRequestApmQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetToplistDefinitionRequestApmQuerySearch'] = None):
        """
        :param 'DashboardWidgetToplistDefinitionRequestApmQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetToplistDefinitionRequestApmQueryGroupByArgs'] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param 'DashboardWidgetToplistDefinitionRequestApmQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetToplistDefinitionRequestApmQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetToplistDefinitionRequestApmQueryGroupBy']]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestApmQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestApmQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetToplistDefinitionRequestApmQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetToplistDefinitionRequestApmQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestApmQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestConditionalFormat(dict):
    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: Comparator to apply from: One of `>`, `>=`, `<`, or `<=`.
        :param str palette: Color palette to apply; One of `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `green`, `green_on_white`, `grey`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `white_on_red`, `white_on_yellow`, or `yellow_on_white`.
        :param float value: Value for the comparator.
        :param str custom_bg_color: Color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: Color palette to apply to the foreground, same values available as palette.
        :param str image_url: Displays an image as the background.
               .
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        Comparator to apply from: One of `>`, `>=`, `<`, or `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        Color palette to apply; One of `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `green`, `green_on_white`, `grey`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `white_on_red`, `white_on_yellow`, or `yellow_on_white`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        Value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        Color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        Color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        .
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        return pulumi.get(self, "timeframe")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestLogQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.DashboardWidgetToplistDefinitionRequestLogQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.DashboardWidgetToplistDefinitionRequestLogQueryGroupBy']] = None,
                 search: Optional['outputs.DashboardWidgetToplistDefinitionRequestLogQuerySearch'] = None):
        """
        :param 'DashboardWidgetToplistDefinitionRequestLogQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['DashboardWidgetToplistDefinitionRequestLogQueryGroupByArgs'] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param 'DashboardWidgetToplistDefinitionRequestLogQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.DashboardWidgetToplistDefinitionRequestLogQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.DashboardWidgetToplistDefinitionRequestLogQueryGroupBy']]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestLogQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestLogQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.DashboardWidgetToplistDefinitionRequestLogQueryGroupBySort'] = None):
        """
        :param float limit: The number of lines to show in the table.
        :param 'DashboardWidgetToplistDefinitionRequestLogQueryGroupBySortArgs' sort: The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestLogQueryGroupBySort']:
        """
        The facet and order to sort the data based upon. Example: `"{"column": "time", "order": "desc"}"`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `manage_status_definition`: The definition for a Manage Status, aka Monitor Summary, widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str order: The sort order for the rows. One of `desc` or `asc`.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
               - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The sort order for the rows. One of `desc` or `asc`.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `scatterplot_definition`: The definition for a Scatterplot widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Exactly one request block is allowed with the following structure:
        - `x`: (Optional) The query used for the X-Axis. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestProcessQuery(dict):
    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[List[str]] = None,
                 limit: Optional[float] = None,
                 search_by: Optional[str] = None):
        """
        :param float limit: The number of lines to show in the table.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[List[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 palette: Optional[str] = None):
        """
        :param str palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
               - `query`: (Required) The query to use in the widget.
               - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
               - `show_legend`: (Optional) Whether or not to show the legend on this widget.
               - `legend_size`: (Optional) The size of the legend displayed in the widget.
               - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
               - `q`: (Required) The event query to use in the widget.
               - `tags_execution`: (Optional) The execution method for multi-value filters.
               - `title`: (Optional) The title of the widget.
               - `title_size`: (Optional) The size of the widget's title. Default is 16.
               - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
               - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
               - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
               - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
               - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
               - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
               - `q`: (Required) The metric query to use in the widget.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/graphing/widgets/timeseries/#appearance.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `event_stream_definition`: The definition for a Event Stream widget. Exactly one nested block is allowed with the following structure:
        - `query`: (Required) The query to use in the widget.
        - `yaxis`: (Optional) Nested block describing the Y-Axis Controls. The structure of this block is described below
        - `show_legend`: (Optional) Whether or not to show the legend on this widget.
        - `legend_size`: (Optional) The size of the legend displayed in the widget.
        - `event`: (Optional) The definition of the event to overlay on the graph. Includes the following structure:
        - `q`: (Required) The event query to use in the widget.
        - `tags_execution`: (Optional) The execution method for multi-value filters.
        - `title`: (Optional) The title of the widget.
        - `title_size`: (Optional) The size of the widget's title. Default is 16.
        - `title_align`: (Optional) The alignment of the widget's title. One of "left", "center", or "right".
        - `time`: (Optional) Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below.
        - `hostmap_definition`: The definition for a Hostmap widget. Exactly one nested block is allowed with the following structure:
        - `request`: (Required) Nested block describing the request to use when displaying the widget. Multiple request blocks are allowed with the following structure:
        - `fill`: (Optional) The query used to fill the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        - `size`: (Optional) The query used to size the map. Exactly one nested block is allowed with the following structure:
        - `q`: (Required) The metric query to use in the widget.
        """
        return pulumi.get(self, "palette")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetToplistDefinitionTime(dict):
    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTraceServiceDefinition(dict):
    def __init__(__self__, *,
                 env: str,
                 service: str,
                 span_name: str,
                 display_format: Optional[str] = None,
                 show_breakdown: Optional[bool] = None,
                 show_distribution: Optional[bool] = None,
                 show_errors: Optional[bool] = None,
                 show_hits: Optional[bool] = None,
                 show_latency: Optional[bool] = None,
                 show_resource_list: Optional[bool] = None,
                 size_format: Optional[str] = None,
                 time: Optional['outputs.DashboardWidgetTraceServiceDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str display_format: The display setting to use. One of "counts", "list", or "countsAndList".
        :param str title: Title of the dashboard.
        """
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "span_name", span_name)
        if display_format is not None:
            pulumi.set(__self__, "display_format", display_format)
        if show_breakdown is not None:
            pulumi.set(__self__, "show_breakdown", show_breakdown)
        if show_distribution is not None:
            pulumi.set(__self__, "show_distribution", show_distribution)
        if show_errors is not None:
            pulumi.set(__self__, "show_errors", show_errors)
        if show_hits is not None:
            pulumi.set(__self__, "show_hits", show_hits)
        if show_latency is not None:
            pulumi.set(__self__, "show_latency", show_latency)
        if show_resource_list is not None:
            pulumi.set(__self__, "show_resource_list", show_resource_list)
        if size_format is not None:
            pulumi.set(__self__, "size_format", size_format)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def env(self) -> str:
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def service(self) -> str:
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="spanName")
    def span_name(self) -> str:
        return pulumi.get(self, "span_name")

    @property
    @pulumi.getter(name="displayFormat")
    def display_format(self) -> Optional[str]:
        """
        The display setting to use. One of "counts", "list", or "countsAndList".
        """
        return pulumi.get(self, "display_format")

    @property
    @pulumi.getter(name="showBreakdown")
    def show_breakdown(self) -> Optional[bool]:
        return pulumi.get(self, "show_breakdown")

    @property
    @pulumi.getter(name="showDistribution")
    def show_distribution(self) -> Optional[bool]:
        return pulumi.get(self, "show_distribution")

    @property
    @pulumi.getter(name="showErrors")
    def show_errors(self) -> Optional[bool]:
        return pulumi.get(self, "show_errors")

    @property
    @pulumi.getter(name="showHits")
    def show_hits(self) -> Optional[bool]:
        return pulumi.get(self, "show_hits")

    @property
    @pulumi.getter(name="showLatency")
    def show_latency(self) -> Optional[bool]:
        return pulumi.get(self, "show_latency")

    @property
    @pulumi.getter(name="showResourceList")
    def show_resource_list(self) -> Optional[bool]:
        return pulumi.get(self, "show_resource_list")

    @property
    @pulumi.getter(name="sizeFormat")
    def size_format(self) -> Optional[str]:
        return pulumi.get(self, "size_format")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetTraceServiceDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DashboardWidgetTraceServiceDefinitionTime(dict):
    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. One of `10m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`.
        """
        return pulumi.get(self, "live_span")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DowntimeRecurrence(dict):
    def __init__(__self__, *,
                 period: float,
                 type: str,
                 until_date: Optional[float] = None,
                 until_occurrences: Optional[float] = None,
                 week_days: Optional[List[str]] = None):
        """
        :param float period: How often to repeat as an integer. For example to repeat every 3 days, select a type of days and a period of 3.
        :param str type: days, weeks, months, or years
        :param float until_date: The date at which the recurrence should end as a POSIX timestamp. `until_occurrences` and `until_date` are mutually exclusive.
        :param float until_occurrences: How many times the downtime will be rescheduled. `until_occurrences` and `until_date` are mutually exclusive.
        :param List[str] week_days: A list of week days to repeat on. Choose from: Mon, Tue, Wed, Thu, Fri, Sat or Sun. Only applicable when type is weeks. First letter must be capitalized.
        """
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "type", type)
        if until_date is not None:
            pulumi.set(__self__, "until_date", until_date)
        if until_occurrences is not None:
            pulumi.set(__self__, "until_occurrences", until_occurrences)
        if week_days is not None:
            pulumi.set(__self__, "week_days", week_days)

    @property
    @pulumi.getter
    def period(self) -> float:
        """
        How often to repeat as an integer. For example to repeat every 3 days, select a type of days and a period of 3.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        days, weeks, months, or years
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="untilDate")
    def until_date(self) -> Optional[float]:
        """
        The date at which the recurrence should end as a POSIX timestamp. `until_occurrences` and `until_date` are mutually exclusive.
        """
        return pulumi.get(self, "until_date")

    @property
    @pulumi.getter(name="untilOccurrences")
    def until_occurrences(self) -> Optional[float]:
        """
        How many times the downtime will be rescheduled. `until_occurrences` and `until_date` are mutually exclusive.
        """
        return pulumi.get(self, "until_occurrences")

    @property
    @pulumi.getter(name="weekDays")
    def week_days(self) -> Optional[List[str]]:
        """
        A list of week days to repeat on. Choose from: Mon, Tue, Wed, Thu, Fri, Sat or Sun. Only applicable when type is weeks. First letter must be capitalized.
        """
        return pulumi.get(self, "week_days")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsArchiveAzure(dict):
    def __init__(__self__, *,
                 client_id: str,
                 container: str,
                 storage_account: str,
                 tenant_id: str,
                 path: Optional[str] = None):
        """
        :param str client_id: Your client id.
        :param str container: The container where the archive will be stored.
        :param str storage_account: The associated storage account.
        :param str tenant_id: Your tenant id.
        :param str path: The path where the archive will be stored.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "container", container)
        pulumi.set(__self__, "storage_account", storage_account)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Your client id.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def container(self) -> str:
        """
        The container where the archive will be stored.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter(name="storageAccount")
    def storage_account(self) -> str:
        """
        The associated storage account.
        """
        return pulumi.get(self, "storage_account")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        Your tenant id.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path where the archive will be stored.
        """
        return pulumi.get(self, "path")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsArchiveGcs(dict):
    def __init__(__self__, *,
                 bucket: str,
                 client_email: str,
                 path: str,
                 project_id: str):
        """
        :param str bucket: Name of your gcs bucket.
        :param str client_email: Your client email.
        :param str path: The path where the archive will be stored.
        :param str project_id: Your project id.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "client_email", client_email)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Name of your gcs bucket.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> str:
        """
        Your client email.
        """
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path where the archive will be stored.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Your project id.
        """
        return pulumi.get(self, "project_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsArchiveS3(dict):
    def __init__(__self__, *,
                 account_id: str,
                 bucket: str,
                 client_email: str,
                 path: str,
                 project_id: str,
                 role_name: str):
        """
        :param str account_id: Your AWS account id.
        :param str bucket: Name of your gcs bucket.
        :param str client_email: Your client email.
        :param str path: The path where the archive will be stored.
        :param str project_id: Your project id.
        :param str role_name: Your AWS role name.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "client_email", client_email)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        """
        Your AWS account id.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Name of your gcs bucket.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> str:
        """
        Your client email.
        """
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path where the archive will be stored.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Your project id.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        """
        Your AWS role name.
        """
        return pulumi.get(self, "role_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineFilter(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessor(dict):
    def __init__(__self__, *,
                 arithmetic_processor: Optional['outputs.LogsCustomPipelineProcessorArithmeticProcessor'] = None,
                 attribute_remapper: Optional['outputs.LogsCustomPipelineProcessorAttributeRemapper'] = None,
                 category_processor: Optional['outputs.LogsCustomPipelineProcessorCategoryProcessor'] = None,
                 date_remapper: Optional['outputs.LogsCustomPipelineProcessorDateRemapper'] = None,
                 geo_ip_parser: Optional['outputs.LogsCustomPipelineProcessorGeoIpParser'] = None,
                 grok_parser: Optional['outputs.LogsCustomPipelineProcessorGrokParser'] = None,
                 lookup_processor: Optional['outputs.LogsCustomPipelineProcessorLookupProcessor'] = None,
                 message_remapper: Optional['outputs.LogsCustomPipelineProcessorMessageRemapper'] = None,
                 pipeline: Optional['outputs.LogsCustomPipelineProcessorPipeline'] = None,
                 service_remapper: Optional['outputs.LogsCustomPipelineProcessorServiceRemapper'] = None,
                 status_remapper: Optional['outputs.LogsCustomPipelineProcessorStatusRemapper'] = None,
                 string_builder_processor: Optional['outputs.LogsCustomPipelineProcessorStringBuilderProcessor'] = None,
                 trace_id_remapper: Optional['outputs.LogsCustomPipelineProcessorTraceIdRemapper'] = None,
                 url_parser: Optional['outputs.LogsCustomPipelineProcessorUrlParser'] = None,
                 user_agent_parser: Optional['outputs.LogsCustomPipelineProcessorUserAgentParser'] = None):
        if arithmetic_processor is not None:
            pulumi.set(__self__, "arithmetic_processor", arithmetic_processor)
        if attribute_remapper is not None:
            pulumi.set(__self__, "attribute_remapper", attribute_remapper)
        if category_processor is not None:
            pulumi.set(__self__, "category_processor", category_processor)
        if date_remapper is not None:
            pulumi.set(__self__, "date_remapper", date_remapper)
        if geo_ip_parser is not None:
            pulumi.set(__self__, "geo_ip_parser", geo_ip_parser)
        if grok_parser is not None:
            pulumi.set(__self__, "grok_parser", grok_parser)
        if lookup_processor is not None:
            pulumi.set(__self__, "lookup_processor", lookup_processor)
        if message_remapper is not None:
            pulumi.set(__self__, "message_remapper", message_remapper)
        if pipeline is not None:
            pulumi.set(__self__, "pipeline", pipeline)
        if service_remapper is not None:
            pulumi.set(__self__, "service_remapper", service_remapper)
        if status_remapper is not None:
            pulumi.set(__self__, "status_remapper", status_remapper)
        if string_builder_processor is not None:
            pulumi.set(__self__, "string_builder_processor", string_builder_processor)
        if trace_id_remapper is not None:
            pulumi.set(__self__, "trace_id_remapper", trace_id_remapper)
        if url_parser is not None:
            pulumi.set(__self__, "url_parser", url_parser)
        if user_agent_parser is not None:
            pulumi.set(__self__, "user_agent_parser", user_agent_parser)

    @property
    @pulumi.getter(name="arithmeticProcessor")
    def arithmetic_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorArithmeticProcessor']:
        return pulumi.get(self, "arithmetic_processor")

    @property
    @pulumi.getter(name="attributeRemapper")
    def attribute_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorAttributeRemapper']:
        return pulumi.get(self, "attribute_remapper")

    @property
    @pulumi.getter(name="categoryProcessor")
    def category_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorCategoryProcessor']:
        return pulumi.get(self, "category_processor")

    @property
    @pulumi.getter(name="dateRemapper")
    def date_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorDateRemapper']:
        return pulumi.get(self, "date_remapper")

    @property
    @pulumi.getter(name="geoIpParser")
    def geo_ip_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorGeoIpParser']:
        return pulumi.get(self, "geo_ip_parser")

    @property
    @pulumi.getter(name="grokParser")
    def grok_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorGrokParser']:
        return pulumi.get(self, "grok_parser")

    @property
    @pulumi.getter(name="lookupProcessor")
    def lookup_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorLookupProcessor']:
        return pulumi.get(self, "lookup_processor")

    @property
    @pulumi.getter(name="messageRemapper")
    def message_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorMessageRemapper']:
        return pulumi.get(self, "message_remapper")

    @property
    @pulumi.getter
    def pipeline(self) -> Optional['outputs.LogsCustomPipelineProcessorPipeline']:
        return pulumi.get(self, "pipeline")

    @property
    @pulumi.getter(name="serviceRemapper")
    def service_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorServiceRemapper']:
        return pulumi.get(self, "service_remapper")

    @property
    @pulumi.getter(name="statusRemapper")
    def status_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorStatusRemapper']:
        return pulumi.get(self, "status_remapper")

    @property
    @pulumi.getter(name="stringBuilderProcessor")
    def string_builder_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorStringBuilderProcessor']:
        return pulumi.get(self, "string_builder_processor")

    @property
    @pulumi.getter(name="traceIdRemapper")
    def trace_id_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorTraceIdRemapper']:
        return pulumi.get(self, "trace_id_remapper")

    @property
    @pulumi.getter(name="urlParser")
    def url_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorUrlParser']:
        return pulumi.get(self, "url_parser")

    @property
    @pulumi.getter(name="userAgentParser")
    def user_agent_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorUserAgentParser']:
        return pulumi.get(self, "user_agent_parser")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorArithmeticProcessor(dict):
    def __init__(__self__, *,
                 expression: str,
                 target: str,
                 is_enabled: Optional[bool] = None,
                 is_replace_missing: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param str expression: Arithmetic operation between one or more log attributes.
        :param str target: Name of the parent attribute that contains all the extracted details from the sources.
        :param bool is_enabled: If the processor is enabled or not.
        :param bool is_replace_missing: If it replaces all missing attributes of `template` by an empty string.
               * trace_id_remapper
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_replace_missing is not None:
            pulumi.set(__self__, "is_replace_missing", is_replace_missing)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Arithmetic operation between one or more log attributes.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isReplaceMissing")
    def is_replace_missing(self) -> Optional[bool]:
        """
        If it replaces all missing attributes of `template` by an empty string.
        * trace_id_remapper
        """
        return pulumi.get(self, "is_replace_missing")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorAttributeRemapper(dict):
    def __init__(__self__, *,
                 source_type: str,
                 sources: List[str],
                 target: str,
                 target_type: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 override_on_conflict: Optional[bool] = None,
                 preserve_source: Optional[bool] = None):
        """
        :param str source_type: Defines where the sources are from (log `attribute` or `tag`).
        :param List[str] sources: List of source attributes.
        :param str target: Name of the parent attribute that contains all the extracted details from the sources.
        :param str target_type: Defines if the target is a log `attribute` or `tag`.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        :param bool override_on_conflict: Override the target element if already set.
        :param bool preserve_source: Remove or preserve the remapped source element.
        """
        pulumi.set(__self__, "source_type", source_type)
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "target_type", target_type)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_on_conflict is not None:
            pulumi.set(__self__, "override_on_conflict", override_on_conflict)
        if preserve_source is not None:
            pulumi.set(__self__, "preserve_source", preserve_source)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        Defines where the sources are from (log `attribute` or `tag`).
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter
    def sources(self) -> List[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> str:
        """
        Defines if the target is a log `attribute` or `tag`.
        """
        return pulumi.get(self, "target_type")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="overrideOnConflict")
    def override_on_conflict(self) -> Optional[bool]:
        """
        Override the target element if already set.
        """
        return pulumi.get(self, "override_on_conflict")

    @property
    @pulumi.getter(name="preserveSource")
    def preserve_source(self) -> Optional[bool]:
        """
        Remove or preserve the remapped source element.
        """
        return pulumi.get(self, "preserve_source")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorCategoryProcessor(dict):
    def __init__(__self__, *,
                 categories: List['outputs.LogsCustomPipelineProcessorCategoryProcessorCategory'],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param List['LogsCustomPipelineProcessorCategoryProcessorCategoryArgs'] categories: List of filters to match or exclude a log with their corresponding name to assign a custom value to the log.
        :param str target: Name of the parent attribute that contains all the extracted details from the sources.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "categories", categories)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def categories(self) -> List['outputs.LogsCustomPipelineProcessorCategoryProcessorCategory']:
        """
        List of filters to match or exclude a log with their corresponding name to assign a custom value to the log.
        """
        return pulumi.get(self, "categories")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorCategoryProcessorCategory(dict):
    def __init__(__self__, *,
                 filters: List['outputs.LogsCustomPipelineProcessorCategoryProcessorCategoryFilter'],
                 name: str):
        """
        :param List['LogsCustomPipelineProcessorCategoryProcessorCategoryFilterArgs'] filters: Defines the nested pipeline filter. Only logs that match the filter criteria are processed by this pipeline.
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def filters(self) -> List['outputs.LogsCustomPipelineProcessorCategoryProcessorCategoryFilter']:
        """
        Defines the nested pipeline filter. Only logs that match the filter criteria are processed by this pipeline.
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorCategoryProcessorCategoryFilter(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorDateRemapper(dict):
    def __init__(__self__, *,
                 sources: List[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param List[str] sources: List of source attributes.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> List[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorGeoIpParser(dict):
    def __init__(__self__, *,
                 sources: List[str],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param List[str] sources: List of source attributes.
        :param str target: Name of the parent attribute that contains all the extracted details from the sources.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> List[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorGrokParser(dict):
    def __init__(__self__, *,
                 grok: 'outputs.LogsCustomPipelineProcessorGrokParserGrok',
                 source: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 samples: Optional[List[str]] = None):
        """
        :param str source: Name of the source attribute used to do the lookup.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        :param List[str] samples: List of sample logs for this parser. It can save up to 5 samples. Each sample takes up to 5000 characters.
        """
        pulumi.set(__self__, "grok", grok)
        pulumi.set(__self__, "source", source)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if samples is not None:
            pulumi.set(__self__, "samples", samples)

    @property
    @pulumi.getter
    def grok(self) -> 'outputs.LogsCustomPipelineProcessorGrokParserGrok':
        return pulumi.get(self, "grok")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Name of the source attribute used to do the lookup.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def samples(self) -> Optional[List[str]]:
        """
        List of sample logs for this parser. It can save up to 5 samples. Each sample takes up to 5000 characters.
        """
        return pulumi.get(self, "samples")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorGrokParserGrok(dict):
    def __init__(__self__, *,
                 match_rules: str,
                 support_rules: str):
        """
        :param str match_rules: Match rules for your grok parser.
        :param str support_rules: Support rules for your grok parser.
        """
        pulumi.set(__self__, "match_rules", match_rules)
        pulumi.set(__self__, "support_rules", support_rules)

    @property
    @pulumi.getter(name="matchRules")
    def match_rules(self) -> str:
        """
        Match rules for your grok parser.
        """
        return pulumi.get(self, "match_rules")

    @property
    @pulumi.getter(name="supportRules")
    def support_rules(self) -> str:
        """
        Support rules for your grok parser.
        """
        return pulumi.get(self, "support_rules")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorLookupProcessor(dict):
    def __init__(__self__, *,
                 lookup_tables: List[str],
                 source: str,
                 target: str,
                 default_lookup: Optional[str] = None,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param List[str] lookup_tables: List of entries of the lookup table using `"key,value"` format.
        :param str source: Name of the source attribute used to do the lookup.
        :param str target: Name of the parent attribute that contains all the extracted details from the sources.
        :param str default_lookup: Default lookup value to use if there is no entry in the lookup table for the value of the source attribute.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "lookup_tables", lookup_tables)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if default_lookup is not None:
            pulumi.set(__self__, "default_lookup", default_lookup)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="lookupTables")
    def lookup_tables(self) -> List[str]:
        """
        List of entries of the lookup table using `"key,value"` format.
        """
        return pulumi.get(self, "lookup_tables")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Name of the source attribute used to do the lookup.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="defaultLookup")
    def default_lookup(self) -> Optional[str]:
        """
        Default lookup value to use if there is no entry in the lookup table for the value of the source attribute.
        """
        return pulumi.get(self, "default_lookup")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorMessageRemapper(dict):
    def __init__(__self__, *,
                 sources: List[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param List[str] sources: List of source attributes.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> List[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorPipeline(dict):
    def __init__(__self__, *,
                 filters: List['outputs.LogsCustomPipelineProcessorPipelineFilter'],
                 name: str,
                 is_enabled: Optional[bool] = None,
                 processors: Optional[List['outputs.LogsCustomPipelineProcessorPipelineProcessor']] = None):
        """
        :param List['LogsCustomPipelineProcessorPipelineFilterArgs'] filters: Defines the nested pipeline filter. Only logs that match the filter criteria are processed by this pipeline.
        :param str name: Name of the processor
        :param bool is_enabled: If the processor is enabled or not.
        :param List['LogsCustomPipelineProcessorPipelineProcessorArgs'] processors: Processors. Nested pipeline can't take any other nested pipeline as its processor.
        """
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "name", name)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if processors is not None:
            pulumi.set(__self__, "processors", processors)

    @property
    @pulumi.getter
    def filters(self) -> List['outputs.LogsCustomPipelineProcessorPipelineFilter']:
        """
        Defines the nested pipeline filter. Only logs that match the filter criteria are processed by this pipeline.
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def processors(self) -> Optional[List['outputs.LogsCustomPipelineProcessorPipelineProcessor']]:
        """
        Processors. Nested pipeline can't take any other nested pipeline as its processor.
        """
        return pulumi.get(self, "processors")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineFilter(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessor(dict):
    def __init__(__self__, *,
                 arithmetic_processor: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor'] = None,
                 attribute_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper'] = None,
                 category_processor: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor'] = None,
                 date_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorDateRemapper'] = None,
                 geo_ip_parser: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorGeoIpParser'] = None,
                 grok_parser: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorGrokParser'] = None,
                 lookup_processor: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorLookupProcessor'] = None,
                 message_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorMessageRemapper'] = None,
                 service_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorServiceRemapper'] = None,
                 status_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorStatusRemapper'] = None,
                 string_builder_processor: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor'] = None,
                 trace_id_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper'] = None,
                 url_parser: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorUrlParser'] = None,
                 user_agent_parser: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorUserAgentParser'] = None):
        if arithmetic_processor is not None:
            pulumi.set(__self__, "arithmetic_processor", arithmetic_processor)
        if attribute_remapper is not None:
            pulumi.set(__self__, "attribute_remapper", attribute_remapper)
        if category_processor is not None:
            pulumi.set(__self__, "category_processor", category_processor)
        if date_remapper is not None:
            pulumi.set(__self__, "date_remapper", date_remapper)
        if geo_ip_parser is not None:
            pulumi.set(__self__, "geo_ip_parser", geo_ip_parser)
        if grok_parser is not None:
            pulumi.set(__self__, "grok_parser", grok_parser)
        if lookup_processor is not None:
            pulumi.set(__self__, "lookup_processor", lookup_processor)
        if message_remapper is not None:
            pulumi.set(__self__, "message_remapper", message_remapper)
        if service_remapper is not None:
            pulumi.set(__self__, "service_remapper", service_remapper)
        if status_remapper is not None:
            pulumi.set(__self__, "status_remapper", status_remapper)
        if string_builder_processor is not None:
            pulumi.set(__self__, "string_builder_processor", string_builder_processor)
        if trace_id_remapper is not None:
            pulumi.set(__self__, "trace_id_remapper", trace_id_remapper)
        if url_parser is not None:
            pulumi.set(__self__, "url_parser", url_parser)
        if user_agent_parser is not None:
            pulumi.set(__self__, "user_agent_parser", user_agent_parser)

    @property
    @pulumi.getter(name="arithmeticProcessor")
    def arithmetic_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor']:
        return pulumi.get(self, "arithmetic_processor")

    @property
    @pulumi.getter(name="attributeRemapper")
    def attribute_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper']:
        return pulumi.get(self, "attribute_remapper")

    @property
    @pulumi.getter(name="categoryProcessor")
    def category_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor']:
        return pulumi.get(self, "category_processor")

    @property
    @pulumi.getter(name="dateRemapper")
    def date_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorDateRemapper']:
        return pulumi.get(self, "date_remapper")

    @property
    @pulumi.getter(name="geoIpParser")
    def geo_ip_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorGeoIpParser']:
        return pulumi.get(self, "geo_ip_parser")

    @property
    @pulumi.getter(name="grokParser")
    def grok_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorGrokParser']:
        return pulumi.get(self, "grok_parser")

    @property
    @pulumi.getter(name="lookupProcessor")
    def lookup_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorLookupProcessor']:
        return pulumi.get(self, "lookup_processor")

    @property
    @pulumi.getter(name="messageRemapper")
    def message_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorMessageRemapper']:
        return pulumi.get(self, "message_remapper")

    @property
    @pulumi.getter(name="serviceRemapper")
    def service_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorServiceRemapper']:
        return pulumi.get(self, "service_remapper")

    @property
    @pulumi.getter(name="statusRemapper")
    def status_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorStatusRemapper']:
        return pulumi.get(self, "status_remapper")

    @property
    @pulumi.getter(name="stringBuilderProcessor")
    def string_builder_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor']:
        return pulumi.get(self, "string_builder_processor")

    @property
    @pulumi.getter(name="traceIdRemapper")
    def trace_id_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper']:
        return pulumi.get(self, "trace_id_remapper")

    @property
    @pulumi.getter(name="urlParser")
    def url_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorUrlParser']:
        return pulumi.get(self, "url_parser")

    @property
    @pulumi.getter(name="userAgentParser")
    def user_agent_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorUserAgentParser']:
        return pulumi.get(self, "user_agent_parser")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor(dict):
    def __init__(__self__, *,
                 expression: str,
                 target: str,
                 is_enabled: Optional[bool] = None,
                 is_replace_missing: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param str expression: Arithmetic operation between one or more log attributes.
        :param str target: Name of the parent attribute that contains all the extracted details from the sources.
        :param bool is_enabled: If the processor is enabled or not.
        :param bool is_replace_missing: If it replaces all missing attributes of `template` by an empty string.
               * trace_id_remapper
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_replace_missing is not None:
            pulumi.set(__self__, "is_replace_missing", is_replace_missing)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Arithmetic operation between one or more log attributes.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isReplaceMissing")
    def is_replace_missing(self) -> Optional[bool]:
        """
        If it replaces all missing attributes of `template` by an empty string.
        * trace_id_remapper
        """
        return pulumi.get(self, "is_replace_missing")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper(dict):
    def __init__(__self__, *,
                 source_type: str,
                 sources: List[str],
                 target: str,
                 target_type: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 override_on_conflict: Optional[bool] = None,
                 preserve_source: Optional[bool] = None):
        """
        :param str source_type: Defines where the sources are from (log `attribute` or `tag`).
        :param List[str] sources: List of source attributes.
        :param str target: Name of the parent attribute that contains all the extracted details from the sources.
        :param str target_type: Defines if the target is a log `attribute` or `tag`.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        :param bool override_on_conflict: Override the target element if already set.
        :param bool preserve_source: Remove or preserve the remapped source element.
        """
        pulumi.set(__self__, "source_type", source_type)
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "target_type", target_type)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_on_conflict is not None:
            pulumi.set(__self__, "override_on_conflict", override_on_conflict)
        if preserve_source is not None:
            pulumi.set(__self__, "preserve_source", preserve_source)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        Defines where the sources are from (log `attribute` or `tag`).
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter
    def sources(self) -> List[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> str:
        """
        Defines if the target is a log `attribute` or `tag`.
        """
        return pulumi.get(self, "target_type")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="overrideOnConflict")
    def override_on_conflict(self) -> Optional[bool]:
        """
        Override the target element if already set.
        """
        return pulumi.get(self, "override_on_conflict")

    @property
    @pulumi.getter(name="preserveSource")
    def preserve_source(self) -> Optional[bool]:
        """
        Remove or preserve the remapped source element.
        """
        return pulumi.get(self, "preserve_source")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor(dict):
    def __init__(__self__, *,
                 categories: List['outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory'],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param List['LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryArgs'] categories: List of filters to match or exclude a log with their corresponding name to assign a custom value to the log.
        :param str target: Name of the parent attribute that contains all the extracted details from the sources.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "categories", categories)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def categories(self) -> List['outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory']:
        """
        List of filters to match or exclude a log with their corresponding name to assign a custom value to the log.
        """
        return pulumi.get(self, "categories")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory(dict):
    def __init__(__self__, *,
                 filters: List['outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter'],
                 name: str):
        """
        :param List['LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilterArgs'] filters: Defines the nested pipeline filter. Only logs that match the filter criteria are processed by this pipeline.
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def filters(self) -> List['outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter']:
        """
        Defines the nested pipeline filter. Only logs that match the filter criteria are processed by this pipeline.
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorDateRemapper(dict):
    def __init__(__self__, *,
                 sources: List[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param List[str] sources: List of source attributes.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> List[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorGeoIpParser(dict):
    def __init__(__self__, *,
                 sources: List[str],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param List[str] sources: List of source attributes.
        :param str target: Name of the parent attribute that contains all the extracted details from the sources.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> List[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorGrokParser(dict):
    def __init__(__self__, *,
                 grok: 'outputs.LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok',
                 source: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 samples: Optional[List[str]] = None):
        """
        :param str source: Name of the source attribute used to do the lookup.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        :param List[str] samples: List of sample logs for this parser. It can save up to 5 samples. Each sample takes up to 5000 characters.
        """
        pulumi.set(__self__, "grok", grok)
        pulumi.set(__self__, "source", source)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if samples is not None:
            pulumi.set(__self__, "samples", samples)

    @property
    @pulumi.getter
    def grok(self) -> 'outputs.LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok':
        return pulumi.get(self, "grok")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Name of the source attribute used to do the lookup.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def samples(self) -> Optional[List[str]]:
        """
        List of sample logs for this parser. It can save up to 5 samples. Each sample takes up to 5000 characters.
        """
        return pulumi.get(self, "samples")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok(dict):
    def __init__(__self__, *,
                 match_rules: str,
                 support_rules: str):
        """
        :param str match_rules: Match rules for your grok parser.
        :param str support_rules: Support rules for your grok parser.
        """
        pulumi.set(__self__, "match_rules", match_rules)
        pulumi.set(__self__, "support_rules", support_rules)

    @property
    @pulumi.getter(name="matchRules")
    def match_rules(self) -> str:
        """
        Match rules for your grok parser.
        """
        return pulumi.get(self, "match_rules")

    @property
    @pulumi.getter(name="supportRules")
    def support_rules(self) -> str:
        """
        Support rules for your grok parser.
        """
        return pulumi.get(self, "support_rules")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorLookupProcessor(dict):
    def __init__(__self__, *,
                 lookup_tables: List[str],
                 source: str,
                 target: str,
                 default_lookup: Optional[str] = None,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param List[str] lookup_tables: List of entries of the lookup table using `"key,value"` format.
        :param str source: Name of the source attribute used to do the lookup.
        :param str target: Name of the parent attribute that contains all the extracted details from the sources.
        :param str default_lookup: Default lookup value to use if there is no entry in the lookup table for the value of the source attribute.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "lookup_tables", lookup_tables)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if default_lookup is not None:
            pulumi.set(__self__, "default_lookup", default_lookup)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="lookupTables")
    def lookup_tables(self) -> List[str]:
        """
        List of entries of the lookup table using `"key,value"` format.
        """
        return pulumi.get(self, "lookup_tables")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Name of the source attribute used to do the lookup.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="defaultLookup")
    def default_lookup(self) -> Optional[str]:
        """
        Default lookup value to use if there is no entry in the lookup table for the value of the source attribute.
        """
        return pulumi.get(self, "default_lookup")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorMessageRemapper(dict):
    def __init__(__self__, *,
                 sources: List[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param List[str] sources: List of source attributes.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> List[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorServiceRemapper(dict):
    def __init__(__self__, *,
                 sources: List[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param List[str] sources: List of source attributes.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> List[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorStatusRemapper(dict):
    def __init__(__self__, *,
                 sources: List[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param List[str] sources: List of source attributes.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> List[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor(dict):
    def __init__(__self__, *,
                 target: str,
                 template: str,
                 is_enabled: Optional[bool] = None,
                 is_replace_missing: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param str target: Name of the parent attribute that contains all the extracted details from the sources.
        :param str template: The formula with one or more attributes and raw text.
        :param bool is_enabled: If the processor is enabled or not.
        :param bool is_replace_missing: If it replaces all missing attributes of `template` by an empty string.
               * trace_id_remapper
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "template", template)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_replace_missing is not None:
            pulumi.set(__self__, "is_replace_missing", is_replace_missing)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def template(self) -> str:
        """
        The formula with one or more attributes and raw text.
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isReplaceMissing")
    def is_replace_missing(self) -> Optional[bool]:
        """
        If it replaces all missing attributes of `template` by an empty string.
        * trace_id_remapper
        """
        return pulumi.get(self, "is_replace_missing")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper(dict):
    def __init__(__self__, *,
                 sources: List[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param List[str] sources: List of source attributes.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> List[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorUrlParser(dict):
    def __init__(__self__, *,
                 sources: List[str],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 normalize_ending_slashes: Optional[bool] = None):
        """
        :param List[str] sources: List of source attributes.
        :param str target: Name of the parent attribute that contains all the extracted details from the sources.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        :param bool normalize_ending_slashes: Normalize the ending slashes or not.
        """
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if normalize_ending_slashes is not None:
            pulumi.set(__self__, "normalize_ending_slashes", normalize_ending_slashes)

    @property
    @pulumi.getter
    def sources(self) -> List[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="normalizeEndingSlashes")
    def normalize_ending_slashes(self) -> Optional[bool]:
        """
        Normalize the ending slashes or not.
        """
        return pulumi.get(self, "normalize_ending_slashes")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorUserAgentParser(dict):
    def __init__(__self__, *,
                 sources: List[str],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 is_encoded: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param List[str] sources: List of source attributes.
        :param str target: Name of the parent attribute that contains all the extracted details from the sources.
        :param bool is_enabled: If the processor is enabled or not.
        :param bool is_encoded: If the source attribute is URL encoded or not.
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_encoded is not None:
            pulumi.set(__self__, "is_encoded", is_encoded)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> List[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isEncoded")
    def is_encoded(self) -> Optional[bool]:
        """
        If the source attribute is URL encoded or not.
        """
        return pulumi.get(self, "is_encoded")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorServiceRemapper(dict):
    def __init__(__self__, *,
                 sources: List[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param List[str] sources: List of source attributes.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> List[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorStatusRemapper(dict):
    def __init__(__self__, *,
                 sources: List[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param List[str] sources: List of source attributes.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> List[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorStringBuilderProcessor(dict):
    def __init__(__self__, *,
                 target: str,
                 template: str,
                 is_enabled: Optional[bool] = None,
                 is_replace_missing: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param str target: Name of the parent attribute that contains all the extracted details from the sources.
        :param str template: The formula with one or more attributes and raw text.
        :param bool is_enabled: If the processor is enabled or not.
        :param bool is_replace_missing: If it replaces all missing attributes of `template` by an empty string.
               * trace_id_remapper
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "template", template)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_replace_missing is not None:
            pulumi.set(__self__, "is_replace_missing", is_replace_missing)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def template(self) -> str:
        """
        The formula with one or more attributes and raw text.
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isReplaceMissing")
    def is_replace_missing(self) -> Optional[bool]:
        """
        If it replaces all missing attributes of `template` by an empty string.
        * trace_id_remapper
        """
        return pulumi.get(self, "is_replace_missing")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorTraceIdRemapper(dict):
    def __init__(__self__, *,
                 sources: List[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param List[str] sources: List of source attributes.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> List[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorUrlParser(dict):
    def __init__(__self__, *,
                 sources: List[str],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 normalize_ending_slashes: Optional[bool] = None):
        """
        :param List[str] sources: List of source attributes.
        :param str target: Name of the parent attribute that contains all the extracted details from the sources.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        :param bool normalize_ending_slashes: Normalize the ending slashes or not.
        """
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if normalize_ending_slashes is not None:
            pulumi.set(__self__, "normalize_ending_slashes", normalize_ending_slashes)

    @property
    @pulumi.getter
    def sources(self) -> List[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="normalizeEndingSlashes")
    def normalize_ending_slashes(self) -> Optional[bool]:
        """
        Normalize the ending slashes or not.
        """
        return pulumi.get(self, "normalize_ending_slashes")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsCustomPipelineProcessorUserAgentParser(dict):
    def __init__(__self__, *,
                 sources: List[str],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 is_encoded: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param List[str] sources: List of source attributes.
        :param str target: Name of the parent attribute that contains all the extracted details from the sources.
        :param bool is_enabled: If the processor is enabled or not.
        :param bool is_encoded: If the source attribute is URL encoded or not.
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_encoded is not None:
            pulumi.set(__self__, "is_encoded", is_encoded)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> List[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isEncoded")
    def is_encoded(self) -> Optional[bool]:
        """
        If the source attribute is URL encoded or not.
        """
        return pulumi.get(self, "is_encoded")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsIndexExclusionFilter(dict):
    def __init__(__self__, *,
                 filters: Optional[List['outputs.LogsIndexExclusionFilterFilter']] = None,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param bool is_enabled: A boolean stating if the exclusion is active or not.
        :param str name: The name of the exclusion filter.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def filters(self) -> Optional[List['outputs.LogsIndexExclusionFilterFilter']]:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        A boolean stating if the exclusion is active or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the exclusion filter.
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsIndexExclusionFilterFilter(dict):
    def __init__(__self__, *,
                 query: Optional[str] = None,
                 sample_rate: Optional[float] = None):
        """
        :param str query: Only logs matching the filter criteria and the query of the parent index will be considered for this exclusion filter.
        :param float sample_rate: The fraction of logs excluded by the exclusion filter, when active.
        """
        if query is not None:
            pulumi.set(__self__, "query", query)
        if sample_rate is not None:
            pulumi.set(__self__, "sample_rate", sample_rate)

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        Only logs matching the filter criteria and the query of the parent index will be considered for this exclusion filter.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[float]:
        """
        The fraction of logs excluded by the exclusion filter, when active.
        """
        return pulumi.get(self, "sample_rate")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LogsIndexFilter(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Only logs matching the filter criteria and the query of the parent index will be considered for this exclusion filter.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Only logs matching the filter criteria and the query of the parent index will be considered for this exclusion filter.
        """
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MonitorThresholdWindows(dict):
    def __init__(__self__, *,
                 recovery_window: Optional[str] = None,
                 trigger_window: Optional[str] = None):
        """
        :param str recovery_window: describes how long an anomalous metric must be normal before the alert recovers.
        :param str trigger_window: describes how long a metric must be anomalous before an alert triggers.
        """
        if recovery_window is not None:
            pulumi.set(__self__, "recovery_window", recovery_window)
        if trigger_window is not None:
            pulumi.set(__self__, "trigger_window", trigger_window)

    @property
    @pulumi.getter(name="recoveryWindow")
    def recovery_window(self) -> Optional[str]:
        """
        describes how long an anomalous metric must be normal before the alert recovers.
        """
        return pulumi.get(self, "recovery_window")

    @property
    @pulumi.getter(name="triggerWindow")
    def trigger_window(self) -> Optional[str]:
        """
        describes how long a metric must be anomalous before an alert triggers.
        """
        return pulumi.get(self, "trigger_window")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MonitorThresholds(dict):
    def __init__(__self__, *,
                 critical: Optional[float] = None,
                 critical_recovery: Optional[float] = None,
                 ok: Optional[float] = None,
                 unknown: Optional[float] = None,
                 warning: Optional[float] = None,
                 warning_recovery: Optional[float] = None):
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if critical_recovery is not None:
            pulumi.set(__self__, "critical_recovery", critical_recovery)
        if ok is not None:
            pulumi.set(__self__, "ok", ok)
        if unknown is not None:
            pulumi.set(__self__, "unknown", unknown)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)
        if warning_recovery is not None:
            pulumi.set(__self__, "warning_recovery", warning_recovery)

    @property
    @pulumi.getter
    def critical(self) -> Optional[float]:
        return pulumi.get(self, "critical")

    @property
    @pulumi.getter(name="criticalRecovery")
    def critical_recovery(self) -> Optional[float]:
        return pulumi.get(self, "critical_recovery")

    @property
    @pulumi.getter
    def ok(self) -> Optional[float]:
        return pulumi.get(self, "ok")

    @property
    @pulumi.getter
    def unknown(self) -> Optional[float]:
        return pulumi.get(self, "unknown")

    @property
    @pulumi.getter
    def warning(self) -> Optional[float]:
        return pulumi.get(self, "warning")

    @property
    @pulumi.getter(name="warningRecovery")
    def warning_recovery(self) -> Optional[float]:
        return pulumi.get(self, "warning_recovery")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScreenBoardTemplateVariable(dict):
    def __init__(__self__, *,
                 name: str,
                 default: Optional[str] = None,
                 prefix: Optional[str] = None):
        """
        :param str name: The variable name. Can be referenced as \$name in `graph` `request` `q` query strings.
        :param str default: The default tag. Default: "\*" (match all).
        :param str prefix: The tag group. Default: no tag group.
        """
        pulumi.set(__self__, "name", name)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The variable name. Can be referenced as \$name in `graph` `request` `q` query strings.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def default(self) -> Optional[str]:
        """
        The default tag. Default: "\*" (match all).
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        The tag group. Default: no tag group.
        """
        return pulumi.get(self, "prefix")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScreenBoardWidget(dict):
    def __init__(__self__, *,
                 type: str,
                 x: float,
                 y: float,
                 alert_id: Optional[float] = None,
                 auto_refresh: Optional[bool] = None,
                 bgcolor: Optional[str] = None,
                 check: Optional[str] = None,
                 color: Optional[str] = None,
                 color_preference: Optional[str] = None,
                 columns: Optional[str] = None,
                 display_format: Optional[str] = None,
                 env: Optional[str] = None,
                 event_size: Optional[str] = None,
                 font_size: Optional[str] = None,
                 group: Optional[str] = None,
                 group_bies: Optional[List[str]] = None,
                 grouping: Optional[str] = None,
                 height: Optional[float] = None,
                 hide_zero_counts: Optional[bool] = None,
                 html: Optional[str] = None,
                 layout_version: Optional[str] = None,
                 legend: Optional[bool] = None,
                 legend_size: Optional[str] = None,
                 logset: Optional[str] = None,
                 manage_status_show_title: Optional[bool] = None,
                 manage_status_title_align: Optional[str] = None,
                 manage_status_title_size: Optional[str] = None,
                 manage_status_title_text: Optional[str] = None,
                 margin: Optional[str] = None,
                 monitor: Optional[Mapping[str, str]] = None,
                 must_show_breakdown: Optional[bool] = None,
                 must_show_distribution: Optional[bool] = None,
                 must_show_errors: Optional[bool] = None,
                 must_show_hits: Optional[bool] = None,
                 must_show_latency: Optional[bool] = None,
                 must_show_resource_list: Optional[bool] = None,
                 params: Optional[Mapping[str, str]] = None,
                 precision: Optional[str] = None,
                 query: Optional[str] = None,
                 rules: Optional[List['outputs.ScreenBoardWidgetRule']] = None,
                 service_name: Optional[str] = None,
                 service_service: Optional[str] = None,
                 show_last_triggered: Optional[bool] = None,
                 size_version: Optional[str] = None,
                 sizing: Optional[str] = None,
                 summary_type: Optional[str] = None,
                 tags: Optional[List[str]] = None,
                 text: Optional[str] = None,
                 text_align: Optional[str] = None,
                 text_size: Optional[str] = None,
                 tick: Optional[bool] = None,
                 tick_edge: Optional[str] = None,
                 tick_pos: Optional[str] = None,
                 tile_deves: Optional[List['outputs.ScreenBoardWidgetTileDef']] = None,
                 time: Optional[Mapping[str, str]] = None,
                 timeframes: Optional[List[str]] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[float] = None,
                 unit: Optional[str] = None,
                 url: Optional[str] = None,
                 viz_type: Optional[str] = None,
                 width: Optional[float] = None):
        """
        :param str type: Choose the type of representation to use for this query. For widgets of type "timeseries" and "query_value", use one of "line", "bars" or "area". For widgets of type "hostmap", use "fill" or "size".
        :param float x: The position of the widget on the x (horizontal) axis. Should be greater or equal to 0.
        :param float y: The position of the widget on the y (vertical) axis. Should be greater or equal to 0.
        :param float alert_id: The ID of the monitor used by the widget.
        :param bool auto_refresh: Boolean indicating whether the widget is refreshed automatically.
        :param str bgcolor: The color of the background of the widget.
        :param str check: The check to use in the widget.
        :param str color: The color of the text in the widget.
        :param str color_preference: Whether to colorize text or background. One of "text", "background".
        :param str columns: Stringified list of columns to use. Example: `"[\"column1\",\"column2\",\"column3\"]"`
        :param str display_format: The display setting to use. One of "counts", "list", or "countsAndList".
        :param str env: The environment to use.
        :param str event_size: The size of the events in the widget. Either "s" (small, title only) or "l" (large, full event).
        :param str font_size: The size of the text in the widget.
        :param str group: The list of tags to group nodes by.
        :param List[str] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param str grouping: Either "check" or "cluster", depending on whether the widget should use a single check or a cluster of checks.
        :param float height: The height of the widget. Default is 15.
        :param bool hide_zero_counts: Boolean indicating whether to hide empty categories.
        :param str html: The content of the widget. HTML tags supported.
        :param str layout_version: The number of columns to use when displaying values. One of "one_column", "two_column", "three_column".
        :param bool legend: Boolean indicating whether to display a legend in the widget.
        :param str legend_size: The size of the legend displayed in the widget.
        :param str logset: ID of the logset to use.
        :param bool manage_status_show_title: Boolean indicating whether to show a title.
        :param str manage_status_title_align: The alignment of the widget's title. One of "left", "center", or "right".
        :param str manage_status_title_size: The size of the widget's title.
        :param str manage_status_title_text: The title of the widget.
        :param str margin: The margins to use around the image. Either "small" or "large".
        :param bool must_show_breakdown: Boolean indicating whether to display breakdown.
        :param bool must_show_distribution: Boolean indicating whether to display distribution.
        :param bool must_show_errors: Boolean indicating whether to display errors.
        :param bool must_show_hits: Boolean indicating whether to display hits.
        :param bool must_show_latency: Boolean indicating whether to display latency.
        :param bool must_show_resource_list: Boolean indicating whether to display resources.
        :param Mapping[str, str] params: Nested block describing the monitors to display. The structure of this block is described below. At most one such block should be present in a given widget.
        :param str precision: The precision to use when displaying the tile.
        :param str query: The query to use in the widget.
        :param str service_name: The name of the service to use.
        :param str service_service: The trace service to use.
        :param bool show_last_triggered: Boolean indicating whether to show when monitors/groups last triggered.
        :param str size_version: The size of the widget. One of "small", "medium", "large".
        :param str sizing: The preferred method to adapt the dimensions of the image to those of the widget. One of "center" (center the image in the tile), "zoom" (zoom the image to cover the whole tile) or "fit" (fit the image dimensions to those of the tile).
        :param str summary_type: The monitor summary type to use. One of "monitors", "groups", or "combined". Defaults to "monitors".
        :param List[str] tags: List of tags to use in the widget.
        :param str text: The query to use to get monitors. Example: "status:alert".
        :param str text_align: The alignment of the text.
        :param str text_size: The size of the text in the widget.
        :param bool tick: Boolean indicating whether a tick should be displayed on the border of the widget.
        :param str tick_edge: When tick = true, string indicating on which side of the widget the tick should be displayed. One of "bottom", "top", "left", "right".
        :param str tick_pos: When tick = true, string with a percent sign indicating the position of the tick. Example: use tick_pos = "50%" for centered alignment.
        :param List['ScreenBoardWidgetTileDefArgs'] tile_deves: Nested block describing the content to display in the widget. The structure of this block is described below. At most one such block should be present in a given widget.
        :param Mapping[str, str] time: Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below. At most one such block should be present in a given widget.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. One of "left", "center", or "right".
        :param float title_size: The size of the widget's title. Default is 16.
        :param str unit: The unit for the value displayed in the widget.
        :param str url: The URL to use as a data source for the widget.
        :param str viz_type: Type of visualization to use when displaying the widget. Either "timeseries" or "toplist".
        :param float width: The width of the widget. Default is 50.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "x", x)
        pulumi.set(__self__, "y", y)
        if alert_id is not None:
            pulumi.set(__self__, "alert_id", alert_id)
        if auto_refresh is not None:
            pulumi.set(__self__, "auto_refresh", auto_refresh)
        if bgcolor is not None:
            pulumi.set(__self__, "bgcolor", bgcolor)
        if check is not None:
            pulumi.set(__self__, "check", check)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if color_preference is not None:
            pulumi.set(__self__, "color_preference", color_preference)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if display_format is not None:
            pulumi.set(__self__, "display_format", display_format)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if event_size is not None:
            pulumi.set(__self__, "event_size", event_size)
        if font_size is not None:
            pulumi.set(__self__, "font_size", font_size)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if grouping is not None:
            pulumi.set(__self__, "grouping", grouping)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if hide_zero_counts is not None:
            pulumi.set(__self__, "hide_zero_counts", hide_zero_counts)
        if html is not None:
            pulumi.set(__self__, "html", html)
        if layout_version is not None:
            pulumi.set(__self__, "layout_version", layout_version)
        if legend is not None:
            pulumi.set(__self__, "legend", legend)
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if logset is not None:
            pulumi.set(__self__, "logset", logset)
        if manage_status_show_title is not None:
            pulumi.set(__self__, "manage_status_show_title", manage_status_show_title)
        if manage_status_title_align is not None:
            pulumi.set(__self__, "manage_status_title_align", manage_status_title_align)
        if manage_status_title_size is not None:
            pulumi.set(__self__, "manage_status_title_size", manage_status_title_size)
        if manage_status_title_text is not None:
            pulumi.set(__self__, "manage_status_title_text", manage_status_title_text)
        if margin is not None:
            pulumi.set(__self__, "margin", margin)
        if monitor is not None:
            pulumi.set(__self__, "monitor", monitor)
        if must_show_breakdown is not None:
            pulumi.set(__self__, "must_show_breakdown", must_show_breakdown)
        if must_show_distribution is not None:
            pulumi.set(__self__, "must_show_distribution", must_show_distribution)
        if must_show_errors is not None:
            pulumi.set(__self__, "must_show_errors", must_show_errors)
        if must_show_hits is not None:
            pulumi.set(__self__, "must_show_hits", must_show_hits)
        if must_show_latency is not None:
            pulumi.set(__self__, "must_show_latency", must_show_latency)
        if must_show_resource_list is not None:
            pulumi.set(__self__, "must_show_resource_list", must_show_resource_list)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if service_service is not None:
            pulumi.set(__self__, "service_service", service_service)
        if show_last_triggered is not None:
            pulumi.set(__self__, "show_last_triggered", show_last_triggered)
        if size_version is not None:
            pulumi.set(__self__, "size_version", size_version)
        if sizing is not None:
            pulumi.set(__self__, "sizing", sizing)
        if summary_type is not None:
            pulumi.set(__self__, "summary_type", summary_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if text_size is not None:
            pulumi.set(__self__, "text_size", text_size)
        if tick is not None:
            pulumi.set(__self__, "tick", tick)
        if tick_edge is not None:
            pulumi.set(__self__, "tick_edge", tick_edge)
        if tick_pos is not None:
            pulumi.set(__self__, "tick_pos", tick_pos)
        if tile_deves is not None:
            pulumi.set(__self__, "tile_deves", tile_deves)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if timeframes is not None:
            pulumi.set(__self__, "timeframes", timeframes)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if viz_type is not None:
            pulumi.set(__self__, "viz_type", viz_type)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Choose the type of representation to use for this query. For widgets of type "timeseries" and "query_value", use one of "line", "bars" or "area". For widgets of type "hostmap", use "fill" or "size".
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def x(self) -> float:
        """
        The position of the widget on the x (horizontal) axis. Should be greater or equal to 0.
        """
        return pulumi.get(self, "x")

    @property
    @pulumi.getter
    def y(self) -> float:
        """
        The position of the widget on the y (vertical) axis. Should be greater or equal to 0.
        """
        return pulumi.get(self, "y")

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> Optional[float]:
        """
        The ID of the monitor used by the widget.
        """
        return pulumi.get(self, "alert_id")

    @property
    @pulumi.getter(name="autoRefresh")
    def auto_refresh(self) -> Optional[bool]:
        """
        Boolean indicating whether the widget is refreshed automatically.
        """
        return pulumi.get(self, "auto_refresh")

    @property
    @pulumi.getter
    def bgcolor(self) -> Optional[str]:
        """
        The color of the background of the widget.
        """
        return pulumi.get(self, "bgcolor")

    @property
    @pulumi.getter
    def check(self) -> Optional[str]:
        """
        The check to use in the widget.
        """
        return pulumi.get(self, "check")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        """
        The color of the text in the widget.
        """
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="colorPreference")
    def color_preference(self) -> Optional[str]:
        """
        Whether to colorize text or background. One of "text", "background".
        """
        return pulumi.get(self, "color_preference")

    @property
    @pulumi.getter
    def columns(self) -> Optional[str]:
        """
        Stringified list of columns to use. Example: `"[\"column1\",\"column2\",\"column3\"]"`
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter(name="displayFormat")
    def display_format(self) -> Optional[str]:
        """
        The display setting to use. One of "counts", "list", or "countsAndList".
        """
        return pulumi.get(self, "display_format")

    @property
    @pulumi.getter
    def env(self) -> Optional[str]:
        """
        The environment to use.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="eventSize")
    def event_size(self) -> Optional[str]:
        """
        The size of the events in the widget. Either "s" (small, title only) or "l" (large, full event).
        """
        return pulumi.get(self, "event_size")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[str]:
        """
        The size of the text in the widget.
        """
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        The list of tags to group nodes by.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List[str]]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def grouping(self) -> Optional[str]:
        """
        Either "check" or "cluster", depending on whether the widget should use a single check or a cluster of checks.
        """
        return pulumi.get(self, "grouping")

    @property
    @pulumi.getter
    def height(self) -> Optional[float]:
        """
        The height of the widget. Default is 15.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="hideZeroCounts")
    def hide_zero_counts(self) -> Optional[bool]:
        """
        Boolean indicating whether to hide empty categories.
        """
        return pulumi.get(self, "hide_zero_counts")

    @property
    @pulumi.getter
    def html(self) -> Optional[str]:
        """
        The content of the widget. HTML tags supported.
        """
        return pulumi.get(self, "html")

    @property
    @pulumi.getter(name="layoutVersion")
    def layout_version(self) -> Optional[str]:
        """
        The number of columns to use when displaying values. One of "one_column", "two_column", "three_column".
        """
        return pulumi.get(self, "layout_version")

    @property
    @pulumi.getter
    def legend(self) -> Optional[bool]:
        """
        Boolean indicating whether to display a legend in the widget.
        """
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[str]:
        """
        The size of the legend displayed in the widget.
        """
        return pulumi.get(self, "legend_size")

    @property
    @pulumi.getter
    def logset(self) -> Optional[str]:
        """
        ID of the logset to use.
        """
        return pulumi.get(self, "logset")

    @property
    @pulumi.getter(name="manageStatusShowTitle")
    def manage_status_show_title(self) -> Optional[bool]:
        """
        Boolean indicating whether to show a title.
        """
        return pulumi.get(self, "manage_status_show_title")

    @property
    @pulumi.getter(name="manageStatusTitleAlign")
    def manage_status_title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. One of "left", "center", or "right".
        """
        return pulumi.get(self, "manage_status_title_align")

    @property
    @pulumi.getter(name="manageStatusTitleSize")
    def manage_status_title_size(self) -> Optional[str]:
        """
        The size of the widget's title.
        """
        return pulumi.get(self, "manage_status_title_size")

    @property
    @pulumi.getter(name="manageStatusTitleText")
    def manage_status_title_text(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "manage_status_title_text")

    @property
    @pulumi.getter
    def margin(self) -> Optional[str]:
        """
        The margins to use around the image. Either "small" or "large".
        """
        return pulumi.get(self, "margin")

    @property
    @pulumi.getter
    def monitor(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "monitor")

    @property
    @pulumi.getter(name="mustShowBreakdown")
    def must_show_breakdown(self) -> Optional[bool]:
        """
        Boolean indicating whether to display breakdown.
        """
        return pulumi.get(self, "must_show_breakdown")

    @property
    @pulumi.getter(name="mustShowDistribution")
    def must_show_distribution(self) -> Optional[bool]:
        """
        Boolean indicating whether to display distribution.
        """
        return pulumi.get(self, "must_show_distribution")

    @property
    @pulumi.getter(name="mustShowErrors")
    def must_show_errors(self) -> Optional[bool]:
        """
        Boolean indicating whether to display errors.
        """
        return pulumi.get(self, "must_show_errors")

    @property
    @pulumi.getter(name="mustShowHits")
    def must_show_hits(self) -> Optional[bool]:
        """
        Boolean indicating whether to display hits.
        """
        return pulumi.get(self, "must_show_hits")

    @property
    @pulumi.getter(name="mustShowLatency")
    def must_show_latency(self) -> Optional[bool]:
        """
        Boolean indicating whether to display latency.
        """
        return pulumi.get(self, "must_show_latency")

    @property
    @pulumi.getter(name="mustShowResourceList")
    def must_show_resource_list(self) -> Optional[bool]:
        """
        Boolean indicating whether to display resources.
        """
        return pulumi.get(self, "must_show_resource_list")

    @property
    @pulumi.getter
    def params(self) -> Optional[Mapping[str, str]]:
        """
        Nested block describing the monitors to display. The structure of this block is described below. At most one such block should be present in a given widget.
        """
        return pulumi.get(self, "params")

    @property
    @pulumi.getter
    def precision(self) -> Optional[str]:
        """
        The precision to use when displaying the tile.
        """
        return pulumi.get(self, "precision")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        The query to use in the widget.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def rules(self) -> Optional[List['outputs.ScreenBoardWidgetRule']]:
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        """
        The name of the service to use.
        """
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter(name="serviceService")
    def service_service(self) -> Optional[str]:
        """
        The trace service to use.
        """
        return pulumi.get(self, "service_service")

    @property
    @pulumi.getter(name="showLastTriggered")
    def show_last_triggered(self) -> Optional[bool]:
        """
        Boolean indicating whether to show when monitors/groups last triggered.
        """
        return pulumi.get(self, "show_last_triggered")

    @property
    @pulumi.getter(name="sizeVersion")
    def size_version(self) -> Optional[str]:
        """
        The size of the widget. One of "small", "medium", "large".
        """
        return pulumi.get(self, "size_version")

    @property
    @pulumi.getter
    def sizing(self) -> Optional[str]:
        """
        The preferred method to adapt the dimensions of the image to those of the widget. One of "center" (center the image in the tile), "zoom" (zoom the image to cover the whole tile) or "fit" (fit the image dimensions to those of the tile).
        """
        return pulumi.get(self, "sizing")

    @property
    @pulumi.getter(name="summaryType")
    def summary_type(self) -> Optional[str]:
        """
        The monitor summary type to use. One of "monitors", "groups", or "combined". Defaults to "monitors".
        """
        return pulumi.get(self, "summary_type")

    @property
    @pulumi.getter
    def tags(self) -> Optional[List[str]]:
        """
        List of tags to use in the widget.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        """
        The query to use to get monitors. Example: "status:alert".
        """
        return pulumi.get(self, "text")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        """
        The alignment of the text.
        """
        return pulumi.get(self, "text_align")

    @property
    @pulumi.getter(name="textSize")
    def text_size(self) -> Optional[str]:
        """
        The size of the text in the widget.
        """
        return pulumi.get(self, "text_size")

    @property
    @pulumi.getter
    def tick(self) -> Optional[bool]:
        """
        Boolean indicating whether a tick should be displayed on the border of the widget.
        """
        return pulumi.get(self, "tick")

    @property
    @pulumi.getter(name="tickEdge")
    def tick_edge(self) -> Optional[str]:
        """
        When tick = true, string indicating on which side of the widget the tick should be displayed. One of "bottom", "top", "left", "right".
        """
        return pulumi.get(self, "tick_edge")

    @property
    @pulumi.getter(name="tickPos")
    def tick_pos(self) -> Optional[str]:
        """
        When tick = true, string with a percent sign indicating the position of the tick. Example: use tick_pos = "50%" for centered alignment.
        """
        return pulumi.get(self, "tick_pos")

    @property
    @pulumi.getter(name="tileDeves")
    def tile_deves(self) -> Optional[List['outputs.ScreenBoardWidgetTileDef']]:
        """
        Nested block describing the content to display in the widget. The structure of this block is described below. At most one such block should be present in a given widget.
        """
        return pulumi.get(self, "tile_deves")

    @property
    @pulumi.getter
    def time(self) -> Optional[Mapping[str, str]]:
        """
        Nested block describing the timeframe to use when displaying the widget. The structure of this block is described below. At most one such block should be present in a given widget.
        """
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def timeframes(self) -> Optional[List[str]]:
        return pulumi.get(self, "timeframes")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. One of "left", "center", or "right".
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[float]:
        """
        The size of the widget's title. Default is 16.
        """
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        """
        The unit for the value displayed in the widget.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL to use as a data source for the widget.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="vizType")
    def viz_type(self) -> Optional[str]:
        """
        Type of visualization to use when displaying the widget. Either "timeseries" or "toplist".
        """
        return pulumi.get(self, "viz_type")

    @property
    @pulumi.getter
    def width(self) -> Optional[float]:
        """
        The width of the widget. Default is 50.
        """
        return pulumi.get(self, "width")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScreenBoardWidgetRule(dict):
    def __init__(__self__, *,
                 color: Optional[str] = None,
                 threshold: Optional[float] = None,
                 timeframe: Optional[str] = None):
        """
        :param str color: The color of the text in the widget.
        """
        if color is not None:
            pulumi.set(__self__, "color", color)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        """
        The color of the text in the widget.
        """
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        return pulumi.get(self, "timeframe")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScreenBoardWidgetTileDef(dict):
    def __init__(__self__, *,
                 requests: List['outputs.ScreenBoardWidgetTileDefRequest'],
                 viz: str,
                 autoscale: Optional[bool] = None,
                 custom_unit: Optional[str] = None,
                 events: Optional[List['outputs.ScreenBoardWidgetTileDefEvent']] = None,
                 groups: Optional[List[str]] = None,
                 markers: Optional[List['outputs.ScreenBoardWidgetTileDefMarker']] = None,
                 no_group_hosts: Optional[bool] = None,
                 no_metric_hosts: Optional[bool] = None,
                 node_type: Optional[str] = None,
                 precision: Optional[str] = None,
                 scopes: Optional[List[str]] = None,
                 style: Optional[Mapping[str, Any]] = None,
                 text_align: Optional[str] = None):
        """
        :param List['ScreenBoardWidgetTileDefRequestArgs'] requests: Nested block describing the request to use when displaying the widget. The structure of this block is described below. Multiple request blocks are allowed within a given tile_def block.
        :param str viz: Should be the same as the widget's type. One of "timeseries", "query_value", "hostmap", "change", "toplist", "process".
        :param bool autoscale: Boolean indicating whether to automatically scale the tile.
        :param str custom_unit: The unit for the value displayed in the widget
        :param List['ScreenBoardWidgetTileDefEventArgs'] events: Nested block describing the event overlays to use when displaying the widget. The structure of this block is described below. At most one such block should be present in a given tile_def block.
        :param List[str] groups: The check group to use in the widget.
        :param List['ScreenBoardWidgetTileDefMarkerArgs'] markers: Nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple marker blocks are allowed within a given tile_def block.
        :param bool no_group_hosts: Boolean indicating whether to show ungrouped nodes.
        :param bool no_metric_hosts: Boolean indicating whether to show nodes with no metrics.
        :param str node_type: The type of node used. Either "host" or "container".
        :param str precision: The precision to use when displaying the value. Use "\*" for maximum precision.
        :param List[str] scopes: The list of tags to filter nodes by.
        :param Mapping[str, Any] style: Nested block describing how to display the widget. The structure of this block is described below. At most one such block should be present in a given tile_def block.
        :param str text_align: The alignment of the text in the widget.
        """
        pulumi.set(__self__, "requests", requests)
        pulumi.set(__self__, "viz", viz)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if custom_unit is not None:
            pulumi.set(__self__, "custom_unit", custom_unit)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if markers is not None:
            pulumi.set(__self__, "markers", markers)
        if no_group_hosts is not None:
            pulumi.set(__self__, "no_group_hosts", no_group_hosts)
        if no_metric_hosts is not None:
            pulumi.set(__self__, "no_metric_hosts", no_metric_hosts)
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)

    @property
    @pulumi.getter
    def requests(self) -> List['outputs.ScreenBoardWidgetTileDefRequest']:
        """
        Nested block describing the request to use when displaying the widget. The structure of this block is described below. Multiple request blocks are allowed within a given tile_def block.
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def viz(self) -> str:
        """
        Should be the same as the widget's type. One of "timeseries", "query_value", "hostmap", "change", "toplist", "process".
        """
        return pulumi.get(self, "viz")

    @property
    @pulumi.getter
    def autoscale(self) -> Optional[bool]:
        """
        Boolean indicating whether to automatically scale the tile.
        """
        return pulumi.get(self, "autoscale")

    @property
    @pulumi.getter(name="customUnit")
    def custom_unit(self) -> Optional[str]:
        """
        The unit for the value displayed in the widget
        """
        return pulumi.get(self, "custom_unit")

    @property
    @pulumi.getter
    def events(self) -> Optional[List['outputs.ScreenBoardWidgetTileDefEvent']]:
        """
        Nested block describing the event overlays to use when displaying the widget. The structure of this block is described below. At most one such block should be present in a given tile_def block.
        """
        return pulumi.get(self, "events")

    @property
    @pulumi.getter
    def groups(self) -> Optional[List[str]]:
        """
        The check group to use in the widget.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def markers(self) -> Optional[List['outputs.ScreenBoardWidgetTileDefMarker']]:
        """
        Nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple marker blocks are allowed within a given tile_def block.
        """
        return pulumi.get(self, "markers")

    @property
    @pulumi.getter(name="noGroupHosts")
    def no_group_hosts(self) -> Optional[bool]:
        """
        Boolean indicating whether to show ungrouped nodes.
        """
        return pulumi.get(self, "no_group_hosts")

    @property
    @pulumi.getter(name="noMetricHosts")
    def no_metric_hosts(self) -> Optional[bool]:
        """
        Boolean indicating whether to show nodes with no metrics.
        """
        return pulumi.get(self, "no_metric_hosts")

    @property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[str]:
        """
        The type of node used. Either "host" or "container".
        """
        return pulumi.get(self, "node_type")

    @property
    @pulumi.getter
    def precision(self) -> Optional[str]:
        """
        The precision to use when displaying the value. Use "\*" for maximum precision.
        """
        return pulumi.get(self, "precision")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[List[str]]:
        """
        The list of tags to filter nodes by.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def style(self) -> Optional[Mapping[str, Any]]:
        """
        Nested block describing how to display the widget. The structure of this block is described below. At most one such block should be present in a given tile_def block.
        """
        return pulumi.get(self, "style")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        """
        The alignment of the text in the widget.
        """
        return pulumi.get(self, "text_align")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScreenBoardWidgetTileDefEvent(dict):
    def __init__(__self__, *,
                 q: str):
        """
        :param str q: The search query for event overlays.
        """
        pulumi.set(__self__, "q", q)

    @property
    @pulumi.getter
    def q(self) -> str:
        """
        The search query for event overlays.
        """
        return pulumi.get(self, "q")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScreenBoardWidgetTileDefMarker(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str,
                 label: Optional[str] = None):
        """
        :param str type: The type of the widget. One of "free_text", "timeseries", "query_value", "toplist", "change", "event_timeline", "event_stream", "image", "note", "alert_graph", "alert_value", "iframe", "check_status", "trace_service", "hostmap", "manage_status", "log_stream", or "process".
        :param str value: Mathematical expression describing the marker. Examples: "y > 1", "-5 < y < 0", "y = 19".
        :param str label: A label for the line or range.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the widget. One of "free_text", "timeseries", "query_value", "toplist", "change", "event_timeline", "event_stream", "image", "note", "alert_graph", "alert_value", "iframe", "check_status", "trace_service", "hostmap", "manage_status", "log_stream", or "process".
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Mathematical expression describing the marker. Examples: "y > 1", "-5 < y < 0", "y = 19".
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        A label for the line or range.
        """
        return pulumi.get(self, "label")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScreenBoardWidgetTileDefRequest(dict):
    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 apm_query: Optional['outputs.ScreenBoardWidgetTileDefRequestApmQuery'] = None,
                 change_type: Optional[str] = None,
                 compare_to: Optional[str] = None,
                 conditional_formats: Optional[List['outputs.ScreenBoardWidgetTileDefRequestConditionalFormat']] = None,
                 extra_col: Optional[str] = None,
                 increase_good: Optional[bool] = None,
                 limit: Optional[float] = None,
                 log_query: Optional['outputs.ScreenBoardWidgetTileDefRequestLogQuery'] = None,
                 metadata_json: Optional[str] = None,
                 metric: Optional[str] = None,
                 order_by: Optional[str] = None,
                 order_dir: Optional[str] = None,
                 process_query: Optional['outputs.ScreenBoardWidgetTileDefRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 query_type: Optional[str] = None,
                 style: Optional[Mapping[str, Any]] = None,
                 tag_filters: Optional[List[str]] = None,
                 text_filter: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str aggregator: The aggregator to use for time aggregation. One of "avg", "min", "max", "sum", "last".
        :param 'ScreenBoardWidgetTileDefRequestApmQueryArgs' apm_query: The APM query to use in the widget. The structure of this block is described below.
        :param str change_type: Whether to show absolute or relative change. One of "absolute", "relative".
        :param str compare_to: Choose from when to compare current data to. One of "hour_before", "day_before", "week_before" or "month_before".
        :param List['ScreenBoardWidgetTileDefRequestConditionalFormatArgs'] conditional_formats: Nested block to customize the style if certain conditions are met. Currently only applies to `Query Value` and `Top List` type graphs.
        :param str extra_col: If set to "present", displays current value. Can be left empty otherwise.
        :param bool increase_good: Boolean indicating whether an increase in the value is good (thus displayed in green) or not (thus displayed in red).
        :param float limit: Integer indicating the number of hosts to limit to.
        :param 'ScreenBoardWidgetTileDefRequestLogQueryArgs' log_query: The log query to use in the widget. The structure of this block is described below.
        :param str metadata_json: A JSON blob representing mapping of query expressions to alias names. Note that the query expressions in `metadata_json` will be ignored if they're not present in the query. For example:
        :param str metric: The metric you want to use for the widget.
        :param str order_by: One of "change", "name", "present" (present value) or "past" (past value).
        :param str order_dir: Either "asc" (ascending) or "desc" (descending).
        :param 'ScreenBoardWidgetTileDefRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The search query for event overlays.
        :param str query_type: Use "process".
        :param Mapping[str, Any] style: Nested block describing how to display the widget. The structure of this block is described below. At most one such block should be present in a given tile_def block.
        :param List[str] tag_filters: Tags to use for filtering.
        :param str text_filter: The search query for the widget.
        :param str type: The type of the widget. One of "free_text", "timeseries", "query_value", "toplist", "change", "event_timeline", "event_stream", "image", "note", "alert_graph", "alert_value", "iframe", "check_status", "trace_service", "hostmap", "manage_status", "log_stream", or "process".
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if change_type is not None:
            pulumi.set(__self__, "change_type", change_type)
        if compare_to is not None:
            pulumi.set(__self__, "compare_to", compare_to)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if extra_col is not None:
            pulumi.set(__self__, "extra_col", extra_col)
        if increase_good is not None:
            pulumi.set(__self__, "increase_good", increase_good)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if metadata_json is not None:
            pulumi.set(__self__, "metadata_json", metadata_json)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order_by is not None:
            pulumi.set(__self__, "order_by", order_by)
        if order_dir is not None:
            pulumi.set(__self__, "order_dir", order_dir)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if query_type is not None:
            pulumi.set(__self__, "query_type", query_type)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregator to use for time aggregation. One of "avg", "min", "max", "sum", "last".
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.ScreenBoardWidgetTileDefRequestApmQuery']:
        """
        The APM query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="changeType")
    def change_type(self) -> Optional[str]:
        """
        Whether to show absolute or relative change. One of "absolute", "relative".
        """
        return pulumi.get(self, "change_type")

    @property
    @pulumi.getter(name="compareTo")
    def compare_to(self) -> Optional[str]:
        """
        Choose from when to compare current data to. One of "hour_before", "day_before", "week_before" or "month_before".
        """
        return pulumi.get(self, "compare_to")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[List['outputs.ScreenBoardWidgetTileDefRequestConditionalFormat']]:
        """
        Nested block to customize the style if certain conditions are met. Currently only applies to `Query Value` and `Top List` type graphs.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter(name="extraCol")
    def extra_col(self) -> Optional[str]:
        """
        If set to "present", displays current value. Can be left empty otherwise.
        """
        return pulumi.get(self, "extra_col")

    @property
    @pulumi.getter(name="increaseGood")
    def increase_good(self) -> Optional[bool]:
        """
        Boolean indicating whether an increase in the value is good (thus displayed in green) or not (thus displayed in red).
        """
        return pulumi.get(self, "increase_good")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        Integer indicating the number of hosts to limit to.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.ScreenBoardWidgetTileDefRequestLogQuery']:
        """
        The log query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="metadataJson")
    def metadata_json(self) -> Optional[str]:
        """
        A JSON blob representing mapping of query expressions to alias names. Note that the query expressions in `metadata_json` will be ignored if they're not present in the query. For example:
        """
        return pulumi.get(self, "metadata_json")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric you want to use for the widget.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="orderBy")
    def order_by(self) -> Optional[str]:
        """
        One of "change", "name", "present" (present value) or "past" (past value).
        """
        return pulumi.get(self, "order_by")

    @property
    @pulumi.getter(name="orderDir")
    def order_dir(self) -> Optional[str]:
        """
        Either "asc" (ascending) or "desc" (descending).
        """
        return pulumi.get(self, "order_dir")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.ScreenBoardWidgetTileDefRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The search query for event overlays.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="queryType")
    def query_type(self) -> Optional[str]:
        """
        Use "process".
        """
        return pulumi.get(self, "query_type")

    @property
    @pulumi.getter
    def style(self) -> Optional[Mapping[str, Any]]:
        """
        Nested block describing how to display the widget. The structure of this block is described below. At most one such block should be present in a given tile_def block.
        """
        return pulumi.get(self, "style")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[List[str]]:
        """
        Tags to use for filtering.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The search query for the widget.
        """
        return pulumi.get(self, "text_filter")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the widget. One of "free_text", "timeseries", "query_value", "toplist", "change", "event_timeline", "event_stream", "image", "note", "alert_graph", "alert_value", "iframe", "check_status", "trace_service", "hostmap", "manage_status", "log_stream", or "process".
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScreenBoardWidgetTileDefRequestApmQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.ScreenBoardWidgetTileDefRequestApmQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.ScreenBoardWidgetTileDefRequestApmQueryGroupBy']] = None,
                 search: Optional['outputs.ScreenBoardWidgetTileDefRequestApmQuerySearch'] = None):
        """
        :param 'ScreenBoardWidgetTileDefRequestApmQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['ScreenBoardWidgetTileDefRequestApmQueryGroupByArgs'] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param 'ScreenBoardWidgetTileDefRequestApmQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.ScreenBoardWidgetTileDefRequestApmQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.ScreenBoardWidgetTileDefRequestApmQueryGroupBy']]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.ScreenBoardWidgetTileDefRequestApmQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScreenBoardWidgetTileDefRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[str]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScreenBoardWidgetTileDefRequestApmQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.ScreenBoardWidgetTileDefRequestApmQueryGroupBySort'] = None):
        """
        :param float limit: Integer indicating the number of hosts to limit to.
        :param 'ScreenBoardWidgetTileDefRequestApmQueryGroupBySortArgs' sort: The method to use to sort monitors. Example: "status,asc".
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        Integer indicating the number of hosts to limit to.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.ScreenBoardWidgetTileDefRequestApmQueryGroupBySort']:
        """
        The method to use to sort monitors. Example: "status,asc".
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScreenBoardWidgetTileDefRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScreenBoardWidgetTileDefRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: The query to use in the widget.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The query to use in the widget.
        """
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScreenBoardWidgetTileDefRequestConditionalFormat(dict):
    def __init__(__self__, *,
                 comparator: str,
                 color: Optional[str] = None,
                 custom_bg_color: Optional[str] = None,
                 invert: Optional[bool] = None,
                 palette: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str comparator: Comparison operator. Example: ">", "<".
        :param str color: Custom color (e.g., #205081).
        :param bool invert: Boolean indicating whether to invert color scheme.
        :param str palette: Color scheme to be used if the condition is met. One of: "red_on_white", "white_on_red", "yellow_on_white", "white_on_yellow", "green_on_white", "white_on_green", "gray_on_white", "white_on_gray", "custom_text", "custom_bg", "custom_image".
        :param str value: Value that is the threshold for the conditional format.
        """
        pulumi.set(__self__, "comparator", comparator)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if invert is not None:
            pulumi.set(__self__, "invert", invert)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        Comparison operator. Example: ">", "<".
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        """
        Custom color (e.g., #205081).
        """
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter
    def invert(self) -> Optional[bool]:
        """
        Boolean indicating whether to invert color scheme.
        """
        return pulumi.get(self, "invert")

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        Color scheme to be used if the condition is met. One of: "red_on_white", "white_on_red", "yellow_on_white", "white_on_yellow", "green_on_white", "white_on_green", "gray_on_white", "white_on_gray", "custom_text", "custom_bg", "custom_image".
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value that is the threshold for the conditional format.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScreenBoardWidgetTileDefRequestLogQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.ScreenBoardWidgetTileDefRequestLogQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.ScreenBoardWidgetTileDefRequestLogQueryGroupBy']] = None,
                 search: Optional['outputs.ScreenBoardWidgetTileDefRequestLogQuerySearch'] = None):
        """
        :param 'ScreenBoardWidgetTileDefRequestLogQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['ScreenBoardWidgetTileDefRequestLogQueryGroupByArgs'] group_bies: When grouping = "cluster", indicates a list of tags to use for grouping.
        :param 'ScreenBoardWidgetTileDefRequestLogQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.ScreenBoardWidgetTileDefRequestLogQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.ScreenBoardWidgetTileDefRequestLogQueryGroupBy']]:
        """
        When grouping = "cluster", indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.ScreenBoardWidgetTileDefRequestLogQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScreenBoardWidgetTileDefRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[str]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScreenBoardWidgetTileDefRequestLogQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.ScreenBoardWidgetTileDefRequestLogQueryGroupBySort'] = None):
        """
        :param float limit: Integer indicating the number of hosts to limit to.
        :param 'ScreenBoardWidgetTileDefRequestLogQueryGroupBySortArgs' sort: The method to use to sort monitors. Example: "status,asc".
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        Integer indicating the number of hosts to limit to.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.ScreenBoardWidgetTileDefRequestLogQueryGroupBySort']:
        """
        The method to use to sort monitors. Example: "status,asc".
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScreenBoardWidgetTileDefRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScreenBoardWidgetTileDefRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: The query to use in the widget.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The query to use in the widget.
        """
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScreenBoardWidgetTileDefRequestProcessQuery(dict):
    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[List[str]] = None,
                 limit: Optional[float] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: The metric you want to use for the widget.
        :param float limit: Integer indicating the number of hosts to limit to.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric you want to use for the widget.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[List[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        """
        Integer indicating the number of hosts to limit to.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServiceLevelObjectiveQuery(dict):
    def __init__(__self__, *,
                 denominator: str,
                 numerator: str):
        """
        :param str denominator: the sum of the `total` events
               * Example Usage:
        :param str numerator: the sum of all the `good` events
        """
        pulumi.set(__self__, "denominator", denominator)
        pulumi.set(__self__, "numerator", numerator)

    @property
    @pulumi.getter
    def denominator(self) -> str:
        """
        the sum of the `total` events
        * Example Usage:
        """
        return pulumi.get(self, "denominator")

    @property
    @pulumi.getter
    def numerator(self) -> str:
        """
        the sum of all the `good` events
        """
        return pulumi.get(self, "numerator")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServiceLevelObjectiveThreshold(dict):
    def __init__(__self__, *,
                 target: float,
                 timeframe: str,
                 target_display: Optional[str] = None,
                 warning: Optional[float] = None,
                 warning_display: Optional[str] = None):
        """
        :param float target: the objective's target `[0,100]`
        :param str timeframe: the time frame for the objective. The mapping from these types to the types found in the Datadog Web UI can be found in the Datadog API [documentation](https://docs.datadoghq.com/api/v1/service-level-objectives/#create-a-slo-object) page. Available options to choose from are:
               * `7d`
               * `30d`
               * `90d`
        :param str target_display: the string version to specify additional digits in the case of `99` but want 3 digits like `99.000` to display.
        :param float warning: the objective's warning value `[0,100]`. This must be `> target` value.
        :param str warning_display: the string version to specify additional digits in the case of `99` but want 3 digits like `99.000` to display.
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "timeframe", timeframe)
        if target_display is not None:
            pulumi.set(__self__, "target_display", target_display)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)
        if warning_display is not None:
            pulumi.set(__self__, "warning_display", warning_display)

    @property
    @pulumi.getter
    def target(self) -> float:
        """
        the objective's target `[0,100]`
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def timeframe(self) -> str:
        """
        the time frame for the objective. The mapping from these types to the types found in the Datadog Web UI can be found in the Datadog API [documentation](https://docs.datadoghq.com/api/v1/service-level-objectives/#create-a-slo-object) page. Available options to choose from are:
        * `7d`
        * `30d`
        * `90d`
        """
        return pulumi.get(self, "timeframe")

    @property
    @pulumi.getter(name="targetDisplay")
    def target_display(self) -> Optional[str]:
        """
        the string version to specify additional digits in the case of `99` but want 3 digits like `99.000` to display.
        """
        return pulumi.get(self, "target_display")

    @property
    @pulumi.getter
    def warning(self) -> Optional[float]:
        """
        the objective's warning value `[0,100]`. This must be `> target` value.
        """
        return pulumi.get(self, "warning")

    @property
    @pulumi.getter(name="warningDisplay")
    def warning_display(self) -> Optional[str]:
        """
        the string version to specify additional digits in the case of `99` but want 3 digits like `99.000` to display.
        """
        return pulumi.get(self, "warning_display")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SyntheticsTestOptions(dict):
    def __init__(__self__, *,
                 tick_every: float,
                 accept_self_signed: Optional[bool] = None,
                 allow_insecure: Optional[bool] = None,
                 follow_redirects: Optional[bool] = None,
                 min_failure_duration: Optional[float] = None,
                 min_location_failed: Optional[float] = None):
        """
        :param float tick_every: How often the test should run (in seconds). Current possible values are 900, 1800, 3600, 21600, 43200, 86400, 604800 plus 60 if type=api or 300 if type=browser
        :param bool accept_self_signed: For type=ssl, true or false
        :param bool allow_insecure: For type=api, true or false. Allow your HTTP test go on with connection even if there is an error when validating the certificate.
        :param bool follow_redirects: For type=api, true or false
        :param float min_failure_duration: How long the test should be in failure before alerting (integer, number of seconds, max 7200). Default is 0.
        :param float min_location_failed: Threshold below which a synthetics test is allowed to fail before sending notifications
        """
        pulumi.set(__self__, "tick_every", tick_every)
        if accept_self_signed is not None:
            pulumi.set(__self__, "accept_self_signed", accept_self_signed)
        if allow_insecure is not None:
            pulumi.set(__self__, "allow_insecure", allow_insecure)
        if follow_redirects is not None:
            pulumi.set(__self__, "follow_redirects", follow_redirects)
        if min_failure_duration is not None:
            pulumi.set(__self__, "min_failure_duration", min_failure_duration)
        if min_location_failed is not None:
            pulumi.set(__self__, "min_location_failed", min_location_failed)

    @property
    @pulumi.getter(name="tickEvery")
    def tick_every(self) -> float:
        """
        How often the test should run (in seconds). Current possible values are 900, 1800, 3600, 21600, 43200, 86400, 604800 plus 60 if type=api or 300 if type=browser
        """
        return pulumi.get(self, "tick_every")

    @property
    @pulumi.getter(name="acceptSelfSigned")
    def accept_self_signed(self) -> Optional[bool]:
        """
        For type=ssl, true or false
        """
        return pulumi.get(self, "accept_self_signed")

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> Optional[bool]:
        """
        For type=api, true or false. Allow your HTTP test go on with connection even if there is an error when validating the certificate.
        """
        return pulumi.get(self, "allow_insecure")

    @property
    @pulumi.getter(name="followRedirects")
    def follow_redirects(self) -> Optional[bool]:
        """
        For type=api, true or false
        """
        return pulumi.get(self, "follow_redirects")

    @property
    @pulumi.getter(name="minFailureDuration")
    def min_failure_duration(self) -> Optional[float]:
        """
        How long the test should be in failure before alerting (integer, number of seconds, max 7200). Default is 0.
        """
        return pulumi.get(self, "min_failure_duration")

    @property
    @pulumi.getter(name="minLocationFailed")
    def min_location_failed(self) -> Optional[float]:
        """
        Threshold below which a synthetics test is allowed to fail before sending notifications
        """
        return pulumi.get(self, "min_location_failed")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SyntheticsTestRequest(dict):
    def __init__(__self__, *,
                 body: Optional[str] = None,
                 host: Optional[str] = None,
                 method: Optional[str] = None,
                 port: Optional[float] = None,
                 timeout: Optional[float] = None,
                 url: Optional[str] = None):
        """
        :param str body: Request body
        :param str host: host name
        :param str method: no-op, use GET
        :param float port: port number
        :param float timeout: For type=api, any value between 0 and 60 (Default = 60)
        :param str url: Any url
        """
        if body is not None:
            pulumi.set(__self__, "body", body)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        """
        Request body
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        host name
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        no-op, use GET
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def port(self) -> Optional[float]:
        """
        port number
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[float]:
        """
        For type=api, any value between 0 and 60 (Default = 60)
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        Any url
        """
        return pulumi.get(self, "url")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SyntheticsTestRequestBasicauth(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: Password for authentication
        :param str username: Username for authentication
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password for authentication
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username for authentication
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TimeBoardGraph(dict):
    def __init__(__self__, *,
                 requests: List['outputs.TimeBoardGraphRequest'],
                 title: str,
                 viz: str,
                 autoscale: Optional[bool] = None,
                 custom_unit: Optional[str] = None,
                 events: Optional[List[str]] = None,
                 groups: Optional[List[str]] = None,
                 include_no_metric_hosts: Optional[bool] = None,
                 include_ungrouped_hosts: Optional[bool] = None,
                 markers: Optional[List['outputs.TimeBoardGraphMarker']] = None,
                 node_type: Optional[str] = None,
                 precision: Optional[str] = None,
                 scopes: Optional[List[str]] = None,
                 style: Optional[Mapping[str, Any]] = None,
                 text_align: Optional[str] = None,
                 yaxis: Optional[Mapping[str, Any]] = None):
        """
        :param List['TimeBoardGraphRequestArgs'] requests: Nested block describing a graph definition request (a metric query to plot on the graph). The structure of this block is described below. Multiple request blocks are allowed within a graph block.
        :param str title: The name of the graph.
        :param str viz: The type of visualization to use for the graph. Valid choices are "change", "distribution", "heatmap", "hostmap", "query_value", timeseries", and "toplist".
        :param bool autoscale: Boolean that determines whether to autoscale graphs.
        :param str custom_unit: Display a custom unit on the graph (such as 'hertz')
        :param List[str] events: A list of event filter strings. Note that, while supported by the Datadog API, the Datadog UI does not (currently) support multiple event filters very well, so use at your own risk.
        :param List[str] groups: List of groups for hostmaps (shown as 'group by' in the UI).
        :param bool include_no_metric_hosts: If set to true, will display hosts on hostmap that have no reported metrics.
        :param bool include_ungrouped_hosts: If set to true, will display hosts without groups on hostmaps.
        :param List['TimeBoardGraphMarkerArgs'] markers: Nested block describing lines / ranges added to graph for formatting. The structure of this block is described below. Multiple marker blocks are allowed within a graph block.
        :param str node_type: What nodes to display in a hostmap. Can be one of 'host' (default) or 'container'.
        :param str precision: Number of digits displayed, use `*` for full precision.
        :param List[str] scopes: List of scopes for hostmaps (shown as 'filter by' in the UI).
        :param Mapping[str, Any] style: Nested block to customize the graph style.
        :param str text_align: How to align text in the graph, can be one of 'left', 'center', or 'right'.
        :param Mapping[str, Any] yaxis: Nested block describing modifications to the yaxis rendering. The structure of this block is described below.
        """
        pulumi.set(__self__, "requests", requests)
        pulumi.set(__self__, "title", title)
        pulumi.set(__self__, "viz", viz)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if custom_unit is not None:
            pulumi.set(__self__, "custom_unit", custom_unit)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if include_no_metric_hosts is not None:
            pulumi.set(__self__, "include_no_metric_hosts", include_no_metric_hosts)
        if include_ungrouped_hosts is not None:
            pulumi.set(__self__, "include_ungrouped_hosts", include_ungrouped_hosts)
        if markers is not None:
            pulumi.set(__self__, "markers", markers)
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter
    def requests(self) -> List['outputs.TimeBoardGraphRequest']:
        """
        Nested block describing a graph definition request (a metric query to plot on the graph). The structure of this block is described below. Multiple request blocks are allowed within a graph block.
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The name of the graph.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def viz(self) -> str:
        """
        The type of visualization to use for the graph. Valid choices are "change", "distribution", "heatmap", "hostmap", "query_value", timeseries", and "toplist".
        """
        return pulumi.get(self, "viz")

    @property
    @pulumi.getter
    def autoscale(self) -> Optional[bool]:
        """
        Boolean that determines whether to autoscale graphs.
        """
        return pulumi.get(self, "autoscale")

    @property
    @pulumi.getter(name="customUnit")
    def custom_unit(self) -> Optional[str]:
        """
        Display a custom unit on the graph (such as 'hertz')
        """
        return pulumi.get(self, "custom_unit")

    @property
    @pulumi.getter
    def events(self) -> Optional[List[str]]:
        """
        A list of event filter strings. Note that, while supported by the Datadog API, the Datadog UI does not (currently) support multiple event filters very well, so use at your own risk.
        """
        return pulumi.get(self, "events")

    @property
    @pulumi.getter
    def groups(self) -> Optional[List[str]]:
        """
        List of groups for hostmaps (shown as 'group by' in the UI).
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter(name="includeNoMetricHosts")
    def include_no_metric_hosts(self) -> Optional[bool]:
        """
        If set to true, will display hosts on hostmap that have no reported metrics.
        """
        return pulumi.get(self, "include_no_metric_hosts")

    @property
    @pulumi.getter(name="includeUngroupedHosts")
    def include_ungrouped_hosts(self) -> Optional[bool]:
        """
        If set to true, will display hosts without groups on hostmaps.
        """
        return pulumi.get(self, "include_ungrouped_hosts")

    @property
    @pulumi.getter
    def markers(self) -> Optional[List['outputs.TimeBoardGraphMarker']]:
        """
        Nested block describing lines / ranges added to graph for formatting. The structure of this block is described below. Multiple marker blocks are allowed within a graph block.
        """
        return pulumi.get(self, "markers")

    @property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[str]:
        """
        What nodes to display in a hostmap. Can be one of 'host' (default) or 'container'.
        """
        return pulumi.get(self, "node_type")

    @property
    @pulumi.getter
    def precision(self) -> Optional[str]:
        """
        Number of digits displayed, use `*` for full precision.
        """
        return pulumi.get(self, "precision")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[List[str]]:
        """
        List of scopes for hostmaps (shown as 'filter by' in the UI).
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def style(self) -> Optional[Mapping[str, Any]]:
        """
        Nested block to customize the graph style.
        """
        return pulumi.get(self, "style")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        """
        How to align text in the graph, can be one of 'left', 'center', or 'right'.
        """
        return pulumi.get(self, "text_align")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional[Mapping[str, Any]]:
        """
        Nested block describing modifications to the yaxis rendering. The structure of this block is described below.
        """
        return pulumi.get(self, "yaxis")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TimeBoardGraphMarker(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str,
                 label: Optional[str] = None):
        """
        :param str type: How the marker lines will look. Possible values are {"error", "warning", "info", "ok"} {"dashed", "solid", "bold"}. Example: "error dashed".
        :param str value: Mathematical expression describing the marker. Examples: "y > 1", "-5 < y < 0", "y = 19".
        :param str label: A label for the line or range. **Warning:** when a label is enabled but left empty through the UI, the Datadog API returns a boolean value, not a string. This makes `pulumi up` fail with a JSON decoding error.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        How the marker lines will look. Possible values are {"error", "warning", "info", "ok"} {"dashed", "solid", "bold"}. Example: "error dashed".
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Mathematical expression describing the marker. Examples: "y > 1", "-5 < y < 0", "y = 19".
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        A label for the line or range. **Warning:** when a label is enabled but left empty through the UI, the Datadog API returns a boolean value, not a string. This makes `pulumi up` fail with a JSON decoding error.
        """
        return pulumi.get(self, "label")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TimeBoardGraphRequest(dict):
    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 apm_query: Optional['outputs.TimeBoardGraphRequestApmQuery'] = None,
                 change_type: Optional[str] = None,
                 compare_to: Optional[str] = None,
                 conditional_formats: Optional[List['outputs.TimeBoardGraphRequestConditionalFormat']] = None,
                 extra_col: Optional[str] = None,
                 increase_good: Optional[bool] = None,
                 log_query: Optional['outputs.TimeBoardGraphRequestLogQuery'] = None,
                 metadata_json: Optional[str] = None,
                 order_by: Optional[str] = None,
                 order_direction: Optional[str] = None,
                 process_query: Optional['outputs.TimeBoardGraphRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 stacked: Optional[bool] = None,
                 style: Optional[Mapping[str, Any]] = None,
                 type: Optional[str] = None):
        """
        :param str aggregator: The aggregation method used when the number of data points outnumbers the max that can be shown.
        :param 'TimeBoardGraphRequestApmQueryArgs' apm_query: The APM query to use in the widget. The structure of this block is described below.
        :param List['TimeBoardGraphRequestConditionalFormatArgs'] conditional_formats: Nested block to customize the graph style if certain conditions are met. Currently only applies to `Query Value` and `Top List` type graphs.
        :param str extra_col: If set to "present", displays current value. Can be left empty otherwise.
        :param 'TimeBoardGraphRequestLogQueryArgs' log_query: The log query to use in the widget. The structure of this block is described below.
        :param str metadata_json: A JSON blob representing mapping of query expressions to alias names. Note that the query expressions in `metadata_json` will be ignored if they're not present in the query. For example:
        :param 'TimeBoardGraphRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The query of the request. Pro tip: Use the JSON tab inside the Datadog UI to help build you query strings.
        :param bool stacked: Boolean value to determine if this is this a stacked area graph. Default: false (line chart).
        :param Mapping[str, Any] style: Nested block describing hostmaps. The structure of this block is described below.
        :param str type: How the marker lines will look. Possible values are {"error", "warning", "info", "ok"} {"dashed", "solid", "bold"}. Example: "error dashed".
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if change_type is not None:
            pulumi.set(__self__, "change_type", change_type)
        if compare_to is not None:
            pulumi.set(__self__, "compare_to", compare_to)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if extra_col is not None:
            pulumi.set(__self__, "extra_col", extra_col)
        if increase_good is not None:
            pulumi.set(__self__, "increase_good", increase_good)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if metadata_json is not None:
            pulumi.set(__self__, "metadata_json", metadata_json)
        if order_by is not None:
            pulumi.set(__self__, "order_by", order_by)
        if order_direction is not None:
            pulumi.set(__self__, "order_direction", order_direction)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if stacked is not None:
            pulumi.set(__self__, "stacked", stacked)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation method used when the number of data points outnumbers the max that can be shown.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.TimeBoardGraphRequestApmQuery']:
        """
        The APM query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="changeType")
    def change_type(self) -> Optional[str]:
        return pulumi.get(self, "change_type")

    @property
    @pulumi.getter(name="compareTo")
    def compare_to(self) -> Optional[str]:
        return pulumi.get(self, "compare_to")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[List['outputs.TimeBoardGraphRequestConditionalFormat']]:
        """
        Nested block to customize the graph style if certain conditions are met. Currently only applies to `Query Value` and `Top List` type graphs.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter(name="extraCol")
    def extra_col(self) -> Optional[str]:
        """
        If set to "present", displays current value. Can be left empty otherwise.
        """
        return pulumi.get(self, "extra_col")

    @property
    @pulumi.getter(name="increaseGood")
    def increase_good(self) -> Optional[bool]:
        return pulumi.get(self, "increase_good")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.TimeBoardGraphRequestLogQuery']:
        """
        The log query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="metadataJson")
    def metadata_json(self) -> Optional[str]:
        """
        A JSON blob representing mapping of query expressions to alias names. Note that the query expressions in `metadata_json` will be ignored if they're not present in the query. For example:
        """
        return pulumi.get(self, "metadata_json")

    @property
    @pulumi.getter(name="orderBy")
    def order_by(self) -> Optional[str]:
        return pulumi.get(self, "order_by")

    @property
    @pulumi.getter(name="orderDirection")
    def order_direction(self) -> Optional[str]:
        return pulumi.get(self, "order_direction")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.TimeBoardGraphRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The query of the request. Pro tip: Use the JSON tab inside the Datadog UI to help build you query strings.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def stacked(self) -> Optional[bool]:
        """
        Boolean value to determine if this is this a stacked area graph. Default: false (line chart).
        """
        return pulumi.get(self, "stacked")

    @property
    @pulumi.getter
    def style(self) -> Optional[Mapping[str, Any]]:
        """
        Nested block describing hostmaps. The structure of this block is described below.
        """
        return pulumi.get(self, "style")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        How the marker lines will look. Possible values are {"error", "warning", "info", "ok"} {"dashed", "solid", "bold"}. Example: "error dashed".
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TimeBoardGraphRequestApmQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.TimeBoardGraphRequestApmQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.TimeBoardGraphRequestApmQueryGroupBy']] = None,
                 search: Optional['outputs.TimeBoardGraphRequestApmQuerySearch'] = None):
        """
        :param 'TimeBoardGraphRequestApmQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['TimeBoardGraphRequestApmQueryGroupByArgs'] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param 'TimeBoardGraphRequestApmQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.TimeBoardGraphRequestApmQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.TimeBoardGraphRequestApmQueryGroupBy']]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.TimeBoardGraphRequestApmQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TimeBoardGraphRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TimeBoardGraphRequestApmQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.TimeBoardGraphRequestApmQueryGroupBySort'] = None):
        """
        :param 'TimeBoardGraphRequestApmQueryGroupBySortArgs' sort: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.TimeBoardGraphRequestApmQueryGroupBySort']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TimeBoardGraphRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TimeBoardGraphRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TimeBoardGraphRequestConditionalFormat(dict):
    def __init__(__self__, *,
                 comparator: str,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 palette: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str comparator: Comparison operator. Example: ">", "<".
        :param str custom_bg_color: Used when `palette` is set to `custom_bg`. Set the color of the background to a custom web color, such as "#205081".
        :param str custom_fg_color: Used when `palette` is set to `custom_text`. Set the color of the text to a custom web color, such as "#205081".
        :param str palette: Color scheme to be used if the condition is met. For example: "red_on_white", "white_on_red", "yellow_on_white", "white_on_yellow", "green_on_white", "white_on_green", "gray_on_white", "white_on_gray", "custom_text", "custom_bg", "custom_image".
        :param str value: Value that is the threshold for the conditional format.
        """
        pulumi.set(__self__, "comparator", comparator)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        Comparison operator. Example: ">", "<".
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        Used when `palette` is set to `custom_bg`. Set the color of the background to a custom web color, such as "#205081".
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        Used when `palette` is set to `custom_text`. Set the color of the text to a custom web color, such as "#205081".
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        Color scheme to be used if the condition is met. For example: "red_on_white", "white_on_red", "yellow_on_white", "white_on_yellow", "green_on_white", "white_on_green", "gray_on_white", "white_on_gray", "custom_text", "custom_bg", "custom_image".
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value that is the threshold for the conditional format.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TimeBoardGraphRequestLogQuery(dict):
    def __init__(__self__, *,
                 compute: 'outputs.TimeBoardGraphRequestLogQueryCompute',
                 index: str,
                 group_bies: Optional[List['outputs.TimeBoardGraphRequestLogQueryGroupBy']] = None,
                 search: Optional['outputs.TimeBoardGraphRequestLogQuerySearch'] = None):
        """
        :param 'TimeBoardGraphRequestLogQueryComputeArgs' compute: . Exactly one nested block is required with the following structure:
        :param List['TimeBoardGraphRequestLogQueryGroupByArgs'] group_bies: . Multiple nested blocks are allowed with the following structure:
        :param 'TimeBoardGraphRequestLogQuerySearchArgs' search: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.TimeBoardGraphRequestLogQueryCompute':
        """
        . Exactly one nested block is required with the following structure:
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[List['outputs.TimeBoardGraphRequestLogQueryGroupBy']]:
        """
        . Multiple nested blocks are allowed with the following structure:
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.TimeBoardGraphRequestLogQuerySearch']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "search")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TimeBoardGraphRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[float] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TimeBoardGraphRequestLogQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[float] = None,
                 sort: Optional['outputs.TimeBoardGraphRequestLogQueryGroupBySort'] = None):
        """
        :param 'TimeBoardGraphRequestLogQueryGroupBySortArgs' sort: . One nested block is allowed with the following structure:
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.TimeBoardGraphRequestLogQueryGroupBySort']:
        """
        . One nested block is allowed with the following structure:
        """
        return pulumi.get(self, "sort")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TimeBoardGraphRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TimeBoardGraphRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TimeBoardGraphRequestProcessQuery(dict):
    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[List[str]] = None,
                 limit: Optional[float] = None,
                 search_by: Optional[str] = None):
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[List[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TimeBoardTemplateVariable(dict):
    def __init__(__self__, *,
                 name: str,
                 default: Optional[str] = None,
                 prefix: Optional[str] = None):
        """
        :param str name: The variable name. Can be referenced as \$name in `graph` `request` `q` query strings.
        :param str default: The default tag. Default: "\*" (match all).
        :param str prefix: The tag group. Default: no tag group.
        """
        pulumi.set(__self__, "name", name)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The variable name. Can be referenced as \$name in `graph` `request` `q` query strings.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def default(self) -> Optional[str]:
        """
        The default tag. Default: "\*" (match all).
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        The tag group. Default: no tag group.
        """
        return pulumi.get(self, "prefix")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetMonitorThresholdWindowsResult(dict):
    def __init__(__self__, *,
                 recovery_window: str,
                 trigger_window: str):
        pulumi.set(__self__, "recovery_window", recovery_window)
        pulumi.set(__self__, "trigger_window", trigger_window)

    @property
    @pulumi.getter(name="recoveryWindow")
    def recovery_window(self) -> str:
        return pulumi.get(self, "recovery_window")

    @property
    @pulumi.getter(name="triggerWindow")
    def trigger_window(self) -> str:
        return pulumi.get(self, "trigger_window")


@pulumi.output_type
class GetMonitorThresholdsResult(dict):
    def __init__(__self__, *,
                 critical: float,
                 critical_recovery: float,
                 ok: float,
                 unknown: float,
                 warning: float,
                 warning_recovery: float):
        pulumi.set(__self__, "critical", critical)
        pulumi.set(__self__, "critical_recovery", critical_recovery)
        pulumi.set(__self__, "ok", ok)
        pulumi.set(__self__, "unknown", unknown)
        pulumi.set(__self__, "warning", warning)
        pulumi.set(__self__, "warning_recovery", warning_recovery)

    @property
    @pulumi.getter
    def critical(self) -> float:
        return pulumi.get(self, "critical")

    @property
    @pulumi.getter(name="criticalRecovery")
    def critical_recovery(self) -> float:
        return pulumi.get(self, "critical_recovery")

    @property
    @pulumi.getter
    def ok(self) -> float:
        return pulumi.get(self, "ok")

    @property
    @pulumi.getter
    def unknown(self) -> float:
        return pulumi.get(self, "unknown")

    @property
    @pulumi.getter
    def warning(self) -> float:
        return pulumi.get(self, "warning")

    @property
    @pulumi.getter(name="warningRecovery")
    def warning_recovery(self) -> float:
        return pulumi.get(self, "warning_recovery")


