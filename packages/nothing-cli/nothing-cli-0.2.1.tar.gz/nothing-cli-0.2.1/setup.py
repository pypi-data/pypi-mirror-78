# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['nothing_cli',
 'nothing_cli.localization',
 'nothing_cli.tests',
 'nothing_cli.tests.test_filesystem',
 'nothing_cli.tests.test_main']

package_data = \
{'': ['*']}

install_requires = \
['colorama>=0.4.3,<0.5.0',
 'pydantic>=1.4,<2.0',
 'python-slugify>=4.0.0,<5.0.0',
 'ruamel.yaml>=0.16.10,<0.17.0',
 'typer>=0.1.0,<0.2.0',
 'typing-extensions>=3.7.4,<4.0.0']

entry_points = \
{'console_scripts': ['not = nothing_cli.main:app']}

setup_kwargs = {
    'name': 'nothing-cli',
    'version': '0.2.1',
    'description': 'Nothing helps coder be more smarter & less dumber.',
    'long_description': '# Nothing (`not`)\n\nNothing helps coders be more smarter, some cooler, less dumber, and much faster. `not`.\n\nTake hold of the key 🔑 to gradual automation.\n\n\n## Installation\n\n`nothing-cli` is very young, only an infant. 🐣\n\nIf you\'d like to give it a try, it\'s available in alpha on PyPi.\n\n```shell\npip install nothing-cli\n```\n\nIn part due to its youth, only Python 3.7 and above are supported. 😬\n\n\nThe command for interacting with the tool is `not`. Get the overview of its subcommands like so:\n\n```shell\nnot --help\n```\n\nGet a quick first taste by running:\n\n```python\nnot sample\n```\n\nYou should now have a sample Procedure available, aptly named `nothing`. Get an overview of what it does and where it lives with the `describe` subcommand:\n\n```shell\nnot describe nothing\n```\n\nYou can invoke it with the `do` subcommand:\n\n```shell\nnot do nothing\n```\n\nYou\'ll be walked through the Procedure for doing... nothing. Enjoy! Folks don\'t do enough nothing, in my opinion.\n\n## Overview\n\n### A Realistic Example\n\nThe central concept of `nothing-cli` is the *Procedure*. A Procedure is simply a `yaml` file in a `.nothing` directory. We interact with them with the `not` command.\n\nProcedures are not quite todo lists, not quite instructions, and not quite forms. The idea is to use them for infrequent, "toilsome" tasks that are easy to get lost in, annoying to document, and hard ––but very enticing–– to automate.\n\nHere\'s a simple Procedure for a developer\'s personal checklist before starting work on a new feature branch:\n\n```yaml\n---\ntitle: Get started with a feature branch\ndescription: A few preflight checks before you start coding\ncontext:\n  - dev_goal: Briefly, what do you want to accomplish with this branch?\n  - __feature_branch_name: What name did you come up with for the new branch?\nknowns:\n  - main_branch: master\nsteps: |-\n  Check out the main branch and get the latest changes:\n  git checkout {main_branch} && git pull\n\n  Think of a short, kebab-cased name that captures your goal:\n  "{dev_goal}"\n\n  Create the new branch:\n  git checkout -b {__feature_branch_name}\n\n  Push the new branch to the remote:\n  git push -u {__feature_branch_name}\n```\n\nIf you copy and paste the above into a file called `preflight-checks.yml` and save it in a directory called `.nothing` (either in your home or working directory), then you can "do" the Procedure by calling:\n\n```shell\nnot do preflight-checks\n```\n\nFor those without a terminal handy, it\'d look like this:\n\n[![asciicast](https://asciinema.org/a/cbLdJ1QCAhHzOuLsHWwZ4fr0e.svg)](https://asciinema.org/a/cbLdJ1QCAhHzOuLsHWwZ4fr0e)\n\n### Explanation\n\nThe required keys of a Procedure yaml file are:\n\n- `title`\n- `description`\n- `steps`\n\nOptionally, you can also add:\n\n- `context`\n- `knowns`\n\nLet\'s break each key down.\n\n#### `title`\n\nThis one is self-explanatory: It\'s the title of your Procedure! When creating a new Procedure with `not new`, the filename defaults to a `slugified-version` of this value, but you can change it during the process.\n\n#### `description`\n\nAlso self-explanatory. The description is required because, well, since when has extra documentation hurt anyone?\n\n#### `steps`\n\nThis is potentially the most unusual piece of a Procedure. You\'ll notice that the block of text is prepended by a `|-` and a newline.\n\nThat specifies a [block scalar](https://yaml-multiline.info/#block-scalars), a lesser-known feature of yaml. The very existence of this thing was a great inspiration to create this tool in the first place. It functions as a sort of lawless playground for plain text, supporting:\n\n- Multiline text and indentation.\n- A clear visual delineation of content from configuration (content here being your steps)\n- The specification of each step as a paragraph, which is is both obvious to read and easy to edit.\n\nIn line with the fun flirtiness of this tool, the last line of any step paragraph is highlighted, since the last line is a very common place to include a command to copy-paste, plus it adds gravitas. 😉\n\nWithin a step, any variable defined in `context` or `knowns` can be referenced in curly braces with a Python [f-string-style template](https://docs.python.org/3/tutorial/inputoutput.html#tut-f-strings). Which brings us to:\n\n#### `context`\n\nContext points to a list that contains any mix of plain strings and dictionaries. The former is "simple" and the latter "complex."\n\n```yaml\ncontext:\n  - simple_variable\n  - complex_variable: Answer this prompt to give a value to this context variable.\n```\n\nFor `simple_value`, the user would be prompted at the start of the run for the value with a default phrase: *Please provide a value for [variable name]*.\n\nFor a `complex_variable`, the dictionary key will be the variable name, and the value is the prompt used to ask for it. This is generally preferable, but simple context is there if you\'re in a hurry.\n\nThere\'s one more form for context known as "lazy context." Sometimes, it\'s not advantageous to prompt the user for a value at the very beginning of a run. With a lazy context variable, the user is prompted right before the first step that references it.\n\n```yaml\ncontext:\n  - __lazy_variable\n```\n\nThe dunder prefix is what lets `nothing-cli` know the variable is lazy. You\'ll notice that `__feature_branch_name` in the Procedure above is lazy. Lazy context variables can simple or complex and you can use them all you want.\n\n#### `knowns`\n\nKnowns are hardcoded context variables, essentially. They look a lot like complex context. The subtle differences are:\n\n1. Knowns can only be specified as dictionaries.\n2. The value of a known dictionary item is its *value*.\n\nThis is useful if you want to reference something changeable over and over again (like a build URL) but the user doesn\'t necessarily need to know it off the top of their head. This way, authors can disseminate useful information and change it later without making major edits.\n\n## Inspo & Rationale\n\nOnce upon a time, we all read this article about ["do-nothing scripting"](https://blog.danslimmon.com/2019/07/15/do-nothing-scripting-the-key-to-gradual-automation/) by Dan Slimmon.\n\nIt\'s an incredible concept. I\'ve personally wasted hours of my life trying to turn ever-more-complex aliases into [shell functions](https://github.com/ainsleymcgrath/bin/blob/master/.pydev.sh). I\'ve spent days attempting to automate scripts to do extremely infrequent –but highly toilsome– tasks that [probably would not even have taken hours manually](https://github.com/ainsleymcgrath/dotfiles/commit/46add94cb7b5ad068fd7b23fc8305aba85c63762).\n\n"Toil," as Slimmon terms it, sucks. We\'ll do anything to get away from it. Do-nothing scripts are a place to meet halfway: Nowhere near the cognitive overhead of writing an actual automation script, but more interactive and dynamic than pure documentation.\n\nBut, even logic-free & sugary sweet do-nothing scripts are written in the language of your choice can be fragile. Your stylistic decisions rot. There\'s no formality to creation or maintenance. Hardcoded strings sprinkled on off-the-cuff implementation. Suddenly, toil returns. Utility vanishes.\n\nRealizing this as my team and my friends experimented more with the practice, I did the logical thing: I wrote an entire piece of software to automate the process of writing the code we write to prevent ourselves from writing too much code to automate stuff when we want to stop *toiling* and just write some freaking code.\n\nIt\'s a noble cause, I think. [Insert infrequent terrible process] always goes faster when you can just ask your teammate for that really specific command and copy-paste. Cut them some slack. Get the command from a terminal robot.\n\n### Pudding (The proof is in it)\n\nHere is the original do-nothing script example from Slimmon\n\n```python\nimport sys\n\ndef wait_for_enter():\n    raw_input("Press Enter to continue: ")\n\nclass CreateSSHKeypairStep(object):\n    def run(self, context):\n        print("Run:")\n        print("   ssh-keygen -t rsa -f ~/{0}".format(context["username"]))\n        wait_for_enter()\n\nclass GitCommitStep(object):\n    def run(self, context):\n        print("Copy ~/new_key.pub into the `user_keys` Git repository, then run:")\n        print("    git commit {0}".format(context["username"]))\n        print("    git push")\n        wait_for_enter()\n\nclass WaitForBuildStep(object):\n    build_url = "http://example.com/builds/user_keys"\n    def run(self, context):\n        print("Wait for the build job at {0} to finish".format(self.build_url))\n        wait_for_enter()\n\nclass RetrieveUserEmailStep(object):\n    dir_url = "http://example.com/directory"\n    def run(self, context):\n        print("Go to {0}".format(self.dir_url))\n        print("Find the email address for user `{0}`".format(context["username"]))\n        context["email"] = raw_input("Paste the email address and press enter: ")\n\nclass SendPrivateKeyStep(object):\n    def run(self, context):\n        print("Go to 1Password")\n        print("Paste the contents of ~/new_key into a new document")\n        print("Share the document with {0}".format(context["email"]))\n        wait_for_enter()\n\nif __name__ == "__main__":\n    context = {"username": sys.argv[1]}\n    procedure = [\n        CreateSSHKeypairStep(),\n        GitCommitStep(),\n        WaitForBuildStep(),\n        RetrieveUserEmailStep(),\n        SendPrivateKeyStep(),\n    ]\n    for step in procedure:\n        step.run(context)\n    print("Done.")\n```\n\nHere it is translated to a `nothing-cli` Procedure:\n\n```yaml\n---\ntitle: Provision New User Account\ndescription: Create and distribute an SSH key for a new user.\ncontext:\n  - new_user_username\n  - __email: Find and copy the new user\'s email and paste here\nknowns:\n  - dir_url: http://example.com/directory\n  - build_url: http://example.com/builds/user_keys\nsteps: |-\n  Run:\n    ssh-keygen -t rsa -f ~/{new_user_username}\n\n  Copy ~/new_key.pub into the `user_keys` Git repository, then run:\n    git commit {new_user_username}; git push\n\n  Wait for the build job at {build_url} to finish.\n\n  Go to 1Password\n  Paste the contents of ~/new_key into a new document\n  Share the document with {__email}\n```\n\nI know it\'s impolite to talk about LOC, but the `nothing-cli` procedure version weighs in at 17 to the original 43 (excluding blank lines). The drastically improved readability and editability should speak for itself. The Procedure above is functionally identical to the original do-nothing script. Run them side by side and see!\n\n## Planned Features\n\nThe alpha version of `nothing-cli` was meant to be as focused as possible. For this reason, some mechanics of the original do-nothing script were omitted.\n\n#### Promptless Knowns & Context\n\nIn an ideal world, users could specify context as usual:\n\n```yaml\n---\n# diet-review.yml\ncontext:\n  - favorite_food: What\'s your favorite thing to eat?\n```\n\nBut then circumvent the prompt by running the Procedure like this:\n\n```shell\nnot do diet-review --favorite-food \'french omelet\'\n```\n\nEven more useful would be specifying a this for knowns:\n\n```yaml\n---\n# secret-stuff.yml\nknowns:\n  - secret_password\n```\n\nSpecifying a known with no value (as a plain yaml list item) would require the Procedure to be run with the value as a command-line option.\n\n```shell\nnot do secret-stuff # refuses to run\nnot do secret-stuff --secret_password \'n3veR $h4re tHis--\'\n```\n\n#### Chaining Procedures\n\nFor the composition-minded, it could be a boon to write small, related Procedures and have them run directly into each other, maybe even sharing context.\n\nThis could be specified at runtime:\n\n```yaml\nnot do proc-1 --chain proc-2 --chain proc-3\n```\n\nOr in the Procedure itself:\n\n```yaml\n---\n# use-chains.yml\ntitle: Use chains\ndescription: Demonstration of chain usage\ncontext:\n  - name\nsteps: |-\n  Love yourself and your colleagues, {name}.\n\n  Choose composition.\nchain:\n  to: review-chaining\n  pass_context: yes\n```\n\n#### Conditional Chaining\n\nWe\'re getting absolutely crazy here, but adding *several* features could allow for supercharged chains:\n\n```yaml\n---\n# ci-stuff.yml\ntitle: CI/CD Toil\ndescription: Boring CI thing, one day you\'ll automate. But not now.\ncontext:\n  # add syntax for limited choice context\n  - deploy_phase[dev/prod]: What kind of deploy are you doing?\nchain:\n   # use context to determine where chain\n  - if:\n      deploy_phase_is: dev\n      to: dev-deploy\n  - if:\n      deploy_phase_is: prod\n      to: prod-deploy\n```\n\nThis one is surely a moonshot but damn... I wanna do it 🤩\n\n#### And more!\n\nMy head is full of ideas! Perhaps yours is too. If you believe in this tool, drop me a line, I\'ll be overjoyed and say nice things to you. 😸\n',
    'author': 'Ainsley McGrath',
    'author_email': 'mcgrath.ainsley@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': None,
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'entry_points': entry_points,
    'python_requires': '>=3.6.1,<4.0.0',
}


setup(**setup_kwargs)
