<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>circuitgraph.transform API documentation</title>
<meta name="description" content="Functions for transforming circuits" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>circuitgraph.transform</code></h1>
</header>
<section id="section-intro">
<p>Functions for transforming circuits</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Functions for transforming circuits&#34;&#34;&#34;

import math
import code
from subprocess import PIPE, Popen
import subprocess
from tempfile import NamedTemporaryFile
from random import sample
import os
import shutil

import networkx as nx

from circuitgraph import Circuit
from circuitgraph.utils import clog2, lint
from circuitgraph.io import verilog_to_circuit, circuit_to_verilog


def copy(c):
    &#34;&#34;&#34;
    Returns copy of a circuit.

    Parameters
    ----------
    c: Circuit
            circuit to rename

    Returns
    -------
    Circuit
            Relabeled circuit.

    &#34;&#34;&#34;
    return Circuit(graph=c.graph.copy(), name=c.name)


def relabel(c, mapping):
    &#34;&#34;&#34;
    Returns renamed copy of a circuit.

    Parameters
    ----------
    c: Circuit
            circuit to rename
    mapping : dict of str:str
            mapping of old to new names

    Returns
    -------
    Circuit
            Relabeled circuit.

    &#34;&#34;&#34;
    return Circuit(graph=nx.relabel_nodes(c.graph, mapping), name=c.name)


def strip_io(c):
    &#34;&#34;&#34;
    Removes a circuit&#39;s outputs and converts inputs to buffers for easy
    instantiation.

    Parameters
    ----------
    c : Circuit
            circuit to strip io from

    Returns
    -------
    Circuit
            Circuit with removed io
    &#34;&#34;&#34;
    g = c.graph.copy()
    for o in c.outputs():
        g.nodes[o][&#34;output&#34;] = False
    for i in c.inputs():
        g.nodes[i][&#34;type&#34;] = &#34;buf&#34;

    return Circuit(graph=g, name=c.name)


def strip_outputs(c):
    &#34;&#34;&#34;
    Removes a circuit&#39;s outputs for easy
    instantiation.

    Parameters
    ----------
    c : Circuit
            circuit to strip io from

    Returns
    -------
    Circuit
            Circuit with removed io
    &#34;&#34;&#34;
    g = c.graph.copy()
    for o in c.outputs():
        g.nodes[o][&#34;output&#34;] = False

    return Circuit(graph=g, name=c.name)


def strip_inputs(c):
    &#34;&#34;&#34;
    Converts inputs to buffers for easy
    instantiation.

    Parameters
    ----------
    c : Circuit
            circuit to strip inputs from

    Returns
    -------
    Circuit
            Circuit with removed io
    &#34;&#34;&#34;
    g = c.graph.copy()
    for i in c.inputs():
        g.nodes[i][&#34;type&#34;] = &#34;buf&#34;

    return Circuit(graph=g, name=c.name)


def seq_graph(c):
    &#34;&#34;&#34;
    Creates a Circuit of the sequential elements and IO.

    Parameters
    ----------
    c: Circuit

    Returns
    -------
    Circuit
            Sequential circuit.

    &#34;&#34;&#34;
    s = Circuit(name=f&#34;{c.name}_seq&#34;)

    # add nodes
    for n in c.inputs() | c.seq():
        s.add(n, c.type(n), output=c.output(n))

    # add edges
    for n in c.seq():
        s.connect(c.startpoints(c.d(n)), n)

    # add outputs
    for n in s:
        if c.endpoints(n) &amp; c.outputs():
            s.set_output(n, True)

    return s


def syn(c, engine, print_output=False):
    &#34;&#34;&#34;
    Synthesizes the circuit using Genus.

    Parameters
    ----------
    c : Circuit
            Circuit to synthesize.
    engine : str
            Synthesis tool to use (&#39;Genus&#39; or &#39;Yosys&#39;)
    print_output : bool
            Option to print synthesis log

    Returns
    -------
    Circuit
            Synthesized circuit.
    &#34;&#34;&#34;
    verilog = circuit_to_verilog(c)

    with NamedTemporaryFile(prefix=&#34;circuitgraph_syn_genus_input&#34;) as tmp_in:
        tmp_in.write(bytes(verilog, &#34;ascii&#34;))
        tmp_in.flush()
        with NamedTemporaryFile(prefix=&#34;circuitgraph_syn_genus_output&#34;) as tmp_out:
            if engine == &#34;Genus&#34;:
                cmd = [
                    &#34;genus&#34;,
                    &#34;-no_gui&#34;,
                    &#34;-execute&#34;,
                    &#34;set_db / .library &#34;
                    f&#34;{os.environ[&#39;CIRCUITGRAPH_GENUS_LIBRARY_PATH&#39;]};\n&#34;
                    f&#34;read_hdl -sv {tmp_in.name};\n&#34;
                    &#34;elaborate;\n&#34;
                    &#34;set_db syn_generic_effort high;\n&#34;
                    &#34;syn_generic;\n&#34;
                    &#34;syn_map;\n&#34;
                    &#34;syn_opt;\n&#34;
                    f&#39;redirect {tmp_out.name} &#34;write_hdl -generic&#34;;\n&#39;
                    &#34;exit;&#34;,
                ]
            elif engine == &#34;Yosys&#34;:
                cmd = [
                    &#34;yosys&#34;,
                    &#34;-p&#34;,
                    f&#34;read_verilog {tmp_in.name}; &#34;
                    &#34;proc; opt; fsm; opt; memory; opt; clean; &#34;
                    f&#34;write_verilog -noattr {tmp_out.name}&#34;,
                ]

            else:
                raise ValueError(&#34;synthesis engine must be Yosys or Genus&#34;)

            process = Popen(cmd, stdout=PIPE, stderr=PIPE, universal_newlines=True)
            while True:
                line = process.stdout.readline()
                if line == &#34;&#34; and process.poll() is not None:
                    break
                if line:
                    if print_output:
                        print(line.strip())
            output = tmp_out.read().decode(&#34;utf-8&#34;)
            if print_output:
                print(output)

    return verilog_to_circuit(output, c.name)


def ternary(c):
    &#34;&#34;&#34;
    Encodes the circuit with ternary values

    Parameters
    ----------
    c : Circuit
            Circuit to encode.

    Returns
    -------
    Circuit
            Encoded circuit.

    &#34;&#34;&#34;
    t = copy(c)

    # add dual nodes
    for n in c:
        if c.type(n) in [&#34;and&#34;, &#34;nand&#34;]:
            t.add(f&#34;{n}_x&#34;, &#34;and&#34;, output=c.output(n))
            t.add(
                f&#34;{n}_x_in_fi&#34;,
                &#34;or&#34;,
                fanout=f&#34;{n}_x&#34;,
                fanin=[f&#34;{p}_x&#34; for p in c.fanin(n)],
            )
            t.add(f&#34;{n}_0_not_in_fi&#34;, &#34;nor&#34;, fanout=f&#34;{n}_x&#34;)

            for p in c.fanin(n):
                t.add(
                    f&#34;{p}_is_0&#34;, &#34;nor&#34;, fanout=f&#34;{n}_0_not_in_fi&#34;, fanin=[p, f&#34;{p}_x&#34;]
                )

        elif c.type(n) in [&#34;or&#34;, &#34;nor&#34;]:
            t.add(f&#34;{n}_x&#34;, &#34;and&#34;, output=c.output(n))
            t.add(
                f&#34;{n}_x_in_fi&#34;,
                &#34;or&#34;,
                fanout=f&#34;{n}_x&#34;,
                fanin=[f&#34;{p}_x&#34; for p in c.fanin(n)],
            )
            t.add(f&#34;{n}_1_not_in_fi&#34;, &#34;nor&#34;, fanout=f&#34;{n}_x&#34;)

            for p in c.fanin(n):
                t.add(f&#34;{p}_is_1&#34;, &#34;and&#34;, fanout=f&#34;{n}_1_not_in_fi&#34;, fanin=p)
                t.add(f&#34;{p}_not_x&#34;, &#34;not&#34;, fanout=f&#34;{p}_is_1&#34;, fanin=f&#34;{p}_x&#34;)

        elif c.type(n) in [&#34;buf&#34;, &#34;not&#34;]:
            p = c.fanin(n).pop()
            t.add(f&#34;{n}_x&#34;, &#34;buf&#34;, output=c.output(n), fanin=f&#34;{p}_x&#34;)

        elif c.type(n) in [&#34;xor&#34;, &#34;xnor&#34;]:
            t.add(
                f&#34;{n}_x&#34;, &#34;or&#34;, output=c.output(n), fanin=(f&#34;{p}_x&#34; for p in c.fanin(n))
            )

        elif c.type(n) in [&#34;0&#34;, &#34;1&#34;]:
            t.add(f&#34;{n}_x&#34;, &#34;0&#34;, output=c.output(n))

        elif c.type(n) in [&#34;input&#34;]:
            t.add(f&#34;{n}_x&#34;, &#34;input&#34;, output=c.output(n))

        elif c.type(n) in [&#34;ff&#34;, &#34;lat&#34;]:
            t.add(
                f&#34;{n}_x&#34;,
                c.type(n),
                output=c.output(n),
                clk=f&#34;{c.clk(n)}_x&#34;,
                r=f&#34;{c.r(n)}_x&#34;,
                s=f&#34;{c.s(n)}_x&#34;,
                fanin=f&#34;{c.fanin(n).pop()}_x&#34;,
            )

        elif c.type(n) in [&#34;0&#34;, &#34;1&#34;]:
            continue

    return t


def miter(c0, c1=None, startpoints=None, endpoints=None):
    &#34;&#34;&#34;
    Creates a miter circuit

    Parameters
    ----------
    c0 : Circuit
            First circuit.
    c1 : Circuit
            Optional second circuit, if None c0 is mitered with itself.
    startpoints : set of str
            Nodes to be tied together, must exist in both circuits.
    endpoints : set of str
            Nodes to be compared, must exist in both circuits.

    Returns
    -------
    Circuit
            Miter circuit.
    &#34;&#34;&#34;
    # clean inputs
    if not c1:
        c1 = c0
    if not startpoints:
        startpoints = c0.startpoints() &amp; c1.startpoints()
    if not endpoints:
        endpoints = c0.endpoints() &amp; c1.endpoints()

    # create miter, relabel
    m = relabel(c0, {n: f&#34;c0_{n}&#34; for n in c0.nodes() - startpoints})
    m.extend(relabel(c1, {n: f&#34;c1_{n}&#34; for n in c1.nodes() - startpoints}))
    strip_outputs(m)

    # compare endpoints
    m.add(&#34;sat&#34;, &#34;or&#34;, output=True)
    for o in endpoints - startpoints:
        m.add(f&#34;miter_{o}&#34;, &#34;xor&#34;, fanout=[&#34;sat&#34;], fanin=[f&#34;c0_{o}&#34;, f&#34;c1_{o}&#34;])
    return m


def comb(c):
    &#34;&#34;&#34;
    Creates combinational version of the circuit.

    Parameters
    ----------
    c : Circuit
            Sequential circuit to make combinational.

    Returns
    -------
    Circuit
            Combinational circuit.

    &#34;&#34;&#34;
    import circuitgraph.logic as logic

    c_comb = copy(c)
    lat_model = logic.comb_lat()
    ff_model = logic.comb_ff()

    for s in c.seq():
        model = lat_model if c.type(s) == &#34;lat&#34; else ff_model
        relabeled_model = relabel(model, {n: f&#34;{s}_{n}&#34; for n in model})
        c_comb.extend(relabeled_model)
        c_comb.connect(f&#34;{s}_q&#34;, c_comb.fanout(s))
        c_comb.connect(c_comb.fanin(s), f&#34;{s}_d&#34;)
        if c.clk(s):
            c_comb.connect(c.clk(s), f&#34;{s}_clk&#34;)
        if c.r(s):
            c_comb.connect(c.r(s), f&#34;{s}_rst&#34;)
        if c.s(s):
            c_comb.connect(c.s(s), f&#34;{s}_set&#34;)
        c_comb.remove(s)

    return c_comb


def unroll(c, cycles):
    &#34;&#34;&#34;
    Creates combinational unrolling of the circuit.

    Parameters
    ----------
    c : Circuit
            Sequential circuit to unroll.
    cycles : int
            Number of cycles to unroll

    Returns
    -------
    Circuit
            Unrolled circuit.

    &#34;&#34;&#34;
    u = Circuit()
    c_comb = comb(c)
    for i in range(cycles):
        u.extend(c_comb, {n: f&#34;{n}_{i}&#34; for n in c_comb})
        if i == 0:
            # convert si to inputs
            for n in c:
                if c.type(n) in [&#34;lat&#34;, &#34;ff&#34;]:
                    u.set_type(f&#34;{n}_si_{i}&#34;, &#34;input&#34;)

        else:
            # connect prev si
            for n in c:
                if c.type(n) in [&#34;lat&#34;, &#34;ff&#34;]:
                    u.connect(f&#34;{n}_si_{i-1}&#34;, f&#34;{n}_si_{i}&#34;)

    return u


def influence_transform(c, n, s):
    &#34;&#34;&#34;
    Creates a circuit to compute sensitivity.

    Parameters
    ----------
    c : Circuit
            Sequential circuit to unroll.
    n : str
            Node to compute influence at.
    s : str
            Startpoint to compute influence for.

    Returns
    -------
    Circuit
            Influence circuit.

    &#34;&#34;&#34;
    # check if s is in startpoints
    sp = c.startpoints(n)
    if s not in sp:
        raise ValueError(f&#34;{s} is not in startpoints of {n}&#34;)

    # get input cone
    fiNodes = c.transitive_fanin(n) | set([n])
    sub_c = Circuit(c.graph.subgraph(fiNodes).copy())

    # remove outs, convert startpoints
    sub_c.set_output(sub_c.outputs(), False)
    sub_c.set_type(sub_c.startpoints(), &#34;input&#34;)

    # create two copies of sub circuit
    infl = Circuit(name=f&#34;infl_{s}_on_{n}&#34;)
    infl.extend(sub_c)
    infl.extend(relabel(sub_c, {g: f&#34;s1_{g}&#34; for g in sub_c if g not in sp - set([s])}))
    infl.add(&#34;sat&#34;, &#34;xor&#34;, fanin=[n, f&#34;s1_{n}&#34;], output=True)
    infl.add(f&#34;not_{s}&#34;, &#34;not&#34;, fanin=s, fanout=f&#34;s1_{s}&#34;)

    return infl


def sensitivity_transform(c, n, startpoints=None):
    &#34;&#34;&#34;
    Creates a circuit to compute sensitivity.

    Parameters
    ----------
    c : Circuit
            Sequential circuit to unroll.
    n : str
            Node to compute sensitivity at.
    startpoints : iterable of str
            startpoints of n to flip.

    Returns
    -------
    Circuit
            Sensitivity circuit.

    &#34;&#34;&#34;
    import circuitgraph.logic as logic

    # choose all startpoints if not specified
    if startpoints is None:
        startpoints = c.startpoints(n)
    all_startpoints = c.startpoints(n)

    # get fanin cone of node
    if n in c.startpoints():
        raise ValueError(f&#34;{n} is in startpoints&#34;)

    # get input cone
    fiNodes = c.transitive_fanin(n) | set([n])
    sub_c = Circuit(c.graph.subgraph(fiNodes).copy())

    # remove outs, convert startpoints
    sub_c.set_output(sub_c.outputs(), False)
    sub_c.set_type(sub_c.startpoints(), &#34;input&#34;)
    sub_c.disconnect(sub_c.nodes(), sub_c.startpoints())

    # create sensitivity circuit and add first copy of subcircuit
    sen = Circuit()
    sen.extend(sub_c)

    # instantiate population count
    p = strip_io(logic.popcount(len(startpoints)))
    p = relabel(p, {g: f&#34;pop_{g}&#34; for g in p})
    sen.extend(p)
    for o in range(clog2(len(startpoints) + 1)):
        sen.add(f&#34;out_{o}&#34;, &#34;buf&#34;, fanin=f&#34;pop_out_{o}&#34;, output=True)

    # stamp out a copies of the circuit with s inverted
    for i, s in enumerate(startpoints):
        mapping = {
            g: f&#34;sen_{s}_{g}&#34; for g in sub_c if g not in all_startpoints - set([s])
        }
        sen.extend(relabel(sub_c, mapping))

        # connect inverted input
        sen.set_type(f&#34;sen_{s}_{s}&#34;, &#34;not&#34;)
        sen.connect(s, f&#34;sen_{s}_{s}&#34;)

        # compare to first copy
        sen.add(
            f&#34;difference_{s}&#34;,
            &#34;xor&#34;,
            fanin=[n, f&#34;sen_{s}_{n}&#34;],
            fanout=f&#34;pop_in_{i}&#34;,
            output=True,
        )

    return sen


def sensitization_transform(c, n):
    &#34;&#34;&#34;
    Creates a circuit to sensitize a node to an endpoint.

    Parameters
    ----------
    c : Circuit
            Input circuit.
    n : str
            Node to sensitize.

    Returns
    -------
    Circuit
            Output circuit.

    &#34;&#34;&#34;
    # create miter, relabel
    s = copy(c)
    s.extend(relabel(c, {n: f&#34;c1_{n}&#34; for n in c}))
    strip_outputs(s)

    # connect startpoints
    for g in c.startpoints():
        s.set_type(f&#34;c1_{g}&#34;, &#34;buf&#34;)
        s.disconnect(s.fanin(f&#34;c1_{g}&#34;), f&#34;c1_{g}&#34;)
        s.connect(g, f&#34;c1_{g}&#34;)

    # compare endpoints
    s.add(&#34;sat&#34;, &#34;or&#34;, output=True)
    for o in c.endpoints():
        s.add(f&#34;miter_{o}&#34;, &#34;xor&#34;, fanout=[&#34;sat&#34;], fanin=[o, f&#34;c1_{o}&#34;])

    # flip node in c1
    s.disconnect(s.fanin(f&#34;c1_{n}&#34;), f&#34;c1_{n}&#34;)
    s.set_type(f&#34;c1_{n}&#34;, &#34;not&#34;)
    s.connect(n, f&#34;c1_{n}&#34;)

    return s</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="circuitgraph.transform.comb"><code class="name flex">
<span>def <span class="ident">comb</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates combinational version of the circuit.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>Sequential circuit to make combinational.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Combinational circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comb(c):
    &#34;&#34;&#34;
    Creates combinational version of the circuit.

    Parameters
    ----------
    c : Circuit
            Sequential circuit to make combinational.

    Returns
    -------
    Circuit
            Combinational circuit.

    &#34;&#34;&#34;
    import circuitgraph.logic as logic

    c_comb = copy(c)
    lat_model = logic.comb_lat()
    ff_model = logic.comb_ff()

    for s in c.seq():
        model = lat_model if c.type(s) == &#34;lat&#34; else ff_model
        relabeled_model = relabel(model, {n: f&#34;{s}_{n}&#34; for n in model})
        c_comb.extend(relabeled_model)
        c_comb.connect(f&#34;{s}_q&#34;, c_comb.fanout(s))
        c_comb.connect(c_comb.fanin(s), f&#34;{s}_d&#34;)
        if c.clk(s):
            c_comb.connect(c.clk(s), f&#34;{s}_clk&#34;)
        if c.r(s):
            c_comb.connect(c.r(s), f&#34;{s}_rst&#34;)
        if c.s(s):
            c_comb.connect(c.s(s), f&#34;{s}_set&#34;)
        c_comb.remove(s)

    return c_comb</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns copy of a circuit.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>circuit to rename</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Relabeled circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(c):
    &#34;&#34;&#34;
    Returns copy of a circuit.

    Parameters
    ----------
    c: Circuit
            circuit to rename

    Returns
    -------
    Circuit
            Relabeled circuit.

    &#34;&#34;&#34;
    return Circuit(graph=c.graph.copy(), name=c.name)</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.influence_transform"><code class="name flex">
<span>def <span class="ident">influence_transform</span></span>(<span>c, n, s)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a circuit to compute sensitivity.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>Sequential circuit to unroll.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>str</code></dt>
<dd>Node to compute influence at.</dd>
<dt><strong><code>s</code></strong> :&ensp;<code>str</code></dt>
<dd>Startpoint to compute influence for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Influence circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def influence_transform(c, n, s):
    &#34;&#34;&#34;
    Creates a circuit to compute sensitivity.

    Parameters
    ----------
    c : Circuit
            Sequential circuit to unroll.
    n : str
            Node to compute influence at.
    s : str
            Startpoint to compute influence for.

    Returns
    -------
    Circuit
            Influence circuit.

    &#34;&#34;&#34;
    # check if s is in startpoints
    sp = c.startpoints(n)
    if s not in sp:
        raise ValueError(f&#34;{s} is not in startpoints of {n}&#34;)

    # get input cone
    fiNodes = c.transitive_fanin(n) | set([n])
    sub_c = Circuit(c.graph.subgraph(fiNodes).copy())

    # remove outs, convert startpoints
    sub_c.set_output(sub_c.outputs(), False)
    sub_c.set_type(sub_c.startpoints(), &#34;input&#34;)

    # create two copies of sub circuit
    infl = Circuit(name=f&#34;infl_{s}_on_{n}&#34;)
    infl.extend(sub_c)
    infl.extend(relabel(sub_c, {g: f&#34;s1_{g}&#34; for g in sub_c if g not in sp - set([s])}))
    infl.add(&#34;sat&#34;, &#34;xor&#34;, fanin=[n, f&#34;s1_{n}&#34;], output=True)
    infl.add(f&#34;not_{s}&#34;, &#34;not&#34;, fanin=s, fanout=f&#34;s1_{s}&#34;)

    return infl</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.miter"><code class="name flex">
<span>def <span class="ident">miter</span></span>(<span>c0, c1=None, startpoints=None, endpoints=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a miter circuit</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c0</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>First circuit.</dd>
<dt><strong><code>c1</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>Optional second circuit, if None c0 is mitered with itself.</dd>
<dt><strong><code>startpoints</code></strong> :&ensp;<code>set</code> of <code>str</code></dt>
<dd>Nodes to be tied together, must exist in both circuits.</dd>
<dt><strong><code>endpoints</code></strong> :&ensp;<code>set</code> of <code>str</code></dt>
<dd>Nodes to be compared, must exist in both circuits.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Miter circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def miter(c0, c1=None, startpoints=None, endpoints=None):
    &#34;&#34;&#34;
    Creates a miter circuit

    Parameters
    ----------
    c0 : Circuit
            First circuit.
    c1 : Circuit
            Optional second circuit, if None c0 is mitered with itself.
    startpoints : set of str
            Nodes to be tied together, must exist in both circuits.
    endpoints : set of str
            Nodes to be compared, must exist in both circuits.

    Returns
    -------
    Circuit
            Miter circuit.
    &#34;&#34;&#34;
    # clean inputs
    if not c1:
        c1 = c0
    if not startpoints:
        startpoints = c0.startpoints() &amp; c1.startpoints()
    if not endpoints:
        endpoints = c0.endpoints() &amp; c1.endpoints()

    # create miter, relabel
    m = relabel(c0, {n: f&#34;c0_{n}&#34; for n in c0.nodes() - startpoints})
    m.extend(relabel(c1, {n: f&#34;c1_{n}&#34; for n in c1.nodes() - startpoints}))
    strip_outputs(m)

    # compare endpoints
    m.add(&#34;sat&#34;, &#34;or&#34;, output=True)
    for o in endpoints - startpoints:
        m.add(f&#34;miter_{o}&#34;, &#34;xor&#34;, fanout=[&#34;sat&#34;], fanin=[f&#34;c0_{o}&#34;, f&#34;c1_{o}&#34;])
    return m</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.relabel"><code class="name flex">
<span>def <span class="ident">relabel</span></span>(<span>c, mapping)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns renamed copy of a circuit.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>circuit to rename</dd>
<dt><strong><code>mapping</code></strong> :&ensp;<code>dict</code> of <code>str:str</code></dt>
<dd>mapping of old to new names</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Relabeled circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def relabel(c, mapping):
    &#34;&#34;&#34;
    Returns renamed copy of a circuit.

    Parameters
    ----------
    c: Circuit
            circuit to rename
    mapping : dict of str:str
            mapping of old to new names

    Returns
    -------
    Circuit
            Relabeled circuit.

    &#34;&#34;&#34;
    return Circuit(graph=nx.relabel_nodes(c.graph, mapping), name=c.name)</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.sensitivity_transform"><code class="name flex">
<span>def <span class="ident">sensitivity_transform</span></span>(<span>c, n, startpoints=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a circuit to compute sensitivity.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>Sequential circuit to unroll.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>str</code></dt>
<dd>Node to compute sensitivity at.</dd>
<dt><strong><code>startpoints</code></strong> :&ensp;<code>iterable</code> of <code>str</code></dt>
<dd>startpoints of n to flip.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Sensitivity circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sensitivity_transform(c, n, startpoints=None):
    &#34;&#34;&#34;
    Creates a circuit to compute sensitivity.

    Parameters
    ----------
    c : Circuit
            Sequential circuit to unroll.
    n : str
            Node to compute sensitivity at.
    startpoints : iterable of str
            startpoints of n to flip.

    Returns
    -------
    Circuit
            Sensitivity circuit.

    &#34;&#34;&#34;
    import circuitgraph.logic as logic

    # choose all startpoints if not specified
    if startpoints is None:
        startpoints = c.startpoints(n)
    all_startpoints = c.startpoints(n)

    # get fanin cone of node
    if n in c.startpoints():
        raise ValueError(f&#34;{n} is in startpoints&#34;)

    # get input cone
    fiNodes = c.transitive_fanin(n) | set([n])
    sub_c = Circuit(c.graph.subgraph(fiNodes).copy())

    # remove outs, convert startpoints
    sub_c.set_output(sub_c.outputs(), False)
    sub_c.set_type(sub_c.startpoints(), &#34;input&#34;)
    sub_c.disconnect(sub_c.nodes(), sub_c.startpoints())

    # create sensitivity circuit and add first copy of subcircuit
    sen = Circuit()
    sen.extend(sub_c)

    # instantiate population count
    p = strip_io(logic.popcount(len(startpoints)))
    p = relabel(p, {g: f&#34;pop_{g}&#34; for g in p})
    sen.extend(p)
    for o in range(clog2(len(startpoints) + 1)):
        sen.add(f&#34;out_{o}&#34;, &#34;buf&#34;, fanin=f&#34;pop_out_{o}&#34;, output=True)

    # stamp out a copies of the circuit with s inverted
    for i, s in enumerate(startpoints):
        mapping = {
            g: f&#34;sen_{s}_{g}&#34; for g in sub_c if g not in all_startpoints - set([s])
        }
        sen.extend(relabel(sub_c, mapping))

        # connect inverted input
        sen.set_type(f&#34;sen_{s}_{s}&#34;, &#34;not&#34;)
        sen.connect(s, f&#34;sen_{s}_{s}&#34;)

        # compare to first copy
        sen.add(
            f&#34;difference_{s}&#34;,
            &#34;xor&#34;,
            fanin=[n, f&#34;sen_{s}_{n}&#34;],
            fanout=f&#34;pop_in_{i}&#34;,
            output=True,
        )

    return sen</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.sensitization_transform"><code class="name flex">
<span>def <span class="ident">sensitization_transform</span></span>(<span>c, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a circuit to sensitize a node to an endpoint.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>Input circuit.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>str</code></dt>
<dd>Node to sensitize.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Output circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sensitization_transform(c, n):
    &#34;&#34;&#34;
    Creates a circuit to sensitize a node to an endpoint.

    Parameters
    ----------
    c : Circuit
            Input circuit.
    n : str
            Node to sensitize.

    Returns
    -------
    Circuit
            Output circuit.

    &#34;&#34;&#34;
    # create miter, relabel
    s = copy(c)
    s.extend(relabel(c, {n: f&#34;c1_{n}&#34; for n in c}))
    strip_outputs(s)

    # connect startpoints
    for g in c.startpoints():
        s.set_type(f&#34;c1_{g}&#34;, &#34;buf&#34;)
        s.disconnect(s.fanin(f&#34;c1_{g}&#34;), f&#34;c1_{g}&#34;)
        s.connect(g, f&#34;c1_{g}&#34;)

    # compare endpoints
    s.add(&#34;sat&#34;, &#34;or&#34;, output=True)
    for o in c.endpoints():
        s.add(f&#34;miter_{o}&#34;, &#34;xor&#34;, fanout=[&#34;sat&#34;], fanin=[o, f&#34;c1_{o}&#34;])

    # flip node in c1
    s.disconnect(s.fanin(f&#34;c1_{n}&#34;), f&#34;c1_{n}&#34;)
    s.set_type(f&#34;c1_{n}&#34;, &#34;not&#34;)
    s.connect(n, f&#34;c1_{n}&#34;)

    return s</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.seq_graph"><code class="name flex">
<span>def <span class="ident">seq_graph</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a Circuit of the sequential elements and IO.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Sequential circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def seq_graph(c):
    &#34;&#34;&#34;
    Creates a Circuit of the sequential elements and IO.

    Parameters
    ----------
    c: Circuit

    Returns
    -------
    Circuit
            Sequential circuit.

    &#34;&#34;&#34;
    s = Circuit(name=f&#34;{c.name}_seq&#34;)

    # add nodes
    for n in c.inputs() | c.seq():
        s.add(n, c.type(n), output=c.output(n))

    # add edges
    for n in c.seq():
        s.connect(c.startpoints(c.d(n)), n)

    # add outputs
    for n in s:
        if c.endpoints(n) &amp; c.outputs():
            s.set_output(n, True)

    return s</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.strip_inputs"><code class="name flex">
<span>def <span class="ident">strip_inputs</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts inputs to buffers for easy
instantiation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>circuit to strip inputs from</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Circuit with removed io</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strip_inputs(c):
    &#34;&#34;&#34;
    Converts inputs to buffers for easy
    instantiation.

    Parameters
    ----------
    c : Circuit
            circuit to strip inputs from

    Returns
    -------
    Circuit
            Circuit with removed io
    &#34;&#34;&#34;
    g = c.graph.copy()
    for i in c.inputs():
        g.nodes[i][&#34;type&#34;] = &#34;buf&#34;

    return Circuit(graph=g, name=c.name)</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.strip_io"><code class="name flex">
<span>def <span class="ident">strip_io</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes a circuit's outputs and converts inputs to buffers for easy
instantiation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>circuit to strip io from</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Circuit with removed io</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strip_io(c):
    &#34;&#34;&#34;
    Removes a circuit&#39;s outputs and converts inputs to buffers for easy
    instantiation.

    Parameters
    ----------
    c : Circuit
            circuit to strip io from

    Returns
    -------
    Circuit
            Circuit with removed io
    &#34;&#34;&#34;
    g = c.graph.copy()
    for o in c.outputs():
        g.nodes[o][&#34;output&#34;] = False
    for i in c.inputs():
        g.nodes[i][&#34;type&#34;] = &#34;buf&#34;

    return Circuit(graph=g, name=c.name)</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.strip_outputs"><code class="name flex">
<span>def <span class="ident">strip_outputs</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes a circuit's outputs for easy
instantiation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>circuit to strip io from</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Circuit with removed io</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strip_outputs(c):
    &#34;&#34;&#34;
    Removes a circuit&#39;s outputs for easy
    instantiation.

    Parameters
    ----------
    c : Circuit
            circuit to strip io from

    Returns
    -------
    Circuit
            Circuit with removed io
    &#34;&#34;&#34;
    g = c.graph.copy()
    for o in c.outputs():
        g.nodes[o][&#34;output&#34;] = False

    return Circuit(graph=g, name=c.name)</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.syn"><code class="name flex">
<span>def <span class="ident">syn</span></span>(<span>c, engine, print_output=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Synthesizes the circuit using Genus.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>Circuit to synthesize.</dd>
<dt><strong><code>engine</code></strong> :&ensp;<code>str</code></dt>
<dd>Synthesis tool to use ('Genus' or 'Yosys')</dd>
<dt><strong><code>print_output</code></strong> :&ensp;<code>bool</code></dt>
<dd>Option to print synthesis log</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Synthesized circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def syn(c, engine, print_output=False):
    &#34;&#34;&#34;
    Synthesizes the circuit using Genus.

    Parameters
    ----------
    c : Circuit
            Circuit to synthesize.
    engine : str
            Synthesis tool to use (&#39;Genus&#39; or &#39;Yosys&#39;)
    print_output : bool
            Option to print synthesis log

    Returns
    -------
    Circuit
            Synthesized circuit.
    &#34;&#34;&#34;
    verilog = circuit_to_verilog(c)

    with NamedTemporaryFile(prefix=&#34;circuitgraph_syn_genus_input&#34;) as tmp_in:
        tmp_in.write(bytes(verilog, &#34;ascii&#34;))
        tmp_in.flush()
        with NamedTemporaryFile(prefix=&#34;circuitgraph_syn_genus_output&#34;) as tmp_out:
            if engine == &#34;Genus&#34;:
                cmd = [
                    &#34;genus&#34;,
                    &#34;-no_gui&#34;,
                    &#34;-execute&#34;,
                    &#34;set_db / .library &#34;
                    f&#34;{os.environ[&#39;CIRCUITGRAPH_GENUS_LIBRARY_PATH&#39;]};\n&#34;
                    f&#34;read_hdl -sv {tmp_in.name};\n&#34;
                    &#34;elaborate;\n&#34;
                    &#34;set_db syn_generic_effort high;\n&#34;
                    &#34;syn_generic;\n&#34;
                    &#34;syn_map;\n&#34;
                    &#34;syn_opt;\n&#34;
                    f&#39;redirect {tmp_out.name} &#34;write_hdl -generic&#34;;\n&#39;
                    &#34;exit;&#34;,
                ]
            elif engine == &#34;Yosys&#34;:
                cmd = [
                    &#34;yosys&#34;,
                    &#34;-p&#34;,
                    f&#34;read_verilog {tmp_in.name}; &#34;
                    &#34;proc; opt; fsm; opt; memory; opt; clean; &#34;
                    f&#34;write_verilog -noattr {tmp_out.name}&#34;,
                ]

            else:
                raise ValueError(&#34;synthesis engine must be Yosys or Genus&#34;)

            process = Popen(cmd, stdout=PIPE, stderr=PIPE, universal_newlines=True)
            while True:
                line = process.stdout.readline()
                if line == &#34;&#34; and process.poll() is not None:
                    break
                if line:
                    if print_output:
                        print(line.strip())
            output = tmp_out.read().decode(&#34;utf-8&#34;)
            if print_output:
                print(output)

    return verilog_to_circuit(output, c.name)</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.ternary"><code class="name flex">
<span>def <span class="ident">ternary</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes the circuit with ternary values</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>Circuit to encode.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Encoded circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ternary(c):
    &#34;&#34;&#34;
    Encodes the circuit with ternary values

    Parameters
    ----------
    c : Circuit
            Circuit to encode.

    Returns
    -------
    Circuit
            Encoded circuit.

    &#34;&#34;&#34;
    t = copy(c)

    # add dual nodes
    for n in c:
        if c.type(n) in [&#34;and&#34;, &#34;nand&#34;]:
            t.add(f&#34;{n}_x&#34;, &#34;and&#34;, output=c.output(n))
            t.add(
                f&#34;{n}_x_in_fi&#34;,
                &#34;or&#34;,
                fanout=f&#34;{n}_x&#34;,
                fanin=[f&#34;{p}_x&#34; for p in c.fanin(n)],
            )
            t.add(f&#34;{n}_0_not_in_fi&#34;, &#34;nor&#34;, fanout=f&#34;{n}_x&#34;)

            for p in c.fanin(n):
                t.add(
                    f&#34;{p}_is_0&#34;, &#34;nor&#34;, fanout=f&#34;{n}_0_not_in_fi&#34;, fanin=[p, f&#34;{p}_x&#34;]
                )

        elif c.type(n) in [&#34;or&#34;, &#34;nor&#34;]:
            t.add(f&#34;{n}_x&#34;, &#34;and&#34;, output=c.output(n))
            t.add(
                f&#34;{n}_x_in_fi&#34;,
                &#34;or&#34;,
                fanout=f&#34;{n}_x&#34;,
                fanin=[f&#34;{p}_x&#34; for p in c.fanin(n)],
            )
            t.add(f&#34;{n}_1_not_in_fi&#34;, &#34;nor&#34;, fanout=f&#34;{n}_x&#34;)

            for p in c.fanin(n):
                t.add(f&#34;{p}_is_1&#34;, &#34;and&#34;, fanout=f&#34;{n}_1_not_in_fi&#34;, fanin=p)
                t.add(f&#34;{p}_not_x&#34;, &#34;not&#34;, fanout=f&#34;{p}_is_1&#34;, fanin=f&#34;{p}_x&#34;)

        elif c.type(n) in [&#34;buf&#34;, &#34;not&#34;]:
            p = c.fanin(n).pop()
            t.add(f&#34;{n}_x&#34;, &#34;buf&#34;, output=c.output(n), fanin=f&#34;{p}_x&#34;)

        elif c.type(n) in [&#34;xor&#34;, &#34;xnor&#34;]:
            t.add(
                f&#34;{n}_x&#34;, &#34;or&#34;, output=c.output(n), fanin=(f&#34;{p}_x&#34; for p in c.fanin(n))
            )

        elif c.type(n) in [&#34;0&#34;, &#34;1&#34;]:
            t.add(f&#34;{n}_x&#34;, &#34;0&#34;, output=c.output(n))

        elif c.type(n) in [&#34;input&#34;]:
            t.add(f&#34;{n}_x&#34;, &#34;input&#34;, output=c.output(n))

        elif c.type(n) in [&#34;ff&#34;, &#34;lat&#34;]:
            t.add(
                f&#34;{n}_x&#34;,
                c.type(n),
                output=c.output(n),
                clk=f&#34;{c.clk(n)}_x&#34;,
                r=f&#34;{c.r(n)}_x&#34;,
                s=f&#34;{c.s(n)}_x&#34;,
                fanin=f&#34;{c.fanin(n).pop()}_x&#34;,
            )

        elif c.type(n) in [&#34;0&#34;, &#34;1&#34;]:
            continue

    return t</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.unroll"><code class="name flex">
<span>def <span class="ident">unroll</span></span>(<span>c, cycles)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates combinational unrolling of the circuit.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>Sequential circuit to unroll.</dd>
<dt><strong><code>cycles</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of cycles to unroll</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Unrolled circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unroll(c, cycles):
    &#34;&#34;&#34;
    Creates combinational unrolling of the circuit.

    Parameters
    ----------
    c : Circuit
            Sequential circuit to unroll.
    cycles : int
            Number of cycles to unroll

    Returns
    -------
    Circuit
            Unrolled circuit.

    &#34;&#34;&#34;
    u = Circuit()
    c_comb = comb(c)
    for i in range(cycles):
        u.extend(c_comb, {n: f&#34;{n}_{i}&#34; for n in c_comb})
        if i == 0:
            # convert si to inputs
            for n in c:
                if c.type(n) in [&#34;lat&#34;, &#34;ff&#34;]:
                    u.set_type(f&#34;{n}_si_{i}&#34;, &#34;input&#34;)

        else:
            # connect prev si
            for n in c:
                if c.type(n) in [&#34;lat&#34;, &#34;ff&#34;]:
                    u.connect(f&#34;{n}_si_{i-1}&#34;, f&#34;{n}_si_{i}&#34;)

    return u</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<header>
<img src="circuitgraph.png" alt="" style="margin-bottom: 31px;">
<a class="github-button" href="https://github.com/circuitgraph/circuitgraph"><b>GitHub</b></a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="circuitgraph" href="index.html">circuitgraph</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="circuitgraph.transform.comb" href="#circuitgraph.transform.comb">comb</a></code></li>
<li><code><a title="circuitgraph.transform.copy" href="#circuitgraph.transform.copy">copy</a></code></li>
<li><code><a title="circuitgraph.transform.influence_transform" href="#circuitgraph.transform.influence_transform">influence_transform</a></code></li>
<li><code><a title="circuitgraph.transform.miter" href="#circuitgraph.transform.miter">miter</a></code></li>
<li><code><a title="circuitgraph.transform.relabel" href="#circuitgraph.transform.relabel">relabel</a></code></li>
<li><code><a title="circuitgraph.transform.sensitivity_transform" href="#circuitgraph.transform.sensitivity_transform">sensitivity_transform</a></code></li>
<li><code><a title="circuitgraph.transform.sensitization_transform" href="#circuitgraph.transform.sensitization_transform">sensitization_transform</a></code></li>
<li><code><a title="circuitgraph.transform.seq_graph" href="#circuitgraph.transform.seq_graph">seq_graph</a></code></li>
<li><code><a title="circuitgraph.transform.strip_inputs" href="#circuitgraph.transform.strip_inputs">strip_inputs</a></code></li>
<li><code><a title="circuitgraph.transform.strip_io" href="#circuitgraph.transform.strip_io">strip_io</a></code></li>
<li><code><a title="circuitgraph.transform.strip_outputs" href="#circuitgraph.transform.strip_outputs">strip_outputs</a></code></li>
<li><code><a title="circuitgraph.transform.syn" href="#circuitgraph.transform.syn">syn</a></code></li>
<li><code><a title="circuitgraph.transform.ternary" href="#circuitgraph.transform.ternary">ternary</a></code></li>
<li><code><a title="circuitgraph.transform.unroll" href="#circuitgraph.transform.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>