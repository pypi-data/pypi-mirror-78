# autogenerated module
from dataclasses import dataclass, field
from typing import List

from ..core.dataclasses_json import dataclass_json

from . import util_intstr
from . import meta_v1
from . import resource


@dataclass_json
@dataclass
class AWSElasticBlockStoreVolumeSource:
    volumeID: 'str'
    fsType: 'str' = None
    partition: 'int' = None
    readOnly: 'bool' = None


@dataclass_json
@dataclass
class Affinity:
    nodeAffinity: 'NodeAffinity' = None
    podAffinity: 'PodAffinity' = None
    podAntiAffinity: 'PodAntiAffinity' = None


@dataclass_json
@dataclass
class AttachedVolume:
    devicePath: 'str'
    name: 'str'


@dataclass_json
@dataclass
class AzureDiskVolumeSource:
    diskName: 'str'
    diskURI: 'str'
    cachingMode: 'str' = None
    fsType: 'str' = None
    kind: 'str' = None
    readOnly: 'bool' = None


@dataclass_json
@dataclass
class AzureFilePersistentVolumeSource:
    secretName: 'str'
    shareName: 'str'
    readOnly: 'bool' = None
    secretNamespace: 'str' = None


@dataclass_json
@dataclass
class AzureFileVolumeSource:
    secretName: 'str'
    shareName: 'str'
    readOnly: 'bool' = None


@dataclass_json
@dataclass
class Binding:
    target: 'ObjectReference'
    apiVersion: 'str' = None
    kind: 'str' = None
    metadata: 'meta_v1.ObjectMeta' = None


@dataclass_json
@dataclass
class CSIPersistentVolumeSource:
    driver: 'str'
    volumeHandle: 'str'
    controllerExpandSecretRef: 'SecretReference' = None
    controllerPublishSecretRef: 'SecretReference' = None
    fsType: 'str' = None
    nodePublishSecretRef: 'SecretReference' = None
    nodeStageSecretRef: 'SecretReference' = None
    readOnly: 'bool' = None
    volumeAttributes: 'dict' = None


@dataclass_json
@dataclass
class CSIVolumeSource:
    driver: 'str'
    fsType: 'str' = None
    nodePublishSecretRef: 'LocalObjectReference' = None
    readOnly: 'bool' = None
    volumeAttributes: 'dict' = None


@dataclass_json
@dataclass
class Capabilities:
    add: 'List[str]' = None
    drop: 'List[str]' = None


@dataclass_json
@dataclass
class CephFSPersistentVolumeSource:
    monitors: 'List[str]'
    path: 'str' = None
    readOnly: 'bool' = None
    secretFile: 'str' = None
    secretRef: 'SecretReference' = None
    user: 'str' = None


@dataclass_json
@dataclass
class CephFSVolumeSource:
    monitors: 'List[str]'
    path: 'str' = None
    readOnly: 'bool' = None
    secretFile: 'str' = None
    secretRef: 'LocalObjectReference' = None
    user: 'str' = None


@dataclass_json
@dataclass
class CinderPersistentVolumeSource:
    volumeID: 'str'
    fsType: 'str' = None
    readOnly: 'bool' = None
    secretRef: 'SecretReference' = None


@dataclass_json
@dataclass
class CinderVolumeSource:
    volumeID: 'str'
    fsType: 'str' = None
    readOnly: 'bool' = None
    secretRef: 'LocalObjectReference' = None


@dataclass_json
@dataclass
class ClientIPConfig:
    timeoutSeconds: 'int' = None


@dataclass_json
@dataclass
class ComponentCondition:
    status: 'str'
    type: 'str'
    error: 'str' = None
    message: 'str' = None


@dataclass_json
@dataclass
class ComponentStatus:
    apiVersion: 'str' = None
    conditions: 'List[ComponentCondition]' = None
    kind: 'str' = None
    metadata: 'meta_v1.ObjectMeta' = None


@dataclass_json
@dataclass
class ComponentStatusList:
    items: 'List[ComponentStatus]'
    apiVersion: 'str' = None
    kind: 'str' = None
    metadata: 'meta_v1.ListMeta' = None


@dataclass_json
@dataclass
class ConfigMap:
    apiVersion: 'str' = None
    binaryData: 'dict' = None
    data: 'dict' = None
    kind: 'str' = None
    metadata: 'meta_v1.ObjectMeta' = None


@dataclass_json
@dataclass
class ConfigMapEnvSource:
    name: 'str' = None
    optional: 'bool' = None


@dataclass_json
@dataclass
class ConfigMapKeySelector:
    key: 'str'
    name: 'str' = None
    optional: 'bool' = None


@dataclass_json
@dataclass
class ConfigMapList:
    items: 'List[ConfigMap]'
    apiVersion: 'str' = None
    kind: 'str' = None
    metadata: 'meta_v1.ListMeta' = None


@dataclass_json
@dataclass
class ConfigMapNodeConfigSource:
    kubeletConfigKey: 'str'
    name: 'str'
    namespace: 'str'
    resourceVersion: 'str' = None
    uid: 'str' = None


@dataclass_json
@dataclass
class ConfigMapProjection:
    items: 'List[KeyToPath]' = None
    name: 'str' = None
    optional: 'bool' = None


@dataclass_json
@dataclass
class ConfigMapVolumeSource:
    defaultMode: 'int' = None
    items: 'List[KeyToPath]' = None
    name: 'str' = None
    optional: 'bool' = None


@dataclass_json
@dataclass
class Container:
    name: 'str'
    args: 'List[str]' = None
    command: 'List[str]' = None
    env: 'List[EnvVar]' = None
    envFrom: 'List[EnvFromSource]' = None
    image: 'str' = None
    imagePullPolicy: 'str' = None
    lifecycle: 'Lifecycle' = None
    livenessProbe: 'Probe' = None
    ports: 'List[ContainerPort]' = None
    readinessProbe: 'Probe' = None
    resources: 'ResourceRequirements' = None
    securityContext: 'SecurityContext' = None
    stdin: 'bool' = None
    stdinOnce: 'bool' = None
    terminationMessagePath: 'str' = None
    terminationMessagePolicy: 'str' = None
    tty: 'bool' = None
    volumeDevices: 'List[VolumeDevice]' = None
    volumeMounts: 'List[VolumeMount]' = None
    workingDir: 'str' = None


@dataclass_json
@dataclass
class ContainerImage:
    names: 'List[str]'
    sizeBytes: 'int' = None


@dataclass_json
@dataclass
class ContainerPort:
    containerPort: 'int'
    hostIP: 'str' = None
    hostPort: 'int' = None
    name: 'str' = None
    protocol: 'str' = None


@dataclass_json
@dataclass
class ContainerState:
    running: 'ContainerStateRunning' = None
    terminated: 'ContainerStateTerminated' = None
    waiting: 'ContainerStateWaiting' = None


@dataclass_json
@dataclass
class ContainerStateRunning:
    startedAt: 'meta_v1.Time' = None


@dataclass_json
@dataclass
class ContainerStateTerminated:
    exitCode: 'int'
    containerID: 'str' = None
    finishedAt: 'meta_v1.Time' = None
    message: 'str' = None
    reason: 'str' = None
    signal: 'int' = None
    startedAt: 'meta_v1.Time' = None


@dataclass_json
@dataclass
class ContainerStateWaiting:
    message: 'str' = None
    reason: 'str' = None


@dataclass_json
@dataclass
class ContainerStatus:
    image: 'str'
    imageID: 'str'
    name: 'str'
    ready: 'bool'
    restartCount: 'int'
    containerID: 'str' = None
    lastState: 'ContainerState' = None
    state: 'ContainerState' = None


@dataclass_json
@dataclass
class DaemonEndpoint:
    Port: 'int'


@dataclass_json
@dataclass
class DownwardAPIProjection:
    items: 'List[DownwardAPIVolumeFile]' = None


@dataclass_json
@dataclass
class DownwardAPIVolumeFile:
    path: 'str'
    fieldRef: 'ObjectFieldSelector' = None
    mode: 'int' = None
    resourceFieldRef: 'ResourceFieldSelector' = None


@dataclass_json
@dataclass
class DownwardAPIVolumeSource:
    defaultMode: 'int' = None
    items: 'List[DownwardAPIVolumeFile]' = None


@dataclass_json
@dataclass
class EmptyDirVolumeSource:
    medium: 'str' = None
    sizeLimit: 'resource.Quantity' = None


@dataclass_json
@dataclass
class EndpointAddress:
    ip: 'str'
    hostname: 'str' = None
    nodeName: 'str' = None
    targetRef: 'ObjectReference' = None


@dataclass_json
@dataclass
class EndpointPort:
    port: 'int'
    name: 'str' = None
    protocol: 'str' = None


@dataclass_json
@dataclass
class EndpointSubset:
    addresses: 'List[EndpointAddress]' = None
    notReadyAddresses: 'List[EndpointAddress]' = None
    ports: 'List[EndpointPort]' = None


@dataclass_json
@dataclass
class Endpoints:
    apiVersion: 'str' = None
    kind: 'str' = None
    metadata: 'meta_v1.ObjectMeta' = None
    subsets: 'List[EndpointSubset]' = None


@dataclass_json
@dataclass
class EndpointsList:
    items: 'List[Endpoints]'
    apiVersion: 'str' = None
    kind: 'str' = None
    metadata: 'meta_v1.ListMeta' = None


@dataclass_json
@dataclass
class EnvFromSource:
    configMapRef: 'ConfigMapEnvSource' = None
    prefix: 'str' = None
    secretRef: 'SecretEnvSource' = None


@dataclass_json
@dataclass
class EnvVar:
    name: 'str'
    value: 'str' = None
    valueFrom: 'EnvVarSource' = None


@dataclass_json
@dataclass
class EnvVarSource:
    configMapKeyRef: 'ConfigMapKeySelector' = None
    fieldRef: 'ObjectFieldSelector' = None
    resourceFieldRef: 'ResourceFieldSelector' = None
    secretKeyRef: 'SecretKeySelector' = None


@dataclass_json
@dataclass
class Event:
    involvedObject: 'ObjectReference'
    metadata: 'meta_v1.ObjectMeta'
    action: 'str' = None
    apiVersion: 'str' = None
    count: 'int' = None
    eventTime: 'meta_v1.MicroTime' = None
    firstTimestamp: 'meta_v1.Time' = None
    kind: 'str' = None
    lastTimestamp: 'meta_v1.Time' = None
    message: 'str' = None
    reason: 'str' = None
    related: 'ObjectReference' = None
    reportingComponent: 'str' = None
    reportingInstance: 'str' = None
    series: 'EventSeries' = None
    source: 'EventSource' = None
    type: 'str' = None


@dataclass_json
@dataclass
class EventList:
    items: 'List[Event]'
    apiVersion: 'str' = None
    kind: 'str' = None
    metadata: 'meta_v1.ListMeta' = None


@dataclass_json
@dataclass
class EventSeries:
    count: 'int' = None
    lastObservedTime: 'meta_v1.MicroTime' = None
    state: 'str' = None


@dataclass_json
@dataclass
class EventSource:
    component: 'str' = None
    host: 'str' = None


@dataclass_json
@dataclass
class ExecAction:
    command: 'List[str]' = None


@dataclass_json
@dataclass
class FCVolumeSource:
    fsType: 'str' = None
    lun: 'int' = None
    readOnly: 'bool' = None
    targetWWNs: 'List[str]' = None
    wwids: 'List[str]' = None


@dataclass_json
@dataclass
class FlexPersistentVolumeSource:
    driver: 'str'
    fsType: 'str' = None
    options: 'dict' = None
    readOnly: 'bool' = None
    secretRef: 'SecretReference' = None


@dataclass_json
@dataclass
class FlexVolumeSource:
    driver: 'str'
    fsType: 'str' = None
    options: 'dict' = None
    readOnly: 'bool' = None
    secretRef: 'LocalObjectReference' = None


@dataclass_json
@dataclass
class FlockerVolumeSource:
    datasetName: 'str' = None
    datasetUUID: 'str' = None


@dataclass_json
@dataclass
class GCEPersistentDiskVolumeSource:
    pdName: 'str'
    fsType: 'str' = None
    partition: 'int' = None
    readOnly: 'bool' = None


@dataclass_json
@dataclass
class GitRepoVolumeSource:
    repository: 'str'
    directory: 'str' = None
    revision: 'str' = None


@dataclass_json
@dataclass
class GlusterfsPersistentVolumeSource:
    endpoints: 'str'
    path: 'str'
    endpointsNamespace: 'str' = None
    readOnly: 'bool' = None


@dataclass_json
@dataclass
class GlusterfsVolumeSource:
    endpoints: 'str'
    path: 'str'
    readOnly: 'bool' = None


@dataclass_json
@dataclass
class HTTPGetAction:
    port: 'util_intstr.IntOrString'
    host: 'str' = None
    httpHeaders: 'List[HTTPHeader]' = None
    path: 'str' = None
    scheme: 'str' = None


@dataclass_json
@dataclass
class HTTPHeader:
    name: 'str'
    value: 'str'


@dataclass_json
@dataclass
class Handler:
    exec: 'ExecAction' = None
    httpGet: 'HTTPGetAction' = None
    tcpSocket: 'TCPSocketAction' = None


@dataclass_json
@dataclass
class HostAlias:
    hostnames: 'List[str]' = None
    ip: 'str' = None


@dataclass_json
@dataclass
class HostPathVolumeSource:
    path: 'str'
    type: 'str' = None


@dataclass_json
@dataclass
class ISCSIPersistentVolumeSource:
    iqn: 'str'
    lun: 'int'
    targetPortal: 'str'
    chapAuthDiscovery: 'bool' = None
    chapAuthSession: 'bool' = None
    fsType: 'str' = None
    initiatorName: 'str' = None
    iscsiInterface: 'str' = None
    portals: 'List[str]' = None
    readOnly: 'bool' = None
    secretRef: 'SecretReference' = None


@dataclass_json
@dataclass
class ISCSIVolumeSource:
    iqn: 'str'
    lun: 'int'
    targetPortal: 'str'
    chapAuthDiscovery: 'bool' = None
    chapAuthSession: 'bool' = None
    fsType: 'str' = None
    initiatorName: 'str' = None
    iscsiInterface: 'str' = None
    portals: 'List[str]' = None
    readOnly: 'bool' = None
    secretRef: 'LocalObjectReference' = None


@dataclass_json
@dataclass
class KeyToPath:
    key: 'str'
    path: 'str'
    mode: 'int' = None


@dataclass_json
@dataclass
class Lifecycle:
    postStart: 'Handler' = None
    preStop: 'Handler' = None


@dataclass_json
@dataclass
class LimitRange:
    apiVersion: 'str' = None
    kind: 'str' = None
    metadata: 'meta_v1.ObjectMeta' = None
    spec: 'LimitRangeSpec' = None


@dataclass_json
@dataclass
class LimitRangeItem:
    default: 'dict' = None
    defaultRequest: 'dict' = None
    max: 'dict' = None
    maxLimitRequestRatio: 'dict' = None
    min: 'dict' = None
    type: 'str' = None


@dataclass_json
@dataclass
class LimitRangeList:
    items: 'List[LimitRange]'
    apiVersion: 'str' = None
    kind: 'str' = None
    metadata: 'meta_v1.ListMeta' = None


@dataclass_json
@dataclass
class LimitRangeSpec:
    limits: 'List[LimitRangeItem]'


@dataclass_json
@dataclass
class LoadBalancerIngress:
    hostname: 'str' = None
    ip: 'str' = None


@dataclass_json
@dataclass
class LoadBalancerStatus:
    ingress: 'List[LoadBalancerIngress]' = None


@dataclass_json
@dataclass
class LocalObjectReference:
    name: 'str' = None


@dataclass_json
@dataclass
class LocalVolumeSource:
    path: 'str'
    fsType: 'str' = None


@dataclass_json
@dataclass
class NFSVolumeSource:
    path: 'str'
    server: 'str'
    readOnly: 'bool' = None


@dataclass_json
@dataclass
class Namespace:
    apiVersion: 'str' = None
    kind: 'str' = None
    metadata: 'meta_v1.ObjectMeta' = None
    spec: 'NamespaceSpec' = None
    status: 'NamespaceStatus' = None


@dataclass_json
@dataclass
class NamespaceList:
    items: 'List[Namespace]'
    apiVersion: 'str' = None
    kind: 'str' = None
    metadata: 'meta_v1.ListMeta' = None


@dataclass_json
@dataclass
class NamespaceSpec:
    finalizers: 'List[str]' = None


@dataclass_json
@dataclass
class NamespaceStatus:
    phase: 'str' = None


@dataclass_json
@dataclass
class Node:
    apiVersion: 'str' = None
    kind: 'str' = None
    metadata: 'meta_v1.ObjectMeta' = None
    spec: 'NodeSpec' = None
    status: 'NodeStatus' = None


@dataclass_json
@dataclass
class NodeAddress:
    address: 'str'
    type: 'str'


@dataclass_json
@dataclass
class NodeAffinity:
    preferredDuringSchedulingIgnoredDuringExecution: 'List[PreferredSchedulingTerm]' = None
    requiredDuringSchedulingIgnoredDuringExecution: 'NodeSelector' = None


@dataclass_json
@dataclass
class NodeCondition:
    status: 'str'
    type: 'str'
    lastHeartbeatTime: 'meta_v1.Time' = None
    lastTransitionTime: 'meta_v1.Time' = None
    message: 'str' = None
    reason: 'str' = None


@dataclass_json
@dataclass
class NodeConfigSource:
    configMap: 'ConfigMapNodeConfigSource' = None


@dataclass_json
@dataclass
class NodeConfigStatus:
    active: 'NodeConfigSource' = None
    assigned: 'NodeConfigSource' = None
    error: 'str' = None
    lastKnownGood: 'NodeConfigSource' = None


@dataclass_json
@dataclass
class NodeDaemonEndpoints:
    kubeletEndpoint: 'DaemonEndpoint' = None


@dataclass_json
@dataclass
class NodeList:
    items: 'List[Node]'
    apiVersion: 'str' = None
    kind: 'str' = None
    metadata: 'meta_v1.ListMeta' = None


@dataclass_json
@dataclass
class NodeSelector:
    nodeSelectorTerms: 'List[NodeSelectorTerm]'


@dataclass_json
@dataclass
class NodeSelectorRequirement:
    key: 'str'
    operator: 'str'
    values: 'List[str]' = None


@dataclass_json
@dataclass
class NodeSelectorTerm:
    matchExpressions: 'List[NodeSelectorRequirement]' = None
    matchFields: 'List[NodeSelectorRequirement]' = None


@dataclass_json
@dataclass
class NodeSpec:
    configSource: 'NodeConfigSource' = None
    externalID: 'str' = None
    podCIDR: 'str' = None
    providerID: 'str' = None
    taints: 'List[Taint]' = None
    unschedulable: 'bool' = None


@dataclass_json
@dataclass
class NodeStatus:
    addresses: 'List[NodeAddress]' = None
    allocatable: 'dict' = None
    capacity: 'dict' = None
    conditions: 'List[NodeCondition]' = None
    config: 'NodeConfigStatus' = None
    daemonEndpoints: 'NodeDaemonEndpoints' = None
    images: 'List[ContainerImage]' = None
    nodeInfo: 'NodeSystemInfo' = None
    phase: 'str' = None
    volumesAttached: 'List[AttachedVolume]' = None
    volumesInUse: 'List[str]' = None


@dataclass_json
@dataclass
class NodeSystemInfo:
    architecture: 'str'
    bootID: 'str'
    containerRuntimeVersion: 'str'
    kernelVersion: 'str'
    kubeProxyVersion: 'str'
    kubeletVersion: 'str'
    machineID: 'str'
    operatingSystem: 'str'
    osImage: 'str'
    systemUUID: 'str'


@dataclass_json
@dataclass
class ObjectFieldSelector:
    fieldPath: 'str'
    apiVersion: 'str' = None


@dataclass_json
@dataclass
class ObjectReference:
    apiVersion: 'str' = None
    fieldPath: 'str' = None
    kind: 'str' = None
    name: 'str' = None
    namespace: 'str' = None
    resourceVersion: 'str' = None
    uid: 'str' = None


@dataclass_json
@dataclass
class PersistentVolume:
    apiVersion: 'str' = None
    kind: 'str' = None
    metadata: 'meta_v1.ObjectMeta' = None
    spec: 'PersistentVolumeSpec' = None
    status: 'PersistentVolumeStatus' = None


@dataclass_json
@dataclass
class PersistentVolumeClaim:
    apiVersion: 'str' = None
    kind: 'str' = None
    metadata: 'meta_v1.ObjectMeta' = None
    spec: 'PersistentVolumeClaimSpec' = None
    status: 'PersistentVolumeClaimStatus' = None


@dataclass_json
@dataclass
class PersistentVolumeClaimCondition:
    status: 'str'
    type: 'str'
    lastProbeTime: 'meta_v1.Time' = None
    lastTransitionTime: 'meta_v1.Time' = None
    message: 'str' = None
    reason: 'str' = None


@dataclass_json
@dataclass
class PersistentVolumeClaimList:
    items: 'List[PersistentVolumeClaim]'
    apiVersion: 'str' = None
    kind: 'str' = None
    metadata: 'meta_v1.ListMeta' = None


@dataclass_json
@dataclass
class PersistentVolumeClaimSpec:
    accessModes: 'List[str]' = None
    dataSource: 'TypedLocalObjectReference' = None
    resources: 'ResourceRequirements' = None
    selector: 'meta_v1.LabelSelector' = None
    storageClassName: 'str' = None
    volumeMode: 'str' = None
    volumeName: 'str' = None


@dataclass_json
@dataclass
class PersistentVolumeClaimStatus:
    accessModes: 'List[str]' = None
    capacity: 'dict' = None
    conditions: 'List[PersistentVolumeClaimCondition]' = None
    phase: 'str' = None


@dataclass_json
@dataclass
class PersistentVolumeClaimVolumeSource:
    claimName: 'str'
    readOnly: 'bool' = None


@dataclass_json
@dataclass
class PersistentVolumeList:
    items: 'List[PersistentVolume]'
    apiVersion: 'str' = None
    kind: 'str' = None
    metadata: 'meta_v1.ListMeta' = None


@dataclass_json
@dataclass
class PersistentVolumeSpec:
    accessModes: 'List[str]' = None
    awsElasticBlockStore: 'AWSElasticBlockStoreVolumeSource' = None
    azureDisk: 'AzureDiskVolumeSource' = None
    azureFile: 'AzureFilePersistentVolumeSource' = None
    capacity: 'dict' = None
    cephfs: 'CephFSPersistentVolumeSource' = None
    cinder: 'CinderPersistentVolumeSource' = None
    claimRef: 'ObjectReference' = None
    csi: 'CSIPersistentVolumeSource' = None
    fc: 'FCVolumeSource' = None
    flexVolume: 'FlexPersistentVolumeSource' = None
    flocker: 'FlockerVolumeSource' = None
    gcePersistentDisk: 'GCEPersistentDiskVolumeSource' = None
    glusterfs: 'GlusterfsPersistentVolumeSource' = None
    hostPath: 'HostPathVolumeSource' = None
    iscsi: 'ISCSIPersistentVolumeSource' = None
    local: 'LocalVolumeSource' = None
    mountOptions: 'List[str]' = None
    nfs: 'NFSVolumeSource' = None
    nodeAffinity: 'VolumeNodeAffinity' = None
    persistentVolumeReclaimPolicy: 'str' = None
    photonPersistentDisk: 'PhotonPersistentDiskVolumeSource' = None
    portworxVolume: 'PortworxVolumeSource' = None
    quobyte: 'QuobyteVolumeSource' = None
    rbd: 'RBDPersistentVolumeSource' = None
    scaleIO: 'ScaleIOPersistentVolumeSource' = None
    storageClassName: 'str' = None
    storageos: 'StorageOSPersistentVolumeSource' = None
    volumeMode: 'str' = None
    vsphereVolume: 'VsphereVirtualDiskVolumeSource' = None


@dataclass_json
@dataclass
class PersistentVolumeStatus:
    message: 'str' = None
    phase: 'str' = None
    reason: 'str' = None


@dataclass_json
@dataclass
class PhotonPersistentDiskVolumeSource:
    pdID: 'str'
    fsType: 'str' = None


@dataclass_json
@dataclass
class Pod:
    apiVersion: 'str' = None
    kind: 'str' = None
    metadata: 'meta_v1.ObjectMeta' = None
    spec: 'PodSpec' = None
    status: 'PodStatus' = None


@dataclass_json
@dataclass
class PodAffinity:
    preferredDuringSchedulingIgnoredDuringExecution: 'List[WeightedPodAffinityTerm]' = None
    requiredDuringSchedulingIgnoredDuringExecution: 'List[PodAffinityTerm]' = None


@dataclass_json
@dataclass
class PodAffinityTerm:
    topologyKey: 'str'
    labelSelector: 'meta_v1.LabelSelector' = None
    namespaces: 'List[str]' = None


@dataclass_json
@dataclass
class PodAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution: 'List[WeightedPodAffinityTerm]' = None
    requiredDuringSchedulingIgnoredDuringExecution: 'List[PodAffinityTerm]' = None


@dataclass_json
@dataclass
class PodCondition:
    status: 'str'
    type: 'str'
    lastProbeTime: 'meta_v1.Time' = None
    lastTransitionTime: 'meta_v1.Time' = None
    message: 'str' = None
    reason: 'str' = None


@dataclass_json
@dataclass
class PodDNSConfig:
    nameservers: 'List[str]' = None
    options: 'List[PodDNSConfigOption]' = None
    searches: 'List[str]' = None


@dataclass_json
@dataclass
class PodDNSConfigOption:
    name: 'str' = None
    value: 'str' = None


@dataclass_json
@dataclass
class PodList:
    items: 'List[Pod]'
    apiVersion: 'str' = None
    kind: 'str' = None
    metadata: 'meta_v1.ListMeta' = None


@dataclass_json
@dataclass
class PodReadinessGate:
    conditionType: 'str'


@dataclass_json
@dataclass
class PodSecurityContext:
    fsGroup: 'int' = None
    runAsGroup: 'int' = None
    runAsNonRoot: 'bool' = None
    runAsUser: 'int' = None
    seLinuxOptions: 'SELinuxOptions' = None
    supplementalGroups: 'List[int]' = None
    sysctls: 'List[Sysctl]' = None
    windowsOptions: 'WindowsSecurityContextOptions' = None


@dataclass_json
@dataclass
class PodSpec:
    containers: 'List[Container]'
    activeDeadlineSeconds: 'int' = None
    affinity: 'Affinity' = None
    automountServiceAccountToken: 'bool' = None
    dnsConfig: 'PodDNSConfig' = None
    dnsPolicy: 'str' = None
    enableServiceLinks: 'bool' = None
    hostAliases: 'List[HostAlias]' = None
    hostIPC: 'bool' = None
    hostNetwork: 'bool' = None
    hostPID: 'bool' = None
    hostname: 'str' = None
    imagePullSecrets: 'List[LocalObjectReference]' = None
    initContainers: 'List[Container]' = None
    nodeName: 'str' = None
    nodeSelector: 'dict' = None
    preemptionPolicy: 'str' = None
    priority: 'int' = None
    priorityClassName: 'str' = None
    readinessGates: 'List[PodReadinessGate]' = None
    restartPolicy: 'str' = None
    runtimeClassName: 'str' = None
    schedulerName: 'str' = None
    securityContext: 'PodSecurityContext' = None
    serviceAccount: 'str' = None
    serviceAccountName: 'str' = None
    shareProcessNamespace: 'bool' = None
    subdomain: 'str' = None
    terminationGracePeriodSeconds: 'int' = None
    tolerations: 'List[Toleration]' = None
    volumes: 'List[Volume]' = None


@dataclass_json
@dataclass
class PodStatus:
    conditions: 'List[PodCondition]' = None
    containerStatuses: 'List[ContainerStatus]' = None
    hostIP: 'str' = None
    initContainerStatuses: 'List[ContainerStatus]' = None
    message: 'str' = None
    nominatedNodeName: 'str' = None
    phase: 'str' = None
    podIP: 'str' = None
    qosClass: 'str' = None
    reason: 'str' = None
    startTime: 'meta_v1.Time' = None


@dataclass_json
@dataclass
class PodTemplate:
    apiVersion: 'str' = None
    kind: 'str' = None
    metadata: 'meta_v1.ObjectMeta' = None
    template: 'PodTemplateSpec' = None


@dataclass_json
@dataclass
class PodTemplateList:
    items: 'List[PodTemplate]'
    apiVersion: 'str' = None
    kind: 'str' = None
    metadata: 'meta_v1.ListMeta' = None


@dataclass_json
@dataclass
class PodTemplateSpec:
    metadata: 'meta_v1.ObjectMeta' = None
    spec: 'PodSpec' = None


@dataclass_json
@dataclass
class PortworxVolumeSource:
    volumeID: 'str'
    fsType: 'str' = None
    readOnly: 'bool' = None


@dataclass_json
@dataclass
class PreferredSchedulingTerm:
    preference: 'NodeSelectorTerm'
    weight: 'int'


@dataclass_json
@dataclass
class Probe:
    exec: 'ExecAction' = None
    failureThreshold: 'int' = None
    httpGet: 'HTTPGetAction' = None
    initialDelaySeconds: 'int' = None
    periodSeconds: 'int' = None
    successThreshold: 'int' = None
    tcpSocket: 'TCPSocketAction' = None
    timeoutSeconds: 'int' = None


@dataclass_json
@dataclass
class ProjectedVolumeSource:
    sources: 'List[VolumeProjection]'
    defaultMode: 'int' = None


@dataclass_json
@dataclass
class QuobyteVolumeSource:
    registry: 'str'
    volume: 'str'
    group: 'str' = None
    readOnly: 'bool' = None
    tenant: 'str' = None
    user: 'str' = None


@dataclass_json
@dataclass
class RBDPersistentVolumeSource:
    image: 'str'
    monitors: 'List[str]'
    fsType: 'str' = None
    keyring: 'str' = None
    pool: 'str' = None
    readOnly: 'bool' = None
    secretRef: 'SecretReference' = None
    user: 'str' = None


@dataclass_json
@dataclass
class RBDVolumeSource:
    image: 'str'
    monitors: 'List[str]'
    fsType: 'str' = None
    keyring: 'str' = None
    pool: 'str' = None
    readOnly: 'bool' = None
    secretRef: 'LocalObjectReference' = None
    user: 'str' = None


@dataclass_json
@dataclass
class ReplicationController:
    apiVersion: 'str' = None
    kind: 'str' = None
    metadata: 'meta_v1.ObjectMeta' = None
    spec: 'ReplicationControllerSpec' = None
    status: 'ReplicationControllerStatus' = None


@dataclass_json
@dataclass
class ReplicationControllerCondition:
    status: 'str'
    type: 'str'
    lastTransitionTime: 'meta_v1.Time' = None
    message: 'str' = None
    reason: 'str' = None


@dataclass_json
@dataclass
class ReplicationControllerList:
    items: 'List[ReplicationController]'
    apiVersion: 'str' = None
    kind: 'str' = None
    metadata: 'meta_v1.ListMeta' = None


@dataclass_json
@dataclass
class ReplicationControllerSpec:
    minReadySeconds: 'int' = None
    replicas: 'int' = None
    selector: 'dict' = None
    template: 'PodTemplateSpec' = None


@dataclass_json
@dataclass
class ReplicationControllerStatus:
    replicas: 'int'
    availableReplicas: 'int' = None
    conditions: 'List[ReplicationControllerCondition]' = None
    fullyLabeledReplicas: 'int' = None
    observedGeneration: 'int' = None
    readyReplicas: 'int' = None


@dataclass_json
@dataclass
class ResourceFieldSelector:
    resource: 'str'
    containerName: 'str' = None
    divisor: 'resource.Quantity' = None


@dataclass_json
@dataclass
class ResourceQuota:
    apiVersion: 'str' = None
    kind: 'str' = None
    metadata: 'meta_v1.ObjectMeta' = None
    spec: 'ResourceQuotaSpec' = None
    status: 'ResourceQuotaStatus' = None


@dataclass_json
@dataclass
class ResourceQuotaList:
    items: 'List[ResourceQuota]'
    apiVersion: 'str' = None
    kind: 'str' = None
    metadata: 'meta_v1.ListMeta' = None


@dataclass_json
@dataclass
class ResourceQuotaSpec:
    hard: 'dict' = None
    scopeSelector: 'ScopeSelector' = None
    scopes: 'List[str]' = None


@dataclass_json
@dataclass
class ResourceQuotaStatus:
    hard: 'dict' = None
    used: 'dict' = None


@dataclass_json
@dataclass
class ResourceRequirements:
    limits: 'dict' = None
    requests: 'dict' = None


@dataclass_json
@dataclass
class SELinuxOptions:
    level: 'str' = None
    role: 'str' = None
    type: 'str' = None
    user: 'str' = None


@dataclass_json
@dataclass
class ScaleIOPersistentVolumeSource:
    gateway: 'str'
    secretRef: 'SecretReference'
    system: 'str'
    fsType: 'str' = None
    protectionDomain: 'str' = None
    readOnly: 'bool' = None
    sslEnabled: 'bool' = None
    storageMode: 'str' = None
    storagePool: 'str' = None
    volumeName: 'str' = None


@dataclass_json
@dataclass
class ScaleIOVolumeSource:
    gateway: 'str'
    secretRef: 'LocalObjectReference'
    system: 'str'
    fsType: 'str' = None
    protectionDomain: 'str' = None
    readOnly: 'bool' = None
    sslEnabled: 'bool' = None
    storageMode: 'str' = None
    storagePool: 'str' = None
    volumeName: 'str' = None


@dataclass_json
@dataclass
class ScopeSelector:
    matchExpressions: 'List[ScopedResourceSelectorRequirement]' = None


@dataclass_json
@dataclass
class ScopedResourceSelectorRequirement:
    operator: 'str'
    scopeName: 'str'
    values: 'List[str]' = None


@dataclass_json
@dataclass
class Secret:
    apiVersion: 'str' = None
    data: 'dict' = None
    kind: 'str' = None
    metadata: 'meta_v1.ObjectMeta' = None
    stringData: 'dict' = None
    type: 'str' = None


@dataclass_json
@dataclass
class SecretEnvSource:
    name: 'str' = None
    optional: 'bool' = None


@dataclass_json
@dataclass
class SecretKeySelector:
    key: 'str'
    name: 'str' = None
    optional: 'bool' = None


@dataclass_json
@dataclass
class SecretList:
    items: 'List[Secret]'
    apiVersion: 'str' = None
    kind: 'str' = None
    metadata: 'meta_v1.ListMeta' = None


@dataclass_json
@dataclass
class SecretProjection:
    items: 'List[KeyToPath]' = None
    name: 'str' = None
    optional: 'bool' = None


@dataclass_json
@dataclass
class SecretReference:
    name: 'str' = None
    namespace: 'str' = None


@dataclass_json
@dataclass
class SecretVolumeSource:
    defaultMode: 'int' = None
    items: 'List[KeyToPath]' = None
    optional: 'bool' = None
    secretName: 'str' = None


@dataclass_json
@dataclass
class SecurityContext:
    allowPrivilegeEscalation: 'bool' = None
    capabilities: 'Capabilities' = None
    privileged: 'bool' = None
    procMount: 'str' = None
    readOnlyRootFilesystem: 'bool' = None
    runAsGroup: 'int' = None
    runAsNonRoot: 'bool' = None
    runAsUser: 'int' = None
    seLinuxOptions: 'SELinuxOptions' = None
    windowsOptions: 'WindowsSecurityContextOptions' = None


@dataclass_json
@dataclass
class Service:
    apiVersion: 'str' = None
    kind: 'str' = None
    metadata: 'meta_v1.ObjectMeta' = None
    spec: 'ServiceSpec' = None
    status: 'ServiceStatus' = None


@dataclass_json
@dataclass
class ServiceAccount:
    apiVersion: 'str' = None
    automountServiceAccountToken: 'bool' = None
    imagePullSecrets: 'List[LocalObjectReference]' = None
    kind: 'str' = None
    metadata: 'meta_v1.ObjectMeta' = None
    secrets: 'List[ObjectReference]' = None


@dataclass_json
@dataclass
class ServiceAccountList:
    items: 'List[ServiceAccount]'
    apiVersion: 'str' = None
    kind: 'str' = None
    metadata: 'meta_v1.ListMeta' = None


@dataclass_json
@dataclass
class ServiceAccountTokenProjection:
    path: 'str'
    audience: 'str' = None
    expirationSeconds: 'int' = None


@dataclass_json
@dataclass
class ServiceList:
    items: 'List[Service]'
    apiVersion: 'str' = None
    kind: 'str' = None
    metadata: 'meta_v1.ListMeta' = None


@dataclass_json
@dataclass
class ServicePort:
    port: 'int'
    name: 'str' = None
    nodePort: 'int' = None
    protocol: 'str' = None
    targetPort: 'util_intstr.IntOrString' = None


@dataclass_json
@dataclass
class ServiceSpec:
    clusterIP: 'str' = None
    externalIPs: 'List[str]' = None
    externalName: 'str' = None
    externalTrafficPolicy: 'str' = None
    healthCheckNodePort: 'int' = None
    loadBalancerIP: 'str' = None
    loadBalancerSourceRanges: 'List[str]' = None
    ports: 'List[ServicePort]' = None
    publishNotReadyAddresses: 'bool' = None
    selector: 'dict' = None
    sessionAffinity: 'str' = None
    sessionAffinityConfig: 'SessionAffinityConfig' = None
    type: 'str' = None


@dataclass_json
@dataclass
class ServiceStatus:
    loadBalancer: 'LoadBalancerStatus' = None


@dataclass_json
@dataclass
class SessionAffinityConfig:
    clientIP: 'ClientIPConfig' = None


@dataclass_json
@dataclass
class StorageOSPersistentVolumeSource:
    fsType: 'str' = None
    readOnly: 'bool' = None
    secretRef: 'ObjectReference' = None
    volumeName: 'str' = None
    volumeNamespace: 'str' = None


@dataclass_json
@dataclass
class StorageOSVolumeSource:
    fsType: 'str' = None
    readOnly: 'bool' = None
    secretRef: 'LocalObjectReference' = None
    volumeName: 'str' = None
    volumeNamespace: 'str' = None


@dataclass_json
@dataclass
class Sysctl:
    name: 'str'
    value: 'str'


@dataclass_json
@dataclass
class TCPSocketAction:
    port: 'util_intstr.IntOrString'
    host: 'str' = None


@dataclass_json
@dataclass
class Taint:
    effect: 'str'
    key: 'str'
    timeAdded: 'meta_v1.Time' = None
    value: 'str' = None


@dataclass_json
@dataclass
class Toleration:
    effect: 'str' = None
    key: 'str' = None
    operator: 'str' = None
    tolerationSeconds: 'int' = None
    value: 'str' = None


@dataclass_json
@dataclass
class TopologySelectorLabelRequirement:
    key: 'str'
    values: 'List[str]'


@dataclass_json
@dataclass
class TopologySelectorTerm:
    matchLabelExpressions: 'List[TopologySelectorLabelRequirement]' = None


@dataclass_json
@dataclass
class TypedLocalObjectReference:
    kind: 'str'
    name: 'str'
    apiGroup: 'str' = None


@dataclass_json
@dataclass
class Volume:
    name: 'str'
    awsElasticBlockStore: 'AWSElasticBlockStoreVolumeSource' = None
    azureDisk: 'AzureDiskVolumeSource' = None
    azureFile: 'AzureFileVolumeSource' = None
    cephfs: 'CephFSVolumeSource' = None
    cinder: 'CinderVolumeSource' = None
    configMap: 'ConfigMapVolumeSource' = None
    csi: 'CSIVolumeSource' = None
    downwardAPI: 'DownwardAPIVolumeSource' = None
    emptyDir: 'EmptyDirVolumeSource' = None
    fc: 'FCVolumeSource' = None
    flexVolume: 'FlexVolumeSource' = None
    flocker: 'FlockerVolumeSource' = None
    gcePersistentDisk: 'GCEPersistentDiskVolumeSource' = None
    gitRepo: 'GitRepoVolumeSource' = None
    glusterfs: 'GlusterfsVolumeSource' = None
    hostPath: 'HostPathVolumeSource' = None
    iscsi: 'ISCSIVolumeSource' = None
    nfs: 'NFSVolumeSource' = None
    persistentVolumeClaim: 'PersistentVolumeClaimVolumeSource' = None
    photonPersistentDisk: 'PhotonPersistentDiskVolumeSource' = None
    portworxVolume: 'PortworxVolumeSource' = None
    projected: 'ProjectedVolumeSource' = None
    quobyte: 'QuobyteVolumeSource' = None
    rbd: 'RBDVolumeSource' = None
    scaleIO: 'ScaleIOVolumeSource' = None
    secret: 'SecretVolumeSource' = None
    storageos: 'StorageOSVolumeSource' = None
    vsphereVolume: 'VsphereVirtualDiskVolumeSource' = None


@dataclass_json
@dataclass
class VolumeDevice:
    devicePath: 'str'
    name: 'str'


@dataclass_json
@dataclass
class VolumeMount:
    mountPath: 'str'
    name: 'str'
    mountPropagation: 'str' = None
    readOnly: 'bool' = None
    subPath: 'str' = None
    subPathExpr: 'str' = None


@dataclass_json
@dataclass
class VolumeNodeAffinity:
    required: 'NodeSelector' = None


@dataclass_json
@dataclass
class VolumeProjection:
    configMap: 'ConfigMapProjection' = None
    downwardAPI: 'DownwardAPIProjection' = None
    secret: 'SecretProjection' = None
    serviceAccountToken: 'ServiceAccountTokenProjection' = None


@dataclass_json
@dataclass
class VsphereVirtualDiskVolumeSource:
    volumePath: 'str'
    fsType: 'str' = None
    storagePolicyID: 'str' = None
    storagePolicyName: 'str' = None


@dataclass_json
@dataclass
class WeightedPodAffinityTerm:
    podAffinityTerm: 'PodAffinityTerm'
    weight: 'int'


@dataclass_json
@dataclass
class WindowsSecurityContextOptions:
    gmsaCredentialSpec: 'str' = None
    gmsaCredentialSpecName: 'str' = None


